<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Theater Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Theater Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/colinrozzi/theater" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="theater-documentation"><a class="header" href="#theater-documentation">Theater Documentation</a></h1>
<p>Welcome to the official documentation for Theater, a WebAssembly actor system designed for building secure, reliable, and transparent AI agent infrastructure.</p>
<h2 id="how-to-use-this-documentation"><a class="header" href="#how-to-use-this-documentation">How to Use This Documentation</a></h2>
<p>This documentation is organized into sections:</p>
<ul>
<li><strong>Introduction</strong>: Understand why Theater exists and the challenges it addresses in AI agent systems</li>
<li><strong>Core Concepts</strong>: Learn what Theater is and its fundamental principles</li>
<li><strong>Use Cases</strong>: Explore how Theater can be applied to build robust AI agent systems</li>
<li><strong>User Guide</strong>: Find practical information on using Theater in your projects</li>
<li><strong>Development</strong>: Learn how to build agents and extend Theater's functionality</li>
<li><strong>Services</strong>: Explore the built-in services and handler systems</li>
<li><strong>API Reference</strong>: Access detailed API documentation</li>
</ul>
<h2 id="the-three-pillars-of-theater"><a class="header" href="#the-three-pillars-of-theater">The Three Pillars of Theater</a></h2>
<p>Theater is built on three foundational pillars that make it ideal for AI agent infrastructure:</p>
<ol>
<li><strong><a href="core-concepts/wasm-components.html">WebAssembly Components &amp; Sandboxing</a></strong>: Security boundaries and capability controls for agent containment</li>
<li><strong><a href="core-concepts/actor-model.html">Actor Model &amp; Supervision</a></strong>: Isolated agents, message-passing communication, and fault tolerance through supervision</li>
<li><strong><a href="core-concepts/traceability.html">Traceability &amp; Verification</a></strong>: Comprehensive tracking of all agent actions for transparency and debugging</li>
</ol>
<p>Understanding these pillars provides the foundation for building effective AI agent systems with Theater.</p>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="introduction/why-theater.html">Why Theater?</a> - Understand the challenges of AI agent systems that Theater solves</li>
<li><a href="core-concepts/index.html">Core Concepts Overview</a> - Learn the fundamental ideas behind Theater</li>
<li><a href="user-guide/cli.html">CLI Reference</a> - Command-line interface documentation</li>
<li><a href="development/building-actors.html">Building Your First Agent</a> - Start creating with Theater</li>
</ul>
<h2 id="theater-for-ai-agents"><a class="header" href="#theater-for-ai-agents">Theater for AI Agents</a></h2>
<p>Theater provides the infrastructure needed to build trustworthy AI agent systems:</p>
<ul>
<li><strong>Secure Execution</strong>: Run agents in sandboxed environments with precise capability controls</li>
<li><strong>Agent Orchestration</strong>: Create hierarchies of specialized agents that work together</li>
<li><strong>Complete Traceability</strong>: Capture and analyze every action taken by agents</li>
<li><strong>Failure Resilience</strong>: Automatically recover from agent failures through supervision</li>
<li><strong>Transparent Operation</strong>: Build trust through comprehensive visibility into agent behavior</li>
</ul>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><a href="https://github.com/colinrozzi/theater">GitHub Repository</a> - Source code and issue tracking</li>
</ul>
<p>This book is continuously updated as Theater evolves. If you find any issues or have suggestions for improvement, please submit them through our GitHub repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Theater is a WebAssembly actor system designed for a world where code may never see human review. It provides an environment where components can interact safely, failures can be contained, and the entire system can be traced and debugged with unprecedented clarity.</p>
<h2 id="a-new-era-of-software-development"><a class="header" href="#a-new-era-of-software-development">A New Era of Software Development</a></h2>
<p>We stand at the beginning of a transformation in how software is written. Large Language Models are already generating significant amounts of code, and this trend will only accelerate. Soon, a substantial portion of the code touching users may never have been seen by human eyes.</p>
<p>This shift presents both opportunities and challenges. On one hand, our software can become more adaptable and flexible, and allow us to tackle problems that were previously too complex or time-consuming. On the other hand, the fundamental assumptions that our software ecosystem is built upon—human review, intentional design, and careful testing—are being upended.</p>
<h2 id="the-three-pillars-of-theater-1"><a class="header" href="#the-three-pillars-of-theater-1">The Three Pillars of Theater</a></h2>
<p>Theater builds trust into the structure of the software system itself through three foundational pillars:</p>
<ol>
<li>
<p><strong>WebAssembly Components &amp; Sandboxing</strong> provide security boundaries and deterministic execution, ensuring that code operates within well-defined constraints.</p>
</li>
<li>
<p><strong>Actor Model &amp; Supervision</strong> implements an Erlang-style actor system with hierarchical supervision, creating isolation between components and facilitating recovery from failures.</p>
</li>
<li>
<p><strong>Traceability &amp; Verification</strong> tracks all information that enters or leaves the WebAssembly sandbox, creating a comprehensive audit trail for debugging and verification.</p>
</li>
</ol>
<p>These three pillars work together to create a system that is secure, resilient, and transparent, addressing the unique challenges of running AI-generated code at scale.</p>
<h2 id="documentation-structure"><a class="header" href="#documentation-structure">Documentation Structure</a></h2>
<p>This book is organized to provide a clear learning path:</p>
<ul>
<li><strong>Introduction</strong>: Why Theater exists and the problems it solves</li>
<li><strong>Core Concepts</strong>: What Theater is and its fundamental principles</li>
<li><strong>Architecture</strong>: How Theater works internally</li>
<li><strong>User Guide</strong>: Practical information for using Theater</li>
<li><strong>Development</strong>: Building and extending Theater components</li>
<li><strong>Services</strong>: Built-in capabilities and handler systems</li>
</ul>
<p>Each section builds on the previous ones, providing a progressively deeper understanding of the Theater system.</p>
<h2 id="who-is-theater-for"><a class="header" href="#who-is-theater-for">Who Is Theater For?</a></h2>
<p>Theater is currently an experimental project for:</p>
<ul>
<li>Developers exploring new approaches to software reliability</li>
<li>Researchers interested in secure execution of untrusted code</li>
<li>Early adopters ready to help shape the future of AI-aware systems</li>
</ul>
<p>It is not intended for production use at this time but provides a glimpse into a future where systems are designed with AI-generated code in mind.</p>
<h2 id="about-this-book"><a class="header" href="#about-this-book">About This Book</a></h2>
<p>This book serves as a friendly introduction to the Theater system. It is meant for programmers new to Theater with existing programming experience. For a more in-depth and precise understanding of the system and its component parts, please refer to the <a href="introduction//theater/api/theater/index.html">API Reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-theater"><a class="header" href="#why-theater">Why Theater?</a></h1>
<h2 id="the-challenge-of-trust-in-the-ai-agent-era"><a class="header" href="#the-challenge-of-trust-in-the-ai-agent-era">The Challenge of Trust in the AI Agent Era</a></h2>
<p>As AI systems become more capable, we're rapidly moving towards a world of autonomous AI agents - software entities that can perform complex tasks, make decisions, and interact with digital systems on our behalf. These agents promise enormous benefits in productivity and automation, but they also present significant challenges that our current software infrastructure isn't designed to address.</p>
<p>These challenges include:</p>
<ol>
<li><strong>Security Boundaries</strong>: How do we ensure agents only access systems and data they're explicitly allowed to?</li>
<li><strong>Visibility and Transparency</strong>: How do we observe, audit, and understand what agents are doing?</li>
<li><strong>Coordination and Cooperation</strong>: How do we enable multiple specialized agents to work together safely?</li>
<li><strong>Failure Management</strong>: How do we handle agents that encounter errors or behave in unexpected ways?</li>
<li><strong>Trust and Verification</strong>: How do we build confidence in agent-based systems, especially in critical applications?</li>
</ol>
<p>These aren't merely theoretical concerns. They represent real, practical challenges that must be solved before AI agents can be deployed widely and safely in production environments.</p>
<h2 id="shifting-trust-from-agents-to-infrastructure"><a class="header" href="#shifting-trust-from-agents-to-infrastructure">Shifting Trust from Agents to Infrastructure</a></h2>
<p>The traditional approach to software reliability has focused on extensive testing and validation of individual components. This approach assumes that once software passes quality checks, it can be trusted to behave correctly.</p>
<p>With AI agents, this assumption becomes problematic. Agents may exhibit emergent behaviors, make unexpected decisions, or encounter edge cases that weren't anticipated during development. Their behavior can be complex and sometimes opaque, making traditional validation insufficient.</p>
<p>Theater takes a different approach. Rather than assuming all agents will behave perfectly, Theater shifts trust to the infrastructure itself. By providing strong guarantees at the system level, Theater creates an environment where even agents with unpredictable behaviors can operate safely.</p>
<p>This shift parallels other advancements in computing history:</p>
<ul>
<li>Virtual machines shifted trust from applications to hypervisors</li>
<li>Containers shifted trust from monoliths to orchestration platforms</li>
<li>Serverless shifted trust from server management to cloud providers</li>
</ul>
<p>Theater continues this evolution by shifting trust from agent behavior to system-level guarantees.</p>
<h2 id="the-three-pillars-of-theater-for-ai-agents"><a class="header" href="#the-three-pillars-of-theater-for-ai-agents">The Three Pillars of Theater for AI Agents</a></h2>
<p>Theater uses three key pillars to provide guarantees about agents running in the system:</p>
<h3 id="1-webassembly-components--sandboxing"><a class="header" href="#1-webassembly-components--sandboxing">1. WebAssembly Components &amp; Sandboxing</a></h3>
<p>Theater uses WebAssembly Components as its foundation, providing:</p>
<ul>
<li><strong>Strict Capability Boundaries</strong>: Agents only have access to capabilities explicitly granted to them</li>
<li><strong>Resource Isolation</strong>: Each agent runs in its own sandbox, preventing direct access to the host system or other agents</li>
<li><strong>Deterministic Execution</strong>: The same inputs always produce the same outputs, making behavior predictable and reproducible</li>
<li><strong>Language Agnosticism</strong>: Agents can be implemented in any language that compiles to WebAssembly</li>
</ul>
<h3 id="2-actor-model--supervision"><a class="header" href="#2-actor-model--supervision">2. Actor Model &amp; Supervision</a></h3>
<p>Taking inspiration from Erlang/OTP, Theater implements a comprehensive actor system:</p>
<ul>
<li><strong>Agent-to-Agent Communication</strong>: All communication happens through explicit message passing</li>
<li><strong>Hierarchical Supervision</strong>: Parent agents monitor children and can restart them upon failure</li>
<li><strong>Failure Isolation</strong>: Problems in one agent don't affect siblings or unrelated parts of the system</li>
<li><strong>Specialized Roles</strong>: Agents can be designed with specific capabilities and responsibilities, forming natural hierarchies</li>
</ul>
<h3 id="3-traceability--verification"><a class="header" href="#3-traceability--verification">3. Traceability &amp; Verification</a></h3>
<p>Theater tracks every action that agents take:</p>
<ul>
<li><strong>Event Chain</strong>: All agent actions are recorded in a verifiable chain</li>
<li><strong>Complete Auditability</strong>: Every decision and action can be traced back to its causes</li>
<li><strong>Deterministic Replay</strong>: Any sequence of events can be replayed exactly for debugging</li>
<li><strong>Explainable Behavior</strong>: The complete history of agent interactions is available for inspection and analysis</li>
</ul>
<h2 id="building-for-an-ai-agent-ecosystem"><a class="header" href="#building-for-an-ai-agent-ecosystem">Building for an AI Agent Ecosystem</a></h2>
<p>By providing a structured environment with strong system-level guarantees, Theater enables developers to build more trustworthy agent systems. This approach is particularly valuable as we move into an era where autonomous agents become increasingly important in our software landscape.</p>
<p>Theater doesn't try to make agent behavior perfectly predictable. Instead, it creates an environment where:</p>
<ul>
<li>Agents can only access what they're explicitly permitted to</li>
<li>Every agent action is recorded and auditable</li>
<li>Failed agents can be automatically restarted or replaced</li>
<li>Complex tasks can be broken down across multiple specialized agents</li>
<li>The entire system behavior is transparent and verifiable</li>
</ul>
<p>Theater provides the infrastructure necessary to deploy AI agents with confidence, knowing that no matter how sophisticated the agents become, the system provides guardrails to ensure they operate safely and reliably.</p>
<p>In the following chapters, we'll explore how Theater implements these principles in practice, starting with the core concepts that form the foundation of the system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Theater is built on three fundamental pillars that work together to create a system that is secure, reliable, and transparent. This section explains what Theater is and the key concepts that make it the ideal infrastructure for AI agent systems.</p>
<h2 id="the-three-pillars-of-theater-2"><a class="header" href="#the-three-pillars-of-theater-2">The Three Pillars of Theater</a></h2>
<h3 id="webassembly-components--sandboxing"><a class="header" href="#webassembly-components--sandboxing"><a href="core-concepts/./wasm-components.html">WebAssembly Components &amp; Sandboxing</a></a></h3>
<p>WebAssembly provides the foundation for Theater's security and capability controls:</p>
<ul>
<li>Strong security boundaries through sandboxing</li>
<li>Deterministic execution for reproducible behavior</li>
<li>Language-agnostic agent implementation</li>
<li>Capability-based security model for precise access control</li>
</ul>
<h3 id="actor-model--supervision"><a class="header" href="#actor-model--supervision"><a href="core-concepts/./actor-model.html">Actor Model &amp; Supervision</a></a></h3>
<p>The Actor Model enables Theater's approach to agent organization, communication, and fault tolerance:</p>
<ul>
<li>Agents as independent, isolated entities</li>
<li>Message-passing for all agent-to-agent communication</li>
<li>Private state management for each agent</li>
<li>Hierarchical supervision for reliable agent systems</li>
</ul>
<h3 id="traceability--verification"><a class="header" href="#traceability--verification"><a href="core-concepts/./traceability.html">Traceability &amp; Verification</a></a></h3>
<p>Traceability ensures that all agent actions are observable, auditable, and debuggable:</p>
<ul>
<li>Event Chain capturing every agent action</li>
<li>Deterministic replay for verification and debugging</li>
<li>State management for consistent agent snapshots</li>
<li>Comprehensive tools for inspection and analysis</li>
</ul>
<h2 id="how-the-pillars-work-together"><a class="header" href="#how-the-pillars-work-together">How The Pillars Work Together</a></h2>
<p>These three pillars complement each other to create Theater's unique properties for agent systems:</p>
<ul>
<li><strong>WebAssembly + Actor Model</strong>: Provides secure agents with clear communication patterns</li>
<li><strong>WebAssembly + Traceability</strong>: Enables deterministic replay and verification of agent behavior</li>
<li><strong>Actor Model + Traceability</strong>: Supports failure diagnosis and recovery in complex agent systems</li>
</ul>
<p>By understanding these core concepts, you'll have a solid foundation for building reliable, secure, and transparent AI agent systems with Theater.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-components--sandboxing-1"><a class="header" href="#webassembly-components--sandboxing-1">WebAssembly Components &amp; Sandboxing</a></h1>
<p>WebAssembly (Wasm) Components form the foundational pillar for Theater's agent security, isolation, and deterministic behavior. By leveraging the Wasm Component Model, Theater creates sandboxed environments where AI agents can operate predictably and securely, with precise control over their capabilities and access to resources.</p>
<h2 id="the-power-of-webassembly-for-secure-agent-execution"><a class="header" href="#the-power-of-webassembly-for-secure-agent-execution">The Power of WebAssembly for Secure Agent Execution</a></h2>
<p>WebAssembly was designed with security as a primary goal. It provides several key features that make it ideal for running AI agents:</p>
<ol>
<li>
<p><strong>Strong Sandboxing</strong>: Each AI agent runs in a completely isolated memory space. Agents cannot access the host system's resources (like files, network, or environment variables) or the memory of other agents unless explicitly granted permission via specific imported functions.</p>
</li>
<li>
<p><strong>Limited Instruction Set</strong>: Wasm's instruction set is intentionally minimal and well-defined. This eliminates entire classes of vulnerabilities common in native code execution, making it safer to run autonomous agents.</p>
</li>
<li>
<p><strong>Capability-Based Security</strong>: The Wasm Component Model relies on explicit interfaces defined using the WebAssembly Interface Type (WIT) language. Agents declare the capabilities they need (like accessing specific APIs or communicating with other agents), and Theater acts as the gatekeeper, controlling which capabilities are provided to each agent.</p>
</li>
</ol>
<p>This sandboxed, capability-based approach means that even sophisticated AI agents with complex behaviors can operate with strong security guarantees. Theater confines each agent's operations to only the resources and capabilities explicitly granted to them.</p>
<h2 id="deterministic-execution-for-predictable-agent-behavior"><a class="header" href="#deterministic-execution-for-predictable-agent-behavior">Deterministic Execution for Predictable Agent Behavior</a></h2>
<p>A crucial property Theater gains from WebAssembly is deterministic execution. Given the same inputs, an agent implemented as a Wasm component will always produce the same outputs and side effects <em>within the sandbox</em>.</p>
<ul>
<li><strong>Well-Defined Semantics</strong>: Wasm has rigorously defined behavior, avoiding the ambiguities and undefined behaviors found in many other execution environments.</li>
<li><strong>Controlled Environment</strong>: All interactions with the outside world (beyond pure computation) must go through imported host functions, which Theater controls and monitors.</li>
</ul>
<p>This determinism is essential for Theater's <a href="core-concepts/./traceability.html">Traceability &amp; Verification</a> pillar, enabling reliable replay, debugging, and verification of agent behavior.</p>
<h2 id="language-agnosticism-for-flexible-agent-implementation"><a class="header" href="#language-agnosticism-for-flexible-agent-implementation">Language Agnosticism for Flexible Agent Implementation</a></h2>
<p>WebAssembly serves as a portable compilation target for numerous programming languages (Rust, C/C++, Go, AssemblyScript, C#, and more). The Wasm Component Model further enhances this by allowing components written in different languages to interoperate seamlessly.</p>
<ul>
<li><strong>Implement Agents in Your Preferred Language</strong>: Developers can choose the best language for their specific agent implementation.</li>
<li><strong>Compose Diverse Capabilities</strong>: An agent within Theater might itself be composed of multiple Wasm components, potentially written in different languages, providing specialized functionality.</li>
<li><strong>Consistent Runtime Behavior</strong>: Regardless of the implementation language, the compiled agent behaves predictably within the Theater runtime.</li>
</ul>
<p>While the Component Model is still evolving across the ecosystem (with Rust having the most mature tooling currently), it provides a powerful, standardized way to build modular and interoperable agent systems.</p>
<h2 id="interface-definitions-with-wit"><a class="header" href="#interface-definitions-with-wit">Interface Definitions with WIT</a></h2>
<p>Theater uses the WebAssembly Interface Type (WIT) language to define the contracts between agents and the system:</p>
<ul>
<li><strong>Agent Interfaces</strong>: Specifies the functions an agent exposes to be called by Theater or other agents.</li>
<li><strong>Host Capabilities</strong>: Defines the capabilities the Theater runtime provides <em>to</em> agents (e.g., sending messages, accessing external APIs, storing data).</li>
<li><strong>Message Formats</strong>: Describes the structure and types of data exchanged between agents and the host.</li>
</ul>
<p>These explicit interface definitions ensure clarity about what each agent can do and enforce the capability-based security model.</p>
<h2 id="benefits-for-ai-agent-systems"><a class="header" href="#benefits-for-ai-agent-systems">Benefits for AI Agent Systems</a></h2>
<p>By building upon WebAssembly Components, Theater achieves:</p>
<ol>
<li><strong>Strong Isolation</strong>: Preventing agents from interfering with each other or the host system.</li>
<li><strong>Precise Capability Control</strong>: Granting agents only the specific access rights they need.</li>
<li><strong>Execution Determinism</strong>: Enabling reliable replay, verification, and debugging of agent behavior.</li>
<li><strong>Implementation Flexibility</strong>: Allowing agents to be developed in various languages.</li>
<li><strong>Modularity and Composability</strong>: Facilitating the creation of complex agent systems from specialized components.</li>
<li><strong>Portability</strong>: Ensuring agents can run consistently across different environments supporting Wasm.</li>
</ol>
<p>This foundation allows Theater to provide a robust runtime environment for AI agent systems where security, reliability, and transparency are paramount concerns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-model--supervision-for-ai-agents"><a class="header" href="#actor-model--supervision-for-ai-agents">Actor Model &amp; Supervision for AI Agents</a></h1>
<p>The Actor Model is the second pillar of Theater, providing a robust framework for organizing, communicating, and managing AI agents. Inspired by systems like Erlang/OTP, Theater implements actors with hierarchical supervision to build resilient and scalable agent architectures.</p>
<h2 id="agents-as-actors-isolated-units-of-intelligence"><a class="header" href="#agents-as-actors-isolated-units-of-intelligence">Agents as Actors: Isolated Units of Intelligence</a></h2>
<p>In Theater, each AI agent is implemented as an <em>actor</em>. Each agent is an independent entity characterized by:</p>
<ol>
<li><strong>Private State</strong>: An agent maintains its own internal state, which cannot be directly accessed or modified by other agents. This isolation ensures agent autonomy and prevents interference.</li>
<li><strong>Mailbox</strong>: Each agent has a mailbox where incoming messages are queued, enabling asynchronous communication.</li>
<li><strong>Behavior</strong>: An agent defines how it processes incoming messages, potentially changing its state, sending messages to other agents, or taking actions in the external world.</li>
<li><strong>Identity</strong>: Agents have unique identifiers used to address messages to them.</li>
</ol>
<p>Crucially, in Theater, each agent corresponds to a running <a href="core-concepts/./wasm-components.html">WebAssembly Component</a>, benefiting from the security and isolation guarantees provided by Wasm.</p>
<h2 id="agent-communication-via-asynchronous-message-passing"><a class="header" href="#agent-communication-via-asynchronous-message-passing">Agent Communication via Asynchronous Message Passing</a></h2>
<p>All interaction between agents in Theater occurs exclusively through asynchronous message passing.</p>
<ul>
<li><strong>No Shared Memory</strong>: Agents do not share memory. To communicate, an agent sends an immutable message to another agent's address.</li>
<li><strong>Asynchronous &amp; Non-Blocking</strong>: When an agent sends a message, it does not wait for the recipient to process it. This allows agents to work concurrently without blocking each other.</li>
<li><strong>Location Transparency</strong>: Agents communicate using addresses, without needing to know the physical location of the recipient agent. (Note: While Theater currently runs agents within a single process, the model allows for future distribution).</li>
<li><strong>Explicit and Traceable</strong>: All interactions are explicit message sends, which are captured by Theater's <a href="core-concepts/./traceability.html">Traceability</a> system.</li>
</ul>
<p>This communication style creates clear boundaries between agents, simplifies concurrency management, and provides a natural way to organize complex agent systems.</p>
<h2 id="agent-isolation-the-core-benefit"><a class="header" href="#agent-isolation-the-core-benefit">Agent Isolation: The Core Benefit</a></h2>
<p>The strict isolation provided by the Actor Model (agents having their own state and communicating only via messages) delivers several critical benefits for AI agent systems:</p>
<ul>
<li><strong>Fault Isolation</strong>: If an agent encounters an error or behaves unexpectedly, the failure is contained within that agent. It does not directly affect the state or operation of other agents in the system.</li>
<li><strong>Independent Lifecycle</strong>: Agents can be started, stopped, restarted, or even upgraded independently without necessarily affecting unrelated parts of the system.</li>
<li><strong>Capability Containment</strong>: Each agent can be granted precisely the capabilities it needs, without sharing those capabilities with other agents.</li>
<li><strong>State Management</strong>: Because state is encapsulated, Theater can manage agent state persistence and recovery more easily. State can potentially be preserved across restarts or upgrades.</li>
</ul>
<h2 id="hierarchical-supervision-for-reliable-agent-systems"><a class="header" href="#hierarchical-supervision-for-reliable-agent-systems">Hierarchical Supervision for Reliable Agent Systems</a></h2>
<p>Theater adopts Erlang/OTP's concept of hierarchical supervision to manage agent failures gracefully.</p>
<ul>
<li><strong>Supervision Trees</strong>: Agents are organized into a tree structure where parent agents <em>supervise</em> their child agents.</li>
<li><strong>Monitoring</strong>: Supervisors monitor the health and behavior of their children.</li>
<li><strong>Recovery Strategies</strong>: When a child agent fails (e.g., crashes due to an unhandled error), its supervisor is notified and decides how to handle the failure based on a defined strategy. Common strategies include:
<ul>
<li><strong>Restart</strong>: Restart the failed agent, potentially restoring its last known good state.</li>
<li><strong>Stop</strong>: Terminate the failed agent permanently if it's deemed unrecoverable or non-essential.</li>
<li><strong>Escalate</strong>: If the supervisor cannot handle the failure, it can fail itself, escalating the problem to <em>its</em> supervisor.</li>
<li><strong>Restart Siblings</strong>: In some cases, a failure in one agent might require restarting other related agents (siblings).</li>
</ul>
</li>
</ul>
<p>This structure allows developers to define how the system should react to failures, building self-healing capabilities directly into the agent architecture. Error handling becomes a primary architectural concern, rather than an afterthought.</p>
<h2 id="agent-patterns-with-the-actor-model"><a class="header" href="#agent-patterns-with-the-actor-model">Agent Patterns with the Actor Model</a></h2>
<p>The Actor Model enables several powerful patterns for AI agent systems:</p>
<h3 id="1-specialized-agent-teams"><a class="header" href="#1-specialized-agent-teams">1. Specialized Agent Teams</a></h3>
<p>Create teams of specialized agents that work together on complex tasks:</p>
<pre><code>CoordinatorAgent
    ├── ResearchAgent
    ├── AnalysisAgent
    └── ReportGenerationAgent
</code></pre>
<p>Each agent focuses on what it does best, communicating results to the next agent in the workflow.</p>
<h3 id="2-agent-redundancy-and-load-balancing"><a class="header" href="#2-agent-redundancy-and-load-balancing">2. Agent Redundancy and Load Balancing</a></h3>
<p>Create multiple instances of the same agent type to handle high workloads or provide redundancy:</p>
<pre><code>RouterAgent
    ├── WorkerAgent-1
    ├── WorkerAgent-2
    ├── WorkerAgent-3
    └── WorkerAgent-4
</code></pre>
<p>The router distributes work across the workers and can easily spin up more workers as needed.</p>
<h3 id="3-progressive-agent-specialization"><a class="header" href="#3-progressive-agent-specialization">3. Progressive Agent Specialization</a></h3>
<p>Create hierarchies of increasingly specialized agents:</p>
<pre><code>GeneralCoordinatorAgent
    ├── ResearchTeamAgent
    │   ├── WebSearchAgent
    │   ├── AcademicDatabaseAgent
    │   └── PatentSearchAgent
    └── AnalysisTeamAgent
        ├── StatisticalAnalysisAgent
        ├── SentimentAnalysisAgent
        └── TrendIdentificationAgent
</code></pre>
<p>Each level in the hierarchy represents a more focused specialization.</p>
<h2 id="benefits-for-ai-agent-systems-1"><a class="header" href="#benefits-for-ai-agent-systems-1">Benefits for AI Agent Systems</a></h2>
<p>Integrating the Actor Model with supervision provides Theater with:</p>
<ol>
<li><strong>Clear Agent Boundaries</strong>: A natural model for defining the scope and capabilities of individual agents.</li>
<li><strong>Enhanced Fault Tolerance</strong>: The ability to contain failures and automatically recover parts of the agent system.</li>
<li><strong>Scalability</strong>: Agents can potentially be distributed across cores or machines to handle increased load.</li>
<li><strong>Resilience</strong>: Systems can remain partially or fully operational even when individual agents fail.</li>
<li><strong>Modular Evolution</strong>: Agents can often be developed, deployed, and updated independently, facilitating continuous improvement without system downtime.</li>
</ol>
<p>Combined with WebAssembly components, the Actor Model allows Theater to manage complex, evolving agent systems within a structure designed for resilience and adaptability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traceability--verification-for-ai-agents"><a class="header" href="#traceability--verification-for-ai-agents">Traceability &amp; Verification for AI Agents</a></h1>
<p>Traceability and verification form the third pillar of Theater, ensuring transparency, auditability, and reproducibility of AI agent behavior. Theater achieves this by meticulously recording all agent actions, decisions, and state changes in a verifiable structure known as the Event Chain. This provides unprecedented insight into agent operations, crucial for debugging, analysis, and building trust in autonomous systems.</p>
<h2 id="the-event-chain-a-verifiable-history-of-agent-actions"><a class="header" href="#the-event-chain-a-verifiable-history-of-agent-actions">The Event Chain: A Verifiable History of Agent Actions</a></h2>
<p>At the heart of Theater's traceability lies the <strong>Event Chain</strong>. Think of it as an immutable, comprehensive logbook that records everything significant that happens within an agent system.</p>
<ul>
<li><strong>Boundary Monitoring</strong>: The system monitors the boundary of each agent (a <a href="core-concepts/./wasm-components.html">WebAssembly Component</a>). Every piece of information crossing this boundary – inputs to the agent, outputs returned, messages sent or received – is captured as an event.</li>
<li><strong>Comprehensive Recording</strong>: Events include agent creation/termination, message sends/receives, API calls made by agents, return values, state changes, external inputs/outputs, and errors.</li>
<li><strong>Cryptographic Linking</strong>: Each event recorded in the chain includes a cryptographic hash of the previous event. This creates a tamper-evident sequence; any modification to a past event would invalidate the hashes of all subsequent events, making unauthorized changes detectable.</li>
</ul>
<p>This chain provides a complete, verifiable history of each agent's actions and the overall system's operation.</p>
<h2 id="deterministic-replay-for-debugging-and-verification"><a class="header" href="#deterministic-replay-for-debugging-and-verification">Deterministic Replay for Debugging and Verification</a></h2>
<p>Because <a href="core-concepts/./wasm-components.html">WebAssembly execution is deterministic</a> and all inputs are captured in the Event Chain, Theater can precisely replay past agent behavior:</p>
<ul>
<li><strong>Reproduce Behaviors</strong>: If an agent produces unexpected results, the exact sequence of events leading up to it can be replayed in a controlled environment to reliably reproduce the behavior.</li>
<li><strong>Debug Complex Interactions</strong>: Developers can step through the replayed sequence, examining agent states and messages at each point to understand complex decision processes or pinpoint the cause of issues.</li>
<li><strong>Verify Improvements</strong>: After modifying agent code to fix a problem, the original event sequence can be replayed against the new agent version to confirm the improvement and check for regressions.</li>
<li><strong>Understand Emergent Behaviors</strong>: When multiple agents interact in complex ways, replaying those interactions helps understand emergent system behaviors.</li>
</ul>
<p>This capability is invaluable for understanding and debugging AI agent systems, especially as agents become more sophisticated and their internal logic more complex.</p>
<h2 id="verifiable-state-management"><a class="header" href="#verifiable-state-management">Verifiable State Management</a></h2>
<p>Theater's approach to agent state management is tightly integrated with traceability:</p>
<ul>
<li><strong>Explicit State Operations</strong>: Agents interact with their persistent state via specific host functions provided by Theater.</li>
<li><strong>State Changes as Events</strong>: Every modification to an agent's state is recorded as an event in the Event Chain, linked to the causal trigger (e.g., processing a specific message or API response).</li>
<li><strong>State History</strong>: The complete evolution of an agent's state is available for inspection, showing how the agent's internal model evolved over time.</li>
</ul>
<p>This ensures that not only the external actions but also the internal state evolution of each agent is fully captured and verifiable.</p>
<h2 id="agent-decision-transparency"><a class="header" href="#agent-decision-transparency">Agent Decision Transparency</a></h2>
<p>For AI agents, transparency into decision-making processes is crucial for trust and debugging:</p>
<ul>
<li><strong>Input Capture</strong>: All inputs that influenced an agent's decisions are recorded</li>
<li><strong>State Transitions</strong>: Changes to the agent's internal state that led to decisions are tracked</li>
<li><strong>Output Tracing</strong>: All actions taken by the agent are linked to the inputs and state that caused them</li>
<li><strong>Causal Chains</strong>: The complete chain of causality from input to action is preserved</li>
</ul>
<p>This level of transparency transforms "black box" AI agents into auditable systems whose behavior can be fully understood and verified.</p>
<h2 id="inspection-and-analysis-tools"><a class="header" href="#inspection-and-analysis-tools">Inspection and Analysis Tools</a></h2>
<p>The Event Chain serves as a rich data source for understanding agent behavior. Theater aims to provide tools (or enable the building of tools) for:</p>
<ul>
<li><strong>Event Inspection</strong>: Browse and examine individual agent actions and their associated data</li>
<li><strong>Timeline Visualization</strong>: View the sequence of interactions between agents over time</li>
<li><strong>State History</strong>: Track how an agent's internal state evolved in response to events</li>
<li><strong>Causality Analysis</strong>: Trace dependencies between events to understand cause-and-effect relationships</li>
<li><strong>Decision Trees</strong>: Visualize the decision paths taken by agents based on different inputs</li>
</ul>
<h2 id="benefits-for-ai-agent-systems-2"><a class="header" href="#benefits-for-ai-agent-systems-2">Benefits for AI Agent Systems</a></h2>
<p>The Traceability &amp; Verification pillar provides:</p>
<ol>
<li><strong>Transparency</strong>: Making agent behavior fully observable and understandable</li>
<li><strong>Powerful Debugging</strong>: Enabling precise reproduction and diagnosis of unexpected behaviors</li>
<li><strong>Auditability</strong>: Allowing independent verification of agent actions and decision processes</li>
<li><strong>Enhanced Trust</strong>: Providing strong evidence of agent behavior, critical for security and compliance</li>
<li><strong>Continuous Improvement</strong>: Facilitating better agent development through comprehensive feedback</li>
</ol>
<p>By capturing a verifiable record of all agent actions, Theater provides the tools needed to understand, debug, and ultimately trust autonomous agent systems. This is especially valuable as agents become more capable and are deployed in increasingly critical applications.</p>
<h2 id="from-black-box-to-glass-box"><a class="header" href="#from-black-box-to-glass-box">From Black Box to Glass Box</a></h2>
<p>Traditional AI systems often operate as "black boxes" where inputs go in, outputs come out, but the internal process remains opaque. Theater transforms AI agents into "glass box" systems where:</p>
<ul>
<li>Every input is recorded</li>
<li>Every state change is tracked</li>
<li>Every decision is logged</li>
<li>Every action is auditable</li>
</ul>
<p>This transparency is essential for building trustworthy AI agent systems that can be deployed with confidence in production environments. Whether for regulatory compliance, user trust, debugging, or system improvement, Theater's traceability capabilities provide the visibility needed to understand and verify agent behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<p>Theater uses TOML for configuration, with support for both actor manifests and system configuration.</p>
<h2 id="actor-manifest"><a class="header" href="#actor-manifest">Actor Manifest</a></h2>
<p>The basic structure of an actor manifest:</p>
<pre><code class="language-toml"># Basic actor information
name = "my-actor"
component_path = "path/to/actor.wasm"

# Interface definitions
[interface]
implements = [
    "ntwk:simple-actor/actor",
    "ntwk:simple-actor/http-server"
]
requires = ["ntwk:simple-actor/http-client"]

# Handler configurations
[[handlers]]
type = "Http-server"
config = { port = 8080 }

[[handlers]]
type = "Metrics"
config = { path = "/metrics" }
</code></pre>
<h3 id="core-fields"><a class="header" href="#core-fields">Core Fields</a></h3>
<ul>
<li><code>name</code> (required): Unique identifier for the actor</li>
<li><code>component_path</code> (required): Path to the WebAssembly component</li>
<li><code>description</code> (optional): Human-readable description</li>
<li><code>version</code> (optional): Semantic version of the actor</li>
</ul>
<h3 id="interface-configuration"><a class="header" href="#interface-configuration">Interface Configuration</a></h3>
<pre><code class="language-toml">[interface]
# Interfaces this actor implements
implements = [
    "ntwk:simple-actor/actor",     # Core actor interface
    "ntwk:simple-actor/metrics",   # Metrics exposure
    "my-org:custom/interface"      # Custom interfaces
]

# Interfaces this actor requires
requires = [
    "ntwk:simple-actor/http-client"
]

# Optional interface configuration
[interface.config]
timeout_ms = 5000
retry_count = 3
</code></pre>
<h3 id="handler-types"><a class="header" href="#handler-types">Handler Types</a></h3>
<h4 id="http-server"><a class="header" href="#http-server">HTTP Server</a></h4>
<pre><code class="language-toml">[[handlers]]
type = "Http-server"
config = {
    port = 8080,
    host = "127.0.0.1",  # Optional, defaults to 0.0.0.0
    path_prefix = "/api", # Optional base path
    
    # Optional TLS configuration
    tls = {
        cert_path = "/path/to/cert.pem",
        key_path = "/path/to/key.pem"
    }
}
</code></pre>
<h4 id="http-client"><a class="header" href="#http-client">HTTP Client</a></h4>
<pre><code class="language-toml">[[handlers]]
type = "Http-client"
config = {
    base_url = "https://api.example.com",
    timeout_ms = 5000,
    
    # Optional default headers
    headers = {
        "User-Agent" = "Theater/1.0",
        "Authorization" = "Bearer ${ENV_TOKEN}"
    }
}
</code></pre>
<h4 id="metrics-handler"><a class="header" href="#metrics-handler">Metrics Handler</a></h4>
<pre><code class="language-toml">[[handlers]]
type = "Metrics"
config = {
    path = "/metrics",
    port = 9090,        # Optional, uses main HTTP port if not specified
    format = "prometheus"
}
</code></pre>
<h4 id="custom-handler"><a class="header" href="#custom-handler">Custom Handler</a></h4>
<pre><code class="language-toml">[[handlers]]
type = "Custom"
name = "my-handler"
config = {
    # Handler-specific configuration
    setting1 = "value1",
    setting2 = 42
}
</code></pre>
<h3 id="state-configuration"><a class="header" href="#state-configuration">State Configuration</a></h3>
<pre><code class="language-toml">[state]
# Initial state as JSON
initial = """
{
    "count": 0,
    "created_at": "${NOW}"
}
"""

# Optional state validation
[state.validation]
schema = "path/to/schema.json"
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>Configuration values can reference environment variables:</p>
<ul>
<li><code>${ENV_NAME}</code>: Required environment variable</li>
<li><code>${ENV_NAME:-default}</code>: Environment variable with default</li>
<li><code>${NOW}</code>: Current timestamp</li>
<li><code>${UUID}</code>: Generate unique ID</li>
</ul>
<p>Example:</p>
<pre><code class="language-toml">name = "actor-${ENV_INSTANCE_ID:-001}"
component_path = "${COMPONENT_DIR}/actor.wasm"

[interface.config]
api_key = "${API_KEY}"
</code></pre>
<h2 id="system-configuration"><a class="header" href="#system-configuration">System Configuration</a></h2>
<p>Theater system-wide configuration:</p>
<pre><code class="language-toml"># System configuration file: theater.toml

[system]
# Directory for WebAssembly components
component_dir = "/opt/theater/components"

# Logging configuration
[system.logging]
level = "info"
format = "json"
output = "stdout"

# Hash chain storage
[system.storage]
type = "filesystem"
path = "/var/lib/theater/chains"

# Optional distributed configuration
[system.distributed]
discovery = "consul"
consul_url = "http://localhost:8500"
</code></pre>
<h3 id="actor-loading"><a class="header" href="#actor-loading">Actor Loading</a></h3>
<pre><code class="language-toml">[system.loading]
# Allow actors to be loaded from these directories
allowed_paths = [
    "/opt/theater/components",
    "${HOME}/.theater/components"
]

# Component validation
verify_signatures = true
signature_keys = ["path/to/public.key"]
</code></pre>
<h3 id="resource-limits"><a class="header" href="#resource-limits">Resource Limits</a></h3>
<pre><code class="language-toml">[system.limits]
# Memory limits
max_memory_mb = 512
max_state_size_mb = 10

# Execution limits
max_execution_time_ms = 1000
max_message_size_kb = 64

# Handler limits
max_http_connections = 1000
max_handlers_per_actor = 5
</code></pre>
<h3 id="security-settings"><a class="header" href="#security-settings">Security Settings</a></h3>
<pre><code class="language-toml">[system.security]
# WASM execution
enable_bulk_memory = true
enable_threads = false
enable_simd = false

# Network access
allow_outbound = true
allowed_hosts = [
    "api.example.com",
    "*.internal.org"
]

# File system access
allow_fs_read = true
allow_fs_write = false
allowed_paths = ["/var/lib/theater"]
</code></pre>
<h2 id="development-configuration"><a class="header" href="#development-configuration">Development Configuration</a></h2>
<p>For development environments:</p>
<pre><code class="language-toml">[dev]
# Hot reload configuration
watch_paths = ["src", "components"]
reload_on_change = true

# Development-specific handlers
[[dev.handlers]]
type = "Http-server"
config = { port = 3000 }

# Mock external services
[[dev.mocks]]
name = "external-api"
port = 8081
responses = "path/to/mock/responses.json"
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Configuration Organization</strong></p>
<ul>
<li>Keep configurations in dedicated directory</li>
<li>Use environment variables for secrets</li>
<li>Version control templates, not actual configs</li>
<li>Document all custom values</li>
</ul>
</li>
<li>
<p><strong>Security</strong></p>
<ul>
<li>Never commit sensitive values</li>
<li>Use environment variables for credentials</li>
<li>Restrict file system access</li>
<li>Limit network access</li>
</ul>
</li>
<li>
<p><strong>Development</strong></p>
<ul>
<li>Use separate dev configurations</li>
<li>Enable detailed logging</li>
<li>Configure mock services</li>
<li>Set reasonable resource limits</li>
</ul>
</li>
<li>
<p><strong>Deployment</strong></p>
<ul>
<li>Use environment-specific configs</li>
<li>Validate all configurations</li>
<li>Monitor resource limits</li>
<li>Document all settings</li>
</ul>
</li>
<li>
<p><strong>Maintenance</strong></p>
<ul>
<li>Regular config reviews</li>
<li>Update security settings</li>
<li>Clean up unused configs</li>
<li>Track config changes</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theater-cli"><a class="header" href="#theater-cli">Theater CLI</a></h1>
<p>The Theater CLI is a command-line tool that provides a convenient interface for working with the Theater WebAssembly actor system. It simplifies actor development, deployment, and management.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>The Theater CLI is included when you build the Theater project:</p>
<pre><code class="language-bash"># Build the project
cargo build --release

# Use the CLI directly
./target/release/theater --help

# Or add it to your PATH for easier access
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-bash"># Get help
theater --help

# Run commands with verbose output
theater -v &lt;command&gt;

# Get output in JSON format (for scripting)
theater --json &lt;command&gt;
</code></pre>
<h2 id="command-overview"><a class="header" href="#command-overview">Command Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>build</code></td><td>Build a Theater actor to WebAssembly</td></tr>
<tr><td><code>create</code></td><td>Create a new Theater actor project</td></tr>
<tr><td><code>events</code></td><td>Get actor events</td></tr>
<tr><td><code>inspect</code></td><td>Show detailed information about an actor</td></tr>
<tr><td><code>list</code></td><td>List all running actors</td></tr>
<tr><td><code>logs</code></td><td>View actor logs</td></tr>
<tr><td><code>message</code></td><td>Send a message to an actor</td></tr>
<tr><td><code>restart</code></td><td>Restart a running actor</td></tr>
<tr><td><code>server</code></td><td>Start a Theater server</td></tr>
<tr><td><code>shell</code></td><td>Start an interactive shell</td></tr>
<tr><td><code>start</code></td><td>Start an actor from a manifest</td></tr>
<tr><td><code>state</code></td><td>Get actor state</td></tr>
<tr><td><code>stop</code></td><td>Stop a running actor</td></tr>
<tr><td><code>tree</code></td><td>Show actor hierarchy as a tree</td></tr>
<tr><td><code>validate</code></td><td>Validate an actor manifest</td></tr>
<tr><td><code>watch</code></td><td>Watch a directory and redeploy on changes</td></tr>
</tbody></table>
</div>
<h2 id="detailed-command-usage"><a class="header" href="#detailed-command-usage">Detailed Command Usage</a></h2>
<h3 id="creating-a-new-actor-project"><a class="header" href="#creating-a-new-actor-project">Creating a New Actor Project</a></h3>
<pre><code class="language-bash"># Create a basic actor project
theater create my-actor

# Create an HTTP actor project
theater create my-http-actor --template http

# Create a project in a specific directory
theater create my-actor --output-dir ~/projects
</code></pre>
<h3 id="building-a-theater-actor"><a class="header" href="#building-a-theater-actor">Building a Theater Actor</a></h3>
<pre><code class="language-bash"># Build the actor in the current directory
theater build

# Build a specific project
theater build /path/to/project

# Build in debug mode
theater build --release false

# Clean and rebuild
theater build --clean
</code></pre>
<h3 id="managing-a-theater-server"><a class="header" href="#managing-a-theater-server">Managing a Theater Server</a></h3>
<pre><code class="language-bash"># Start a server with default settings
theater server

# Start a server with a custom port
theater server --port 9001

# Start a server with a custom data directory
theater server --data-dir /path/to/data
</code></pre>
<h3 id="running-actors"><a class="header" href="#running-actors">Running Actors</a></h3>
<pre><code class="language-bash"># Start an actor from a manifest
theater start path/to/manifest.toml

# Start an actor and output only its ID (useful for piping)
theater start path/to/manifest.toml --id-only

# Start an actor and monitor its events
theater start path/to/manifest.toml --monitor

# List all running actors
theater list

# View actor logs
theater logs &lt;actor-id&gt;

# Get actor state
theater state &lt;actor-id&gt;

# Get actor events
theater events &lt;actor-id&gt;

# Stop an actor
theater stop &lt;actor-id&gt;

# Restart an actor
theater restart &lt;actor-id&gt;

# Subscribe to actor events
theater subscribe &lt;actor-id&gt;

# Start an actor and subscribe to its events (piping commands)
theater start path/to/manifest.toml --id-only | theater subscribe -
</code></pre>
<h3 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h3>
<pre><code class="language-bash"># Create a new actor project
theater create my-actor

# Build the actor
cd my-actor
theater build

# Start the actor and monitor its events
theater start manifest.toml --monitor

# Or, start without monitoring
theater start manifest.toml

# Watch the directory and redeploy on changes
theater watch . --manifest manifest.toml
</code></pre>
<h3 id="sending-messages-to-actors"><a class="header" href="#sending-messages-to-actors">Sending Messages to Actors</a></h3>
<pre><code class="language-bash"># Send a JSON message to an actor
theater message &lt;actor-id&gt; --data '{"action": "doSomething", "value": 42}'

# Send a message from a file
theater message &lt;actor-id&gt; --file message.json
</code></pre>
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<p>The Theater CLI supports human-readable output (default) and JSON output for scripting:</p>
<pre><code class="language-bash"># Human-readable output
theater list

# JSON output
theater --json list
</code></pre>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<p>The Theater CLI respects the following environment variables:</p>
<ul>
<li><code>THEATER_SERVER_ADDRESS</code>: Default server address (host:port)</li>
<li><code>THEATER_DATA_DIR</code>: Default data directory location</li>
</ul>
<h2 id="common-workflows"><a class="header" href="#common-workflows">Common Workflows</a></h2>
<h3 id="develop-build-and-run-loop"><a class="header" href="#develop-build-and-run-loop">Develop, Build, and Run Loop</a></h3>
<ol>
<li>
<p>Create a new actor project</p>
<pre><code class="language-bash">theater create my-actor
cd my-actor
</code></pre>
</li>
<li>
<p>Build the actor</p>
<pre><code class="language-bash">theater build
</code></pre>
</li>
<li>
<p>Start a Theater server (in another terminal)</p>
<pre><code class="language-bash">theater server
</code></pre>
</li>
<li>
<p>Start the actor</p>
<pre><code class="language-bash">theater start manifest.toml
</code></pre>
</li>
<li>
<p>Watch for changes and automatically redeploy</p>
<pre><code class="language-bash">theater watch . --manifest manifest.toml
</code></pre>
</li>
</ol>
<h3 id="monitoring-and-debugging"><a class="header" href="#monitoring-and-debugging">Monitoring and Debugging</a></h3>
<p>To monitor and debug actors:</p>
<ol>
<li>
<p>List all running actors</p>
<pre><code class="language-bash">theater list
</code></pre>
</li>
<li>
<p>View actor logs</p>
<pre><code class="language-bash">theater logs &lt;actor-id&gt;
</code></pre>
</li>
<li>
<p>Inspect actor state</p>
<pre><code class="language-bash">theater state &lt;actor-id&gt;
</code></pre>
</li>
<li>
<p>View actor events</p>
<pre><code class="language-bash">theater events &lt;actor-id&gt;
</code></pre>
</li>
<li>
<p>Monitor actor events in real-time</p>
<pre><code class="language-bash"># When starting a new actor
theater start manifest.toml --monitor

# Or use the subscribe command
theater subscribe &lt;actor-id&gt;

# Or pipe commands together for a streamlined workflow
theater start manifest.toml --id-only | theater subscribe -
</code></pre>
</li>
<li>
<p>Restart an actor if issues occur</p>
<pre><code class="language-bash">theater restart &lt;actor-id&gt;
</code></pre>
</li>
</ol>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="http-actor-setup"><a class="header" href="#http-actor-setup">HTTP Actor Setup</a></h3>
<p>For HTTP actors:</p>
<ol>
<li>
<p>Create an HTTP actor project</p>
<pre><code class="language-bash">theater create my-http-actor --template http
</code></pre>
</li>
<li>
<p>Build and start</p>
<pre><code class="language-bash">cd my-http-actor
theater build
theater start manifest.toml
</code></pre>
</li>
<li>
<p>The HTTP server will be available at the port specified in the manifest</p>
</li>
</ol>
<h3 id="supervisor-pattern"><a class="header" href="#supervisor-pattern">Supervisor Pattern</a></h3>
<p>For parent-child actor relationships:</p>
<ol>
<li>Create parent and child actors</li>
<li>Configure the parent with supervisor capabilities</li>
<li>Start the parent actor</li>
<li>The parent can then spawn and manage child actors</li>
</ol>
<h2 id="new-advanced-commands"><a class="header" href="#new-advanced-commands">New Advanced Commands</a></h2>
<h3 id="inspecting-actors"><a class="header" href="#inspecting-actors">Inspecting Actors</a></h3>
<pre><code class="language-bash"># Inspect an actor in detail
theater inspect &lt;actor-id&gt;

# Show detailed view with full state and all events
theater inspect &lt;actor-id&gt; --detailed
</code></pre>
<h3 id="visualizing-actor-hierarchies"><a class="header" href="#visualizing-actor-hierarchies">Visualizing Actor Hierarchies</a></h3>
<pre><code class="language-bash"># View actor hierarchy as a tree
theater tree

# Limit tree depth
theater tree --depth 2

# Show tree starting from a specific actor
theater tree --root &lt;actor-id&gt;
</code></pre>
<h3 id="validating-manifests"><a class="header" href="#validating-manifests">Validating Manifests</a></h3>
<pre><code class="language-bash"># Validate an actor manifest
theater validate path/to/manifest.toml

# Validate with interface compatibility check
theater validate path/to/manifest.toml --check-interfaces
</code></pre>
<h3 id="interactive-shell"><a class="header" href="#interactive-shell">Interactive Shell</a></h3>
<p>Theater provides an interactive shell for working with actors:</p>
<pre><code class="language-bash"># Start the interactive shell
theater shell

# Connect to a custom server
theater shell --address 127.0.0.1:9001
</code></pre>
<p>In the shell, you can run commands like:</p>
<ul>
<li><code>list</code> - List all running actors</li>
<li><code>inspect &lt;id&gt;</code> - Show detailed information about an actor</li>
<li><code>state &lt;id&gt;</code> - Show the current state of an actor</li>
<li><code>events &lt;id&gt;</code> - Show events for an actor</li>
<li><code>start &lt;path&gt;</code> - Start an actor from a manifest</li>
<li><code>stop &lt;id&gt;</code> - Stop a running actor</li>
<li><code>restart &lt;id&gt;</code> - Restart a running actor</li>
<li><code>message &lt;id&gt; &lt;msg&gt;</code> - Send a message to an actor</li>
<li><code>clear</code> - Clear the screen</li>
<li><code>help</code> - Show help</li>
<li><code>exit</code> - Exit the shell</li>
</ul>
<h2 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and Tricks</a></h2>
<ul>
<li>Use the <code>--verbose</code> flag for detailed output during commands</li>
<li>Use the <code>--json</code> flag to get structured output for scripting</li>
<li>For faster development, use the <code>watch</code> command for automatic redeployment</li>
<li>Use the <code>start --monitor</code> flag to start an actor and monitor its events in real-time</li>
<li>For more advanced event monitoring, use the <code>subscribe</code> command with filtering options</li>
<li>Combine commands with pipes: <code>theater start manifest.toml --id-only | theater subscribe -</code></li>
<li>The <code>subscribe</code> command supports various filtering options like <code>--event-type</code>, <code>--detailed</code>, and <code>--limit</code></li>
<li>Check <code>theater --help</code> and <code>theater &lt;command&gt; --help</code> for specific command options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-ai-agent-systems"><a class="header" href="#building-ai-agent-systems">Building AI Agent Systems</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-ai-generated-code-safely"><a class="header" href="#running-ai-generated-code-safely">Running AI-Generated Code Safely</a></h1>
<p>AI code generation has become increasingly powerful and prevalent. Models like GPT-4, Claude, and specialized coding assistants can now write complex functions, entire modules, and even complete applications with minimal human guidance. This capability offers tremendous productivity benefits, but also introduces new challenges in terms of code quality, reliability, and security.</p>
<p>Theater was designed with these challenges in mind, providing a robust framework for running AI-generated code safely and effectively.</p>
<h2 id="the-ai-code-generation-landscape"><a class="header" href="#the-ai-code-generation-landscape">The AI Code Generation Landscape</a></h2>
<p>Before diving into how Theater helps, let's understand the current landscape of AI code generation:</p>
<h3 id="strengths-of-ai-generated-code"><a class="header" href="#strengths-of-ai-generated-code">Strengths of AI-Generated Code</a></h3>
<ul>
<li><strong>Speed and Volume</strong>: AI can generate large amounts of code quickly</li>
<li><strong>Breadth of Knowledge</strong>: Modern LLMs have been trained on vast repositories of code across languages and frameworks</li>
<li><strong>Pattern Replication</strong>: AI excels at implementing standard patterns and boilerplate code</li>
<li><strong>Adaptation</strong>: AI can often adapt code to new contexts or requirements with minimal guidance</li>
</ul>
<h3 id="challenges-with-ai-generated-code"><a class="header" href="#challenges-with-ai-generated-code">Challenges with AI-Generated Code</a></h3>
<ul>
<li><strong>Correctness Validation</strong>: Verifying that large volumes of AI-generated code work correctly</li>
<li><strong>Subtle Bugs</strong>: AI can introduce subtle logical errors that pass syntax checks but cause runtime issues</li>
<li><strong>Security Vulnerabilities</strong>: AI might inadvertently replicate insecure patterns from its training data</li>
<li><strong>Debugging Complexity</strong>: Understanding and fixing issues in code you didn't write</li>
<li><strong>Integration Problems</strong>: Ensuring AI-generated components work properly with the rest of your system</li>
</ul>
<h2 id="how-theater-addresses-these-challenges"><a class="header" href="#how-theater-addresses-these-challenges">How Theater Addresses These Challenges</a></h2>
<p>Theater provides a comprehensive solution for running AI-generated code safely:</p>
<h3 id="1-containment-through-webassembly-sandboxing"><a class="header" href="#1-containment-through-webassembly-sandboxing">1. Containment through WebAssembly Sandboxing</a></h3>
<p>AI-generated code in Theater runs within WebAssembly sandboxes, which:</p>
<ul>
<li>Prevent direct access to the host system or other components</li>
<li>Limit resource consumption through configurable limits</li>
<li>Create clear boundaries around what the code can and cannot do</li>
<li>Enable the safe execution of code that hasn't been thoroughly reviewed</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of compiling AI-generated code to WebAssembly
fn compile_ai_code(source: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, CompileError&gt; {
    // Compile the AI-generated code to WebAssembly
    let wasm_binary = your_compiler.compile(source)?;
    
    // Return the WebAssembly binary
    Ok(wasm_binary)
}

// Load the WebAssembly component into Theater
let actor_id = theater.load_component(&amp;wasm_binary, &amp;manifest)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-fault-isolation-through-actor-supervision"><a class="header" href="#2-fault-isolation-through-actor-supervision">2. Fault Isolation through Actor Supervision</a></h3>
<p>Theater's supervision system ensures that failures in AI-generated code don't cascade through your entire application:</p>
<ul>
<li>Parent actors can monitor child actors (which might be AI-generated)</li>
<li>If a child actor fails, the parent can restart it or take other recovery actions</li>
<li>Failures are contained to the specific actor that encountered the issue</li>
<li>The system as a whole remains stable even if individual components fail</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of a supervision strategy for AI-generated actors
use theater::supervisor::*;

fn handle_child_failure(child_id: &amp;ActorId, error: &amp;Error) -&gt; SupervisorAction {
    match error {
        // For temporary errors, restart the actor
        Error::Temporary(_) =&gt; SupervisorAction::Restart,
        
        // For more serious errors, stop the actor and notify the admin
        Error::Critical(_) =&gt; {
            notify_admin(child_id, error);
            SupervisorAction::Stop
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-traceability-for-debugging-and-improvement"><a class="header" href="#3-traceability-for-debugging-and-improvement">3. Traceability for Debugging and Improvement</a></h3>
<p>One of the biggest challenges with AI-generated code is understanding what went wrong when issues occur. Theater's traceability features address this directly:</p>
<ul>
<li>Every state change is recorded in a verifiable chain</li>
<li>All inputs and outputs are captured for later analysis</li>
<li>Developers can trace the exact sequence of events that led to a failure</li>
<li>This information can be used to improve the AI code generation process</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of reviewing state history for an AI-generated actor
let history = theater.get_state_history(actor_id)?;

// Analyze the history to find the cause of the issue
for state in history {
    println!("State at {}: {:?}", state.timestamp, state.data);
    
    // Look for the state change that caused the problem
    if let Some(problem) = identify_problem(&amp;state) {
        println!("Found potential issue: {}", problem);
        
        // Use this information to improve the prompt for the AI
        let improved_prompt = generate_improved_prompt(problem);
        println!("Suggested prompt improvement: {}", improved_prompt);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="practical-patterns-for-ai-generated-actors"><a class="header" href="#practical-patterns-for-ai-generated-actors">Practical Patterns for AI-Generated Actors</a></h2>
<p>When working with AI-generated code in Theater, consider these patterns:</p>
<h3 id="1-incremental-responsibility"><a class="header" href="#1-incremental-responsibility">1. Incremental Responsibility</a></h3>
<p>Start by giving AI-generated actors small, well-defined responsibilities, then gradually increase their scope as you gain confidence:</p>
<ol>
<li>Begin with simple data transformation actors</li>
<li>Progress to actors that maintain internal state</li>
<li>Eventually allow AI-generated actors to spawn and supervise other actors</li>
</ol>
<h3 id="2-clear-interface-boundaries"><a class="header" href="#2-clear-interface-boundaries">2. Clear Interface Boundaries</a></h3>
<p>Define clear interfaces for your AI-generated actors:</p>
<pre><code class="language-toml"># Example manifest for an AI-generated actor
name = "ai-generated-processor"
component_path = "ai_processor.wasm"

[interface]
implements = "ntwk:data-processing/processor"
requires = []

[[handlers]]
type = "message-server"
config = {}
</code></pre>
<p>By strictly defining the interfaces, you constrain what the AI-generated code needs to do and limit the potential impact of issues.</p>
<h3 id="3-supervision-hierarchies"><a class="header" href="#3-supervision-hierarchies">3. Supervision Hierarchies</a></h3>
<p>Design your supervision hierarchies to properly manage AI-generated components:</p>
<ul>
<li>Human-written supervisor actors at the top levels</li>
<li>AI-generated actors in the middle or leaf positions</li>
<li>Critical systems supervised by human-written code</li>
<li>Non-critical systems can be supervised by other AI-generated actors</li>
</ul>
<h3 id="4-continuous-verification"><a class="header" href="#4-continuous-verification">4. Continuous Verification</a></h3>
<p>Use Theater's traceability features to continuously verify the behavior of AI-generated actors:</p>
<ul>
<li>Set up automated tests that verify state transitions</li>
<li>Monitor for unexpected patterns in actor behavior</li>
<li>Use the collected data to improve future iterations of the AI-generated code</li>
</ul>
<h2 id="case-study-ai-generated-microservices"><a class="header" href="#case-study-ai-generated-microservices">Case Study: AI-Generated Microservices</a></h2>
<p>A compelling use case for Theater is running a network of AI-generated microservices. In this scenario:</p>
<ol>
<li>Each microservice is implemented as a Theater actor</li>
<li>The services communicate through well-defined message interfaces</li>
<li>A supervision hierarchy ensures system stability</li>
<li>Complete traceability provides visibility into the entire system</li>
</ol>
<p>This approach allows organizations to rapidly develop and deploy new services, leveraging AI for code generation while maintaining system reliability and security.</p>
<h2 id="future-directions"><a class="header" href="#future-directions">Future Directions</a></h2>
<p>The integration of AI code generation with Theater is still evolving. Some exciting future directions include:</p>
<ul>
<li><strong>Feedback Loops</strong>: Automatically using state history and failure data to improve AI prompts</li>
<li><strong>Self-Healing Systems</strong>: AI-powered supervisors that learn from past failures to improve recovery strategies</li>
<li><strong>Hybrid Development</strong>: Tools that seamlessly blend human and AI-written components within the Theater framework</li>
</ul>
<p>By providing a structured, safe environment for running AI-generated code, Theater enables developers to confidently embrace the productivity benefits of AI while mitigating the associated risks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-actors-in-theater"><a class="header" href="#building-actors-in-theater">Building Actors in Theater</a></h1>
<p>This guide walks you through creating actors in Theater, from basic concepts to advanced patterns, with practical examples.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Create a new actor project:</p>
<pre><code class="language-bash">cargo new my-actor
cd my-actor
</code></pre>
<p>Add dependencies to Cargo.toml:</p>
<pre><code class="language-toml">[package]
name = "my-actor"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>my-actor/
├── Cargo.toml              # Project configuration
├── actor.toml             # Actor manifest
├── src/
│   ├── lib.rs            # Actor implementation
│   └── state.rs          # State management
└── wit/                  # Interface definitions
    └── actor.wit         # Actor interface
</code></pre>
<h2 id="basic-actor-implementation"><a class="header" href="#basic-actor-implementation">Basic Actor Implementation</a></h2>
<p>Here's a complete example of a simple counter actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use bindings::exports::ntwk::theater::actor::Guest as ActorGuest;
use bindings::ntwk::theater::types::{Event, Json};
use bindings::ntwk::theater::runtime::log;
use serde::{Deserialize, Serialize};

// Define actor state
#[derive(Serialize, Deserialize)]
struct State {
    count: i32,
    last_updated: String,
}

// Define message types
#[derive(Deserialize)]
#[serde(tag = "type")]
enum Message {
    Increment { amount: i32 },
    Decrement { amount: i32 },
    Reset,
}

struct Component;

impl ActorGuest for Component {
    fn init() -&gt; Vec&lt;u8&gt; {
        log("Initializing counter actor");
        
        let initial_state = State {
            count: 0,
            last_updated: chrono::Utc::now().to_string(),
        };
        
        serde_json::to_vec(&amp;initial_state).unwrap()
    }

    fn handle(evt: Event, state: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
        log(&amp;format!("Handling event: {:?}", evt));
        
        let mut current_state: State = serde_json::from_slice(&amp;state).unwrap();
        
        if let Ok(message) = serde_json::from_slice(&amp;evt.data) {
            match message {
                Message::Increment { amount } =&gt; {
                    current_state.count += amount;
                }
                Message::Decrement { amount } =&gt; {
                    current_state.count -= amount;
                }
                Message::Reset =&gt; {
                    current_state.count = 0;
                }
            }
            current_state.last_updated = chrono::Utc::now().to_string();
        }
        
        serde_json::to_vec(&amp;current_state).unwrap()
    }
}

bindings::export!(Component with_types_in bindings);
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-manifest-1"><a class="header" href="#actor-manifest-1">Actor Manifest</a></h2>
<p>Configure your actor in actor.toml:</p>
<pre><code class="language-toml">name = "counter-actor"
component_path = "target/wasm32-wasi/release/counter_actor.wasm"

[interface]
implements = "theater:simple/actor"
requires = []

[[handlers]]
type = "http-server"
config = { port = 8080 }

[logging]
level = "debug"
output = "stdout"
</code></pre>
<h2 id="adding-http-capabilities"><a class="header" href="#adding-http-capabilities">Adding HTTP Capabilities</a></h2>
<p>Extend the actor to handle HTTP requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bindings::exports::ntwk::theater::http_server::Guest as HttpGuest;
use bindings::ntwk::theater::http_server::{HttpRequest, HttpResponse};

impl HttpGuest for Component {
    fn handle_request(req: HttpRequest, state: Json) -&gt; (HttpResponse, Json) {
        match (req.method.as_str(), req.path.as_str()) {
            // Get current count
            ("GET", "/count") =&gt; {
                let current_state: State = serde_json::from_slice(&amp;state).unwrap();
                
                (HttpResponse {
                    status: 200,
                    headers: vec![
                        ("Content-Type".to_string(), "application/json".to_string())
                    ],
                    body: Some(serde_json::json!({
                        "count": current_state.count,
                        "last_updated": current_state.last_updated
                    }).to_string().into_bytes()),
                }, state)
            },
            
            // Increment count
            ("POST", "/increment") =&gt; {
                if let Some(body) = req.body {
                    if let Ok(increment) = serde_json::from_slice::&lt;serde_json::Value&gt;(&amp;body) {
                        let amount = increment["amount"].as_i64().unwrap_or(1) as i32;
                        
                        let evt = Event {
                            event_type: "increment".to_string(),
                            parent: None,
                            data: serde_json::json!({
                                "type": "Increment",
                                "amount": amount
                            }).to_string().into_bytes(),
                        };
                        
                        let new_state = Component::handle(evt, state);
                        
                        return (HttpResponse {
                            status: 200,
                            headers: vec![
                                ("Content-Type".to_string(), "application/json".to_string())
                            ],
                            body: Some(b"{"status":"ok"}".to_vec()),
                        }, new_state);
                    }
                }
                
                (HttpResponse {
                    status: 400,
                    headers: vec![],
                    body: Some(b"{"error":"invalid request"}".to_vec()),
                }, state)
            },
            
            _ =&gt; (HttpResponse {
                status: 404,
                headers: vec![],
                body: None,
            }, state)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-websocket-support"><a class="header" href="#adding-websocket-support">Adding WebSocket Support</a></h2>
<p>Enable real-time updates with WebSocket support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bindings::exports::ntwk::theater::websocket_server::Guest as WebSocketGuest;
use bindings::ntwk::theater::websocket_server::{
    WebSocketMessage,
    WebSocketResponse,
    MessageType
};

impl WebSocketGuest for Component {
    fn handle_message(msg: WebSocketMessage, state: Json) -&gt; (Json, WebSocketResponse) {
        match msg.ty {
            MessageType::Text =&gt; {
                if let Some(text) = msg.text {
                    // Parse command
                    if let Ok(command) = serde_json::from_str::&lt;serde_json::Value&gt;(&amp;text) {
                        match command["action"].as_str() {
                            Some("subscribe") =&gt; {
                                // Send current state
                                let current_state: State = 
                                    serde_json::from_slice(&amp;state).unwrap();
                                    
                                return (state, WebSocketResponse {
                                    messages: vec![WebSocketMessage {
                                        ty: MessageType::Text,
                                        text: Some(serde_json::json!({
                                            "type": "update",
                                            "count": current_state.count
                                        }).to_string()),
                                        data: None,
                                    }]
                                });
                            },
                            _ =&gt; {}
                        }
                    }
                }
            },
            _ =&gt; {}
        }
        
        (state, WebSocketResponse { messages: vec![] })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-host-functions"><a class="header" href="#using-host-functions">Using Host Functions</a></h2>
<p>Theater provides several host functions for common operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bindings::ntwk::theater::runtime::{log, spawn};
use bindings::ntwk::theater::filesystem::read_file;

// Logging
log("Actor processing message...");

// Spawn another actor
spawn("other-actor.toml");

// Read a file
let content = read_file("config.json");
<span class="boring">}</span></code></pre></pre>
<h2 id="state-management-best-practices"><a class="header" href="#state-management-best-practices">State Management Best Practices</a></h2>
<ol>
<li><strong>Use Strong Typing</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct State {
    data: HashMap&lt;String, Value&gt;,
    metadata: Metadata,
    updated_at: DateTime&lt;Utc&gt;,
}

#[derive(Serialize, Deserialize)]
struct Metadata {
    version: u32,
    owner: String,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Handle Errors Gracefully</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(evt: Event, state: Json) -&gt; Json {
    let current_state: State = match serde_json::from_slice(&amp;state) {
        Ok(state) =&gt; state,
        Err(e) =&gt; {
            log(&amp;format!("Error parsing state: {}", e));
            return state; // Return unchanged state on error
        }
    };
    
    // Process event...
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Include Timestamps</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_state(mut state: State) -&gt; State {
    state.updated_at = chrono::Utc::now();
    state
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Create tests for your actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_increment() {
        let state = State {
            count: 0,
            last_updated: chrono::Utc::now().to_string(),
        };
        
        let event = Event {
            event_type: "increment".to_string(),
            parent: None,
            data: serde_json::json!({
                "type": "Increment",
                "amount": 5
            }).to_string().into_bytes(),
        };
        
        let state_json = serde_json::to_vec(&amp;state).unwrap();
        let new_state_json = Component::handle(event, state_json);
        let new_state: State = serde_json::from_slice(&amp;new_state_json).unwrap();
        
        assert_eq!(new_state.count, 5);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="1-state-history"><a class="header" href="#1-state-history">1. State History</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct State {
    current: StateData,
    history: VecDeque&lt;StateChange&gt;,
}

#[derive(Serialize, Deserialize)]
struct StateChange {
    timestamp: DateTime&lt;Utc&gt;,
    change_type: String,
    previous_value: Value,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-event-correlation"><a class="header" href="#2-event-correlation">2. Event Correlation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct Event {
    id: String,
    correlation_id: Option&lt;String&gt;,
    causation_id: Option&lt;String&gt;,
    data: Value,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-validation-chain"><a class="header" href="#3-validation-chain">3. Validation Chain</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_state(state: &amp;State) -&gt; Result&lt;(), String&gt; {
    validate_constraints(state)?;
    validate_relationships(state)?;
    validate_business_rules(state)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="development-tips"><a class="header" href="#development-tips">Development Tips</a></h2>
<ol>
<li>Use the runtime log function liberally</li>
<li>Test with different message types</li>
<li>Verify state transitions</li>
<li>Handle all error cases</li>
<li>Monitor the hash chain</li>
<li>Test all handler interfaces</li>
</ol>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<ol>
<li>
<p><strong>Not Handling JSON Errors</strong></p>
<ul>
<li>Always handle deserialization errors</li>
<li>Validate JSON structure</li>
<li>Handle missing fields</li>
</ul>
</li>
<li>
<p><strong>State Inconsistency</strong></p>
<ul>
<li>Validate state after changes</li>
<li>Keep state updates atomic</li>
<li>Handle partial updates</li>
</ul>
</li>
<li>
<p><strong>Missing Error Logging</strong></p>
<ul>
<li>Log all errors</li>
<li>Include context</li>
<li>Track error patterns</li>
</ul>
</li>
<li>
<p><strong>Resource Management</strong></p>
<ul>
<li>Clean up resources</li>
<li>Handle timeouts</li>
<li>Monitor memory usage</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-host-functions-guide"><a class="header" href="#building-host-functions-guide">Building Host Functions Guide</a></h1>
<p>This guide explores the principles, challenges, and best practices for implementing host functions in Theater, with particular focus on handling asynchronous operations and maintaining the actor system's integrity.</p>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<h3 id="1-consistent-parameter-patterns"><a class="header" href="#1-consistent-parameter-patterns">1. Consistent Parameter Patterns</a></h3>
<ul>
<li>WIT interfaces should use tuple-based parameter patterns</li>
<li>Client functions should always receive state as their first parameter</li>
<li>Parameters should be bundled in tuples for consistency</li>
</ul>
<h3 id="2-state-chain-integrity"><a class="header" href="#2-state-chain-integrity">2. State Chain Integrity</a></h3>
<ul>
<li>Every state transition must be properly recorded in the hash chain</li>
<li>State updates must be atomic and consistent</li>
<li>The chain must remain verifiable at all times</li>
</ul>
<h3 id="2-non-blocking-operation"><a class="header" href="#2-non-blocking-operation">2. Non-Blocking Operation</a></h3>
<ul>
<li>Host functions should avoid blocking the actor system</li>
<li>Long-running operations should be structured to allow progress</li>
<li>State transitions should be quick and deterministic</li>
</ul>
<h3 id="3-sequential-guarantee-management"><a class="header" href="#3-sequential-guarantee-management">3. Sequential Guarantee Management</a></h3>
<ul>
<li>WebAssembly component calls are inherently sequential</li>
<li>Host functions must be designed with this limitation in mind</li>
<li>Complex async operations need careful structuring</li>
</ul>
<h2 id="common-challenges"><a class="header" href="#common-challenges">Common Challenges</a></h2>
<h3 id="sequential-call-limitation"><a class="header" href="#sequential-call-limitation">Sequential Call Limitation</a></h3>
<p>The WebAssembly component model requires that calls be sequential and return before making progress. This creates challenges for operations that are inherently concurrent or long-running, such as:</p>
<ul>
<li>Websocket connections</li>
<li>Long-polling HTTP requests</li>
<li>File watchers</li>
<li>Database connections</li>
</ul>
<h3 id="solutions-and-patterns"><a class="header" href="#solutions-and-patterns">Solutions and Patterns</a></h3>
<h4 id="1-event-queue-pattern"><a class="header" href="#1-event-queue-pattern">1. Event Queue Pattern</a></h4>
<p>Instead of blocking on handlers, implement an event queue system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WebSocketHost {
    event_queue: Arc&lt;Mutex&lt;VecDeque&lt;WebSocketEvent&gt;&gt;&gt;,
    connections: Arc&lt;Mutex&lt;HashMap&lt;ConnectionId, WebSocket&gt;&gt;&gt;,
}

enum WebSocketEvent {
    NewConnection(ConnectionId, WebSocket),
    Message(ConnectionId, Message),
    Disconnection(ConnectionId),
}

impl WebSocketHost {
    fn process_events(&amp;mut self) {
        while let Some(event) = self.event_queue.lock().unwrap().pop_front() {
            match event {
                WebSocketEvent::NewConnection(id, ws) =&gt; {
                    // Handle new connection without blocking
                    self.connections.lock().unwrap().insert(id, ws);
                    // Notify actor of new connection
                    self.notify_actor_connection(id);
                }
                // Handle other events...
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-state-machine-approach"><a class="header" href="#2-state-machine-approach">2. State Machine Approach</a></h4>
<p>Model long-running operations as state machines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ConnectionState {
    Connecting,
    Connected(WebSocket),
    Closing,
    Closed,
}

struct Connection {
    state: ConnectionState,
    events: VecDeque&lt;WebSocketEvent&gt;,
    last_processed: Instant,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-async-operation-splitting"><a class="header" href="#3-async-operation-splitting">3. Async Operation Splitting</a></h4>
<p>Break long-running operations into discrete steps:</p>
<ol>
<li>Operation initiation</li>
<li>Progress checking</li>
<li>Result collection</li>
</ol>
<h3 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h3>
<ol>
<li>
<p><strong>Event Buffering</strong></p>
<ul>
<li>Buffer events when they can't be processed immediately</li>
<li>Implement reasonable buffer limits</li>
<li>Handle buffer overflow gracefully</li>
</ul>
</li>
<li>
<p><strong>Resource Management</strong></p>
<ul>
<li>Track resource usage carefully</li>
<li>Implement proper cleanup mechanisms</li>
<li>Handle resource exhaustion gracefully</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Propagate errors appropriately</li>
<li>Maintain system stability during errors</li>
<li>Log errors with context for debugging</li>
</ul>
</li>
<li>
<p><strong>State Consistency</strong></p>
<ul>
<li>Ensure state transitions are atomic</li>
<li>Validate state after transitions</li>
<li>Handle partial failures gracefully</li>
</ul>
</li>
</ol>
<h2 id="interface-design-guidelines"><a class="header" href="#interface-design-guidelines">Interface Design Guidelines</a></h2>
<h3 id="1-wit-interface-design"><a class="header" href="#1-wit-interface-design">1. WIT Interface Design</a></h3>
<ul>
<li>Define client-side functions with consistent state parameter patterns:
<pre><code class="language-wit">handle-function: func(state: option&lt;json&gt;, params: tuple&lt;param1-type, param2-type&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;, return-type&gt;, string&gt;;
</code></pre>
</li>
<li>The first parameter is always the actor's state</li>
<li>The second parameter is always a tuple containing function parameters</li>
<li>The result includes both the new state and function result</li>
</ul>
<h3 id="2-host-implementation"><a class="header" href="#2-host-implementation">2. Host Implementation</a></h3>
<ul>
<li>When implementing host-side code that calls client functions, use natural Rust syntax:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>actor_handle
  .call_function::&lt;(ParamType1, ParamType2), ReturnType&gt;(
    "interface.function-name",
    (param1, param2),
  )
  .await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>The type parameters to <code>call_function</code> should match the WIT interface</li>
<li>The adapter layer handles wrapping parameters to match the tuple-based interface</li>
</ul>
<h3 id="3-function-registration"><a class="header" href="#3-function-registration">3. Function Registration</a></h3>
<ul>
<li>Register functions with types matching the WIT interface:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>actor_instance
  .register_function_no_result::&lt;(ParamType1, ParamType2)&gt;(
    "interface",
    "function-name",
  )
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="4-example-channel-functions"><a class="header" href="#4-example-channel-functions">4. Example: Channel Functions</a></h3>
<ul>
<li>
<p>For channel operations, follow the same parameter pattern:</p>
<p><strong>WIT Interface</strong>:</p>
<pre><code class="language-wit">// Correct pattern with tuple-based parameters
handle-channel-message: func(state: option&lt;json&gt;, params: tuple&lt;channel-id, json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
handle-channel-close: func(state: option&lt;json&gt;, params: tuple&lt;channel-id&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
</code></pre>
<p><strong>Host Implementation</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Standard Rust syntax for calling the functions
actor_handle
  .call_function::&lt;(String, Vec&lt;u8&gt;), ()&gt;(
    "theater:simple/message-server-client.handle-channel-message",
    (channel_id.to_string(), data),
  )
  .await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Function Registration</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register with types matching the WIT interface
actor_instance
  .register_function_no_result::&lt;(String, Vec&lt;u8&gt;)&gt;(
    "theater:simple/message-server-client",
    "handle-channel-message",
  )
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="implementation-guidelines"><a class="header" href="#implementation-guidelines">Implementation Guidelines</a></h2>
<h3 id="1-planning-phase"><a class="header" href="#1-planning-phase">1. Planning Phase</a></h3>
<ul>
<li>Map out all possible states and transitions</li>
<li>Identify potential blocking operations</li>
<li>Plan error handling strategy</li>
<li>Consider resource limitations</li>
</ul>
<h3 id="2-implementation-phase"><a class="header" href="#2-implementation-phase">2. Implementation Phase</a></h3>
<ul>
<li>Start with a clear state model</li>
<li>Implement event buffering early</li>
<li>Add comprehensive logging</li>
<li>Build in failure handling</li>
</ul>
<h3 id="3-testing-phase"><a class="header" href="#3-testing-phase">3. Testing Phase</a></h3>
<ul>
<li>Test concurrent operations</li>
<li>Verify state consistency</li>
<li>Check resource cleanup</li>
<li>Test error conditions</li>
</ul>
<h2 id="websocket-host-example"><a class="header" href="#websocket-host-example">WebSocket Host Example</a></h2>
<p>Here's an improved approach to WebSocket hosting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WebSocketHost {
    connections: Arc&lt;Mutex&lt;HashMap&lt;ConnectionId, Connection&gt;&gt;&gt;,
    event_queue: Arc&lt;Mutex&lt;VecDeque&lt;WebSocketEvent&gt;&gt;&gt;,
    config: WebSocketConfig,
}

impl WebSocketHost {
    fn process_events(&amp;mut self) -&gt; Result&lt;(), HostError&gt; {
        // Process a batch of events
        let mut events = self.event_queue.lock().unwrap();
        let batch: Vec&lt;_&gt; = events.drain(..min(events.len(), MAX_BATCH_SIZE)).collect();
        
        for event in batch {
            match event {
                WebSocketEvent::NewConnection(id, ws) =&gt; {
                    self.handle_new_connection(id, ws)?;
                }
                WebSocketEvent::Message(id, msg) =&gt; {
                    self.handle_message(id, msg)?;
                }
                WebSocketEvent::Disconnection(id) =&gt; {
                    self.handle_disconnection(id)?;
                }
            }
        }
        
        Ok(())
    }
    
    fn handle_new_connection(&amp;mut self, id: ConnectionId, ws: WebSocket) -&gt; Result&lt;(), HostError&gt; {
        // Add to connections without blocking
        self.connections.lock().unwrap().insert(id, Connection::new(ws));
        
        // Notify actor through chain
        self.notify_actor_connection(id)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="understanding-parameter-wrapping"><a class="header" href="#understanding-parameter-wrapping">Understanding Parameter Wrapping</a></h2>
<p>The Theater runtime handles parameter conversion between Rust function calls and WebAssembly interfaces. Here's how it works:</p>
<h3 id="1-parameter-flow"><a class="header" href="#1-parameter-flow">1. Parameter Flow</a></h3>
<ol>
<li>
<p><strong>Host Call Layer</strong>: When calling <code>actor_handle.call_function&lt;P, R&gt;(...)</code>, the parameters are serialized to JSON bytes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let params = serde_json::to_vec(&amp;params)?
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Executor Layer</strong>: The <code>execute_call</code> function passes state and parameters to the actor instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (new_state, results) = self.actor_instance.call_function(&amp;name, state, params).await
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Adapter Layer</strong>: The <code>TypedFunction</code> implementation deserializes parameters and calls the appropriately typed function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let params_deserialized: P = serde_json::from_slice(&amp;params)?
match self.call_func(store, state, params_deserialized).await ...
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>WebAssembly Layer</strong>: The parameters are passed to the WebAssembly function according to the WIT interface, with state as the first parameter and parameters as a tuple.</p>
</li>
</ol>
<h3 id="2-return-flow"><a class="header" href="#2-return-flow">2. Return Flow</a></h3>
<ol>
<li>
<p><strong>WebAssembly Layer</strong>: The function returns a result containing the new state and return value.</p>
</li>
<li>
<p><strong>Adapter Layer</strong>: The result is serialized back to JSON bytes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result_serialized = serde_json::to_vec(&amp;result)?
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Executor Layer</strong>: The new state is stored in the actor store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.actor_instance.store.data_mut().set_state(new_state);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Host Call Layer</strong>: The result is deserialized back to the expected return type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res = serde_json::from_slice::&lt;R&gt;(&amp;result)?;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="3-type-mapping"><a class="header" href="#3-type-mapping">3. Type Mapping</a></h3>
<p>The type parameters used in <code>call_function&lt;P, R&gt;</code> and <code>register_function*</code> functions should match the WebAssembly interface definition, but the adapter layer handles the specifics of matching the tuple structure. This lets you use natural Rust parameter patterns while maintaining a consistent WIT interface.</p>
<h2 id="troubleshooting-common-issues"><a class="header" href="#troubleshooting-common-issues">Troubleshooting Common Issues</a></h2>
<h3 id="1-blocking-operations"><a class="header" href="#1-blocking-operations">1. Blocking Operations</a></h3>
<p><strong>Problem</strong>: Operation blocks progress
<strong>Solution</strong>: Convert to event-based handling</p>
<h3 id="2-resource-leaks"><a class="header" href="#2-resource-leaks">2. Resource Leaks</a></h3>
<p><strong>Problem</strong>: Resources not properly cleaned up
<strong>Solution</strong>: Implement proper cleanup in all exit paths</p>
<h3 id="3-state-inconsistency"><a class="header" href="#3-state-inconsistency">3. State Inconsistency</a></h3>
<p><strong>Problem</strong>: State becomes invalid during concurrent operations
<strong>Solution</strong>: Use atomic operations and validate state transitions</p>
<h3 id="4-parameter-pattern-mismatch"><a class="header" href="#4-parameter-pattern-mismatch">4. Parameter Pattern Mismatch</a></h3>
<p><strong>Problem</strong>: WIT interface defines tuple parameters but implementation doesn't match
<strong>Solution</strong>: Ensure WIT interface uses consistent tuple pattern for parameters:</p>
<pre><code class="language-wit">// CORRECT
handle-function: func(state: option&lt;json&gt;, params: tuple&lt;type1, type2&gt;) -&gt; ...;

// INCORRECT
handle-function: func(state: option&lt;json&gt;, param1: type1, param2: type2) -&gt; ...;
</code></pre>
<p>And ensure the host implementation uses matching types in function registration.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Building host functions requires careful consideration of:</p>
<ul>
<li>Consistent parameter patterns in WIT interfaces</li>
<li>Sequential execution constraints</li>
<li>State consistency requirements</li>
<li>Resource management</li>
<li>Error handling</li>
</ul>
<p>Following these patterns and guidelines helps create robust, maintainable host functions that work well within Theater's actor system. In particular, consistently using tuple-based parameter patterns in the WIT interface while leveraging the adapter layer to maintain natural Rust code creates a clean separation between interface definition and implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-changes-to-theater"><a class="header" href="#making-changes-to-theater">Making Changes to Theater</a></h1>
<p>This document outlines the process for making changes to the Theater project. We use a structured approach to document our changes, making it easier for team members to understand what's happening and why.</p>
<h2 id="change-process"><a class="header" href="#change-process">Change Process</a></h2>
<ol>
<li>
<p><strong>Create a Proposal</strong></p>
<ul>
<li>All significant changes start with a proposal</li>
<li>Create a new markdown file in <code>/changes/proposals/</code></li>
<li>Use the format: <code>YYYY-MM-DD-brief-description.md</code></li>
<li>Follow the proposal template structure (see below)</li>
</ul>
</li>
<li>
<p><strong>Update In-Progress List</strong></p>
<ul>
<li>Add your proposal to <code>/changes/in-progress.md</code></li>
<li>Include the proposal file name and a brief description</li>
</ul>
</li>
<li>
<p><strong>Work on the Change</strong></p>
<ul>
<li>Document your progress in the "Working Notes" section</li>
<li>Update as you encounter challenges or make decisions</li>
<li>Keep notes about what worked and what didn't</li>
</ul>
</li>
<li>
<p><strong>Complete the Change</strong></p>
<ul>
<li>Fill out the "Final Notes" section</li>
<li>Document the final implementation details</li>
<li>Note any future considerations or follow-up work</li>
<li>Update <code>in-progress.md</code> to mark as complete</li>
</ul>
</li>
</ol>
<h2 id="proposal-template"><a class="header" href="#proposal-template">Proposal Template</a></h2>
<pre><code class="language-markdown"># [Brief Description of Change]

## Description
- What is being changed
- Why this change is necessary
- Expected benefits and potential risks
- Any alternatives considered

## Working Notes
- Ongoing notes about the implementation
- Challenges encountered
- Decisions made and their reasoning
- References to relevant commits or discussions

## Final Notes
- Final implementation details
- What was actually changed
- Any deviations from the original plan
- Lessons learned
- Future considerations
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>See <a href="development//changes/proposals/2025-01-29-random-id-system.html"><code>/changes/proposals/2025-01-29-random-id-system.md</code></a> for an example of a completed change proposal.</p>
<h2 id="tips-for-good-change-documentation"><a class="header" href="#tips-for-good-change-documentation">Tips for Good Change Documentation</a></h2>
<ol>
<li>Be explicit about your reasoning</li>
<li>Document both successful and unsuccessful approaches</li>
<li>Include relevant code examples or diagrams</li>
<li>Reference related issues or discussions</li>
<li>Update regularly during the change process</li>
</ol>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<ul>
<li>Makes project evolution more transparent</li>
<li>Helps new team members understand the codebase</li>
<li>Creates a knowledge base for future reference</li>
<li>Facilitates code review and discussion</li>
<li>Provides context for future changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-internals"><a class="header" href="#system-internals">System Internals</a></h1>
<p>This section provides a deep dive into the internal architecture and implementation details of Theater. It's designed for contributors and advanced users who want to understand how Theater works under the hood.</p>
<h2 id="who-should-read-this-section"><a class="header" href="#who-should-read-this-section">Who Should Read This Section</a></h2>
<ul>
<li><strong>Contributors</strong> working on the Theater codebase</li>
<li><strong>Advanced users</strong> looking to extend or customize Theater</li>
<li><strong>Curious learners</strong> interested in system design principles</li>
</ul>
<h2 id="whats-covered"><a class="header" href="#whats-covered">What's Covered</a></h2>
<p>This section explores the technical implementation of Theater's core concepts:</p>
<ol>
<li><strong>System Architecture</strong>: The overall design and component relationships</li>
<li><strong>Data Flow</strong>: How information moves through the system</li>
<li><strong>Implementation Details</strong>: Technical specifics of key subsystems</li>
<li><strong>ID System</strong>: How actors and resources are identified</li>
<li><strong>Interface System</strong>: How components communicate</li>
<li><strong>State Management</strong>: Implementation of the state storage mechanisms</li>
<li><strong>Store System</strong>: Technical details of the content-addressable storage</li>
</ol>
<p>While the Core Concepts section explains what Theater is and its fundamental principles, this section explains how those principles are implemented in practice.</p>
<h2 id="navigating-this-section"><a class="header" href="#navigating-this-section">Navigating This Section</a></h2>
<p>The content is organized from high-level architecture to specific implementation details. If you're new to Theater's internals, we recommend starting with the System Architecture page before diving into specific subsystems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h1>
<p>Theater's architecture is designed around the principles of isolation, determinism, and traceability. This page provides a high-level overview of how the system components interact to deliver these guarantees.</p>
<h2 id="system-components"><a class="header" href="#system-components">System Components</a></h2>
<h3 id="theater-runtime"><a class="header" href="#theater-runtime">Theater Runtime</a></h3>
<p>The Theater Runtime is the core orchestration layer that:</p>
<ul>
<li>Manages actor lifecycle (creation, execution, termination)</li>
<li>Implements the supervision system</li>
<li>Coordinates message delivery between actors</li>
<li>Maintains the event chain</li>
<li>Provides access to the store system</li>
</ul>
<h3 id="actor-executor"><a class="header" href="#actor-executor">Actor Executor</a></h3>
<p>The Actor Executor is responsible for:</p>
<ul>
<li>Loading WebAssembly components</li>
<li>Instantiating component instances</li>
<li>Providing host functions to components</li>
<li>Managing component memory and resources</li>
<li>Executing component functions in response to messages</li>
</ul>
<h3 id="event-chain-system"><a class="header" href="#event-chain-system">Event Chain System</a></h3>
<p>The Event Chain tracks:</p>
<ul>
<li>All inputs to actors</li>
<li>All outputs from actors</li>
<li>State changes</li>
<li>Error conditions</li>
<li>Supervision actions</li>
</ul>
<p>Every action in the system is recorded in a verifiable chain of events that enables:</p>
<ul>
<li>Deterministic replay</li>
<li>Auditing</li>
<li>Debugging</li>
<li>System verification</li>
</ul>
<h3 id="store-system"><a class="header" href="#store-system">Store System</a></h3>
<p>The content-addressable Store provides:</p>
<ul>
<li>Persistent storage for actor state</li>
<li>Version control for state changes</li>
<li>Efficient storage through content-addressing</li>
<li>Verification of stored content</li>
</ul>
<h3 id="handler-system"><a class="header" href="#handler-system">Handler System</a></h3>
<p>Handlers extend actor functionality by providing:</p>
<ul>
<li>Access to system services</li>
<li>Integration with external systems</li>
<li>Standard capabilities (HTTP, filesystem, etc.)</li>
<li>Custom functionality through a plugin architecture</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<ol>
<li>
<p><strong>Input Processing</strong>:</p>
<ul>
<li>External requests enter through the Theater Server</li>
<li>Requests are converted to messages</li>
<li>Messages are recorded in the Event Chain</li>
<li>Messages are delivered to target actors</li>
</ul>
</li>
<li>
<p><strong>Actor Execution</strong>:</p>
<ul>
<li>Actor Executor loads actor component</li>
<li>Message handlers are invoked</li>
<li>Actor may access state via the Store</li>
<li>Actor may use handlers to access services</li>
</ul>
</li>
<li>
<p><strong>Output Handling</strong>:</p>
<ul>
<li>Actor responses are recorded in the Event Chain</li>
<li>Responses are delivered to requesters</li>
<li>State changes are persisted to the Store</li>
</ul>
</li>
</ol>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<p>Theater's architecture is built on several key design principles:</p>
<ol>
<li>
<p><strong>Isolation through WebAssembly</strong>:</p>
<ul>
<li>Actors run in sandboxed environments</li>
<li>Component model provides capability-based security</li>
</ul>
</li>
<li>
<p><strong>Explicit State Management</strong>:</p>
<ul>
<li>All state is explicitly managed through the Store</li>
<li>No hidden or shared state between actors</li>
</ul>
</li>
<li>
<p><strong>Explicit Communication</strong>:</p>
<ul>
<li>All communication happens through messages</li>
<li>No direct actor-to-actor function calls</li>
</ul>
</li>
<li>
<p><strong>Comprehensive Tracing</strong>:</p>
<ul>
<li>All system actions are recorded</li>
<li>Chain provides cryptographic verification</li>
</ul>
</li>
<li>
<p><strong>Hierarchical Supervision</strong>:</p>
<ul>
<li>Actors are arranged in supervision trees</li>
<li>Parent actors manage child lifecycle</li>
</ul>
</li>
</ol>
<p>These principles work together to create a system that is secure, deterministic, and verifiable, making it ideal for applications where these properties are critical.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-relationships"><a class="header" href="#component-relationships">Component Relationships</a></h1>
<p>This page details how the various components of Theater interact with each other, providing a deeper understanding of the system's internal architecture.</p>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="theater-runtime-1"><a class="header" href="#theater-runtime-1">Theater Runtime</a></h3>
<p>The Theater Runtime is the central orchestration component that manages the entire system:</p>
<ul>
<li><strong>Relationship with Actor Executor</strong>: The Runtime uses the Actor Executor to instantiate and run actors</li>
<li><strong>Relationship with Store</strong>: The Runtime coordinates with the Store for state persistence</li>
<li><strong>Relationship with Event Chain</strong>: The Runtime records all system events in the Chain</li>
</ul>
<h3 id="actor-executor-1"><a class="header" href="#actor-executor-1">Actor Executor</a></h3>
<p>The Actor Executor handles WebAssembly component instantiation and execution:</p>
<ul>
<li><strong>Relationship with WASM Components</strong>: Loads and instantiates WebAssembly components</li>
<li><strong>Relationship with Host Functions</strong>: Provides host functions to running components</li>
<li><strong>Relationship with Runtime</strong>: Reports execution results back to the Runtime</li>
</ul>
<h3 id="store-system-1"><a class="header" href="#store-system-1">Store System</a></h3>
<p>The Store provides content-addressable storage for actor state:</p>
<ul>
<li><strong>Relationship with Actors</strong>: Provides state storage and retrieval for actors</li>
<li><strong>Relationship with Runtime</strong>: Coordinates with the Runtime for state management</li>
<li><strong>Relationship with Event Chain</strong>: State changes are recorded in the Event Chain</li>
</ul>
<h3 id="event-chain"><a class="header" href="#event-chain">Event Chain</a></h3>
<p>The Event Chain records all system events:</p>
<ul>
<li><strong>Relationship with Runtime</strong>: Receives events from the Runtime</li>
<li><strong>Relationship with Store</strong>: Records state changes from the Store</li>
<li><strong>Relationship with CLI Tools</strong>: Provides data for inspection and debugging</li>
</ul>
<h2 id="secondary-components"><a class="header" href="#secondary-components">Secondary Components</a></h2>
<h3 id="cli"><a class="header" href="#cli">CLI</a></h3>
<p>The CLI provides user interaction with the Theater system:</p>
<ul>
<li><strong>Relationship with Runtime</strong>: Sends commands to the Runtime</li>
<li><strong>Relationship with Event Chain</strong>: Retrieves and displays events</li>
<li><strong>Relationship with Store</strong>: Accesses stored content</li>
</ul>
<h3 id="handlers"><a class="header" href="#handlers">Handlers</a></h3>
<p>Handlers extend actor functionality:</p>
<ul>
<li><strong>Relationship with Actor Executor</strong>: Registered with the Executor</li>
<li><strong>Relationship with Runtime</strong>: Managed by the Runtime</li>
<li><strong>Relationship with Event Chain</strong>: Handler invocations are recorded</li>
</ul>
<h2 id="component-interaction-patterns"><a class="header" href="#component-interaction-patterns">Component Interaction Patterns</a></h2>
<h3 id="creation-flow"><a class="header" href="#creation-flow">Creation Flow</a></h3>
<p>The sequence of component interactions during actor creation:</p>
<ol>
<li>CLI or parent actor requests actor creation</li>
<li>Runtime processes request</li>
<li>Store retrieves component bytes</li>
<li>Actor Executor instantiates component</li>
<li>Runtime initializes actor state</li>
<li>Event Chain records creation</li>
</ol>
<h3 id="message-processing-flow"><a class="header" href="#message-processing-flow">Message Processing Flow</a></h3>
<p>The sequence of component interactions during message processing:</p>
<ol>
<li>Message arrives at Runtime</li>
<li>Runtime records message in Event Chain</li>
<li>Runtime delivers message to target actor</li>
<li>Actor Executor invokes appropriate handler</li>
<li>Actor may access state via Store</li>
<li>Actor response is recorded in Event Chain</li>
<li>Response is delivered to sender</li>
</ol>
<h3 id="failure-handling-flow"><a class="header" href="#failure-handling-flow">Failure Handling Flow</a></h3>
<p>The sequence of component interactions during failure handling:</p>
<ol>
<li>Actor Executor detects failure</li>
<li>Runtime records failure in Event Chain</li>
<li>Runtime notifies supervisor</li>
<li>Supervisor decides on action</li>
<li>Runtime implements supervisory action</li>
<li>Event Chain records recovery action</li>
</ol>
<p>Understanding these component relationships and interaction patterns provides insight into how Theater operates internally and how its various parts work together to create a cohesive system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-flow-1"><a class="header" href="#data-flow-1">Data Flow</a></h1>
<p>This page explains how data moves through the Theater system, from external inputs to actor processing and eventual outputs.</p>
<h2 id="external-input-processing"><a class="header" href="#external-input-processing">External Input Processing</a></h2>
<h3 id="http-requests"><a class="header" href="#http-requests">HTTP Requests</a></h3>
<p>For HTTP-based interactions:</p>
<ol>
<li>HTTP request arrives at Theater Server</li>
<li>Server parses request and identifies target actor</li>
<li>Request is converted to a message</li>
<li>Message is recorded in Event Chain</li>
<li>Message is queued for delivery to actor</li>
</ol>
<h3 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h3>
<p>For CLI-initiated actions:</p>
<ol>
<li>User issues command via CLI</li>
<li>CLI connects to Theater Server</li>
<li>Command is converted to management message</li>
<li>Message is recorded in Event Chain</li>
<li>Server processes management command</li>
</ol>
<h3 id="message-delivery"><a class="header" href="#message-delivery">Message Delivery</a></h3>
<p>For actor-to-actor messaging:</p>
<ol>
<li>Sender actor invokes messaging API</li>
<li>Message is recorded in Event Chain</li>
<li>Message is queued for delivery</li>
<li>Target actor receives message</li>
</ol>
<h2 id="actor-processing"><a class="header" href="#actor-processing">Actor Processing</a></h2>
<h3 id="state-retrieval"><a class="header" href="#state-retrieval">State Retrieval</a></h3>
<p>When actors access state:</p>
<ol>
<li>Actor invokes Store API</li>
<li>Runtime validates access request</li>
<li>State request is recorded in Event Chain</li>
<li>Store retrieves state data</li>
<li>Data is returned to actor</li>
</ol>
<h3 id="computation"><a class="header" href="#computation">Computation</a></h3>
<p>During actor computation:</p>
<ol>
<li>Actor processes message data</li>
<li>Actor may access state via Store</li>
<li>Actor may use handlers for external services</li>
<li>All handler invocations are recorded in Event Chain</li>
</ol>
<h3 id="state-updates"><a class="header" href="#state-updates">State Updates</a></h3>
<p>When actors modify state:</p>
<ol>
<li>Actor creates new state data</li>
<li>Actor invokes Store API to save state</li>
<li>Update request is recorded in Event Chain</li>
<li>Store validates and persists new state</li>
<li>Store returns new state reference to actor</li>
</ol>
<h2 id="external-output-processing"><a class="header" href="#external-output-processing">External Output Processing</a></h2>
<h3 id="http-responses"><a class="header" href="#http-responses">HTTP Responses</a></h3>
<p>For HTTP response generation:</p>
<ol>
<li>Actor produces response data</li>
<li>Response is recorded in Event Chain</li>
<li>Response is converted to HTTP format</li>
<li>HTTP response is sent to client</li>
</ol>
<h3 id="event-streaming"><a class="header" href="#event-streaming">Event Streaming</a></h3>
<p>For event subscription:</p>
<ol>
<li>Client subscribes to events via Theater Server</li>
<li>New events are recorded in Event Chain</li>
<li>Server filters events based on subscription</li>
<li>Matching events are streamed to client</li>
</ol>
<h2 id="special-data-flows"><a class="header" href="#special-data-flows">Special Data Flows</a></h2>
<h3 id="supervision"><a class="header" href="#supervision">Supervision</a></h3>
<p>During supervision operations:</p>
<ol>
<li>Runtime detects actor failure</li>
<li>Failure is recorded in Event Chain</li>
<li>Supervisor actor is notified</li>
<li>Supervisor decides on action</li>
<li>Supervisory action is recorded in Event Chain</li>
<li>Runtime implements supervisory action</li>
</ol>
<h3 id="replay"><a class="header" href="#replay">Replay</a></h3>
<p>During event replay:</p>
<ol>
<li>Replay request identifies starting point</li>
<li>Events are retrieved from Event Chain</li>
<li>Actor state is initialized</li>
<li>Events are applied sequentially</li>
<li>Actor reaches target state</li>
</ol>
<p>Understanding these data flows helps visualize how information moves through the Theater system and how different components collaborate to process data securely and deterministically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h1>
<p>This page provides technical specifics about Theater's implementation, covering internal data structures, algorithms, and design decisions.</p>
<h2 id="actor-executor-2"><a class="header" href="#actor-executor-2">Actor Executor</a></h2>
<h3 id="webassembly-engine"><a class="header" href="#webassembly-engine">WebAssembly Engine</a></h3>
<p>Theater uses Wasmtime as its WebAssembly engine:</p>
<ul>
<li><strong>Component Model Support</strong>: Uses Wasmtime's component model implementation</li>
<li><strong>Resource Management</strong>: Handles memory and table limits</li>
<li><strong>Capability Exposure</strong>: Controls which capabilities are available to components</li>
<li><strong>Asynchronous Execution</strong>: Supports async operations through poll-based approach</li>
</ul>
<h3 id="host-function-implementation"><a class="header" href="#host-function-implementation">Host Function Implementation</a></h3>
<p>Host functions are implemented using:</p>
<ul>
<li><strong>WIT Bindings</strong>: Generated from WIT interface definitions</li>
<li><strong>Capability Checking</strong>: Runtime validation of permission to use functions</li>
<li><strong>Event Recording</strong>: Automatic recording of function invocations</li>
<li><strong>Resource Limiting</strong>: Constraints on resource usage</li>
</ul>
<h2 id="event-chain-1"><a class="header" href="#event-chain-1">Event Chain</a></h2>
<h3 id="data-structure"><a class="header" href="#data-structure">Data Structure</a></h3>
<p>The Event Chain uses a linked data structure:</p>
<ul>
<li><strong>Block Structure</strong>: Events are grouped into blocks</li>
<li><strong>Cryptographic Linking</strong>: Each block links to previous block via hash</li>
<li><strong>Content Addressing</strong>: Events and blocks are referenced by content hash</li>
<li><strong>Efficiency</strong>: Uses optimized serialization for compact representation</li>
</ul>
<h3 id="persistence"><a class="header" href="#persistence">Persistence</a></h3>
<p>Event Chain persistence strategy:</p>
<ul>
<li><strong>Incremental Storage</strong>: New events are appended efficiently</li>
<li><strong>Background Compaction</strong>: Periodic optimization of storage</li>
<li><strong>Index Structures</strong>: Efficient lookup by actor, time, or event type</li>
<li><strong>Pruning Options</strong>: Configurable retention policies</li>
</ul>
<h2 id="store-system-2"><a class="header" href="#store-system-2">Store System</a></h2>
<h3 id="content-addressing"><a class="header" href="#content-addressing">Content-Addressing</a></h3>
<p>Store's content-addressed architecture:</p>
<ul>
<li><strong>Hash Function</strong>: SHA-256 for content identification</li>
<li><strong>Deduplication</strong>: Identical content stored only once</li>
<li><strong>Chunking Strategy</strong>: Large content split into manageable chunks</li>
<li><strong>Reference Counting</strong>: Tracks usage for garbage collection</li>
</ul>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<p>Store's multi-level caching strategy:</p>
<ul>
<li><strong>Memory Cache</strong>: Hot data kept in memory</li>
<li><strong>Local Disk Cache</strong>: Frequently accessed data on local storage</li>
<li><strong>Distributed Cache</strong>: Optional shared cache for clusters</li>
<li><strong>Prefetching</strong>: Predictive loading based on access patterns</li>
</ul>
<h2 id="message-processing"><a class="header" href="#message-processing">Message Processing</a></h2>
<h3 id="queue-implementation"><a class="header" href="#queue-implementation">Queue Implementation</a></h3>
<p>Message queue architecture:</p>
<ul>
<li><strong>Priority Handling</strong>: Messages can have different priorities</li>
<li><strong>Backpressure</strong>: Flow control for overloaded actors</li>
<li><strong>Delivery Guarantees</strong>: At-least-once delivery semantics</li>
<li><strong>Batching</strong>: Efficient processing of multiple messages</li>
</ul>
<h3 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h3>
<p>Approach to concurrent execution:</p>
<ul>
<li><strong>Actor Isolation</strong>: Actors execute independently</li>
<li><strong>Thread Pool</strong>: Configurable worker threads for execution</li>
<li><strong>Work Stealing</strong>: Efficient distribution of processing load</li>
<li><strong>Fairness Policies</strong>: Prevent starvation of actors</li>
</ul>
<h2 id="supervision-system"><a class="header" href="#supervision-system">Supervision System</a></h2>
<h3 id="fault-detection"><a class="header" href="#fault-detection">Fault Detection</a></h3>
<p>How failures are detected:</p>
<ul>
<li><strong>Exception Tracking</strong>: Catches WebAssembly exceptions</li>
<li><strong>Resource Monitoring</strong>: Detects excessive resource usage</li>
<li><strong>Deadlock Detection</strong>: Identifies non-responsive actors</li>
<li><strong>Health Checks</strong>: Periodic verification of actor health</li>
</ul>
<h3 id="recovery-implementation"><a class="header" href="#recovery-implementation">Recovery Implementation</a></h3>
<p>How recovery is implemented:</p>
<ul>
<li><strong>State Preservation</strong>: Maintains actor identity during restarts</li>
<li><strong>Mailbox Handling</strong>: Options for preserving or discarding pending messages</li>
<li><strong>Escalation Chain</strong>: Multi-level supervision hierarchy</li>
<li><strong>Circuit Breaking</strong>: Prevents repeated rapid failures</li>
</ul>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="protocol-design"><a class="header" href="#protocol-design">Protocol Design</a></h3>
<p>Communication protocol details:</p>
<ul>
<li><strong>Message Format</strong>: Binary protocol with versioning</li>
<li><strong>Compression</strong>: Adaptive compression based on content</li>
<li><strong>Authentication</strong>: TLS with certificate validation</li>
<li><strong>Multiplexing</strong>: Multiple logical connections over single transport</li>
</ul>
<h3 id="websocket-implementation"><a class="header" href="#websocket-implementation">WebSocket Implementation</a></h3>
<p>WebSocket support details:</p>
<ul>
<li><strong>Subprotocol</strong>: Theater-specific subprotocol</li>
<li><strong>Event Streaming</strong>: Efficient real-time events</li>
<li><strong>Backpressure</strong>: Client-side flow control</li>
<li><strong>Reconnection</strong>: Automatic reconnection with session resumption</li>
</ul>
<p>Understanding these implementation details provides insight into the technical decisions that enable Theater's unique properties and how they are realized in practice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-id-system"><a class="header" href="#actor-id-system">Actor ID System</a></h1>
<p>The Theater Actor ID system provides a secure, unique identifier mechanism for all entities within the Theater ecosystem. This document covers how IDs are generated, managed, and used throughout the system.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Theater uses UUIDs (Universally Unique Identifiers) to create unique, cryptographically secure identifiers for actors and other entities. These IDs ensure:</p>
<ul>
<li>Uniqueness across distributed systems</li>
<li>Collision resistance even in large-scale deployments</li>
<li>Unpredictability for security purposes</li>
<li>Consistent formatting and representation</li>
</ul>
<h2 id="the-theaterid-type"><a class="header" href="#the-theaterid-type">The TheaterId Type</a></h2>
<p>The core of the ID system is the <code>TheaterId</code> type, which encapsulates a UUID and provides convenient methods for working with actor identifiers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TheaterId(Uuid);

impl TheaterId {
    /// Generate a new random ID
    pub fn generate() -&gt; Self {
        Self(Uuid::new_v4())
    }

    /// Parse a TheaterId from a string
    pub fn parse(s: &amp;str) -&gt; Result&lt;Self, uuid::Error&gt; {
        Ok(Self(Uuid::parse_str(s)?))
    }

    /// Get the underlying UUID
    pub fn as_uuid(&amp;self) -&gt; &amp;Uuid {
        &amp;self.0
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="id-generation"><a class="header" href="#id-generation">ID Generation</a></h2>
<p>Actor IDs are generated using the UUID v4 format, which provides:</p>
<ul>
<li>128 bits (16 bytes) of random data</li>
<li>Extremely low collision probability (1 in 2^122)</li>
<li>Standardized string representation</li>
</ul>
<p>Example of generating a new actor ID:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let actor_id = TheaterId::generate();
<span class="boring">}</span></code></pre></pre>
<h2 id="id-string-representation"><a class="header" href="#id-string-representation">ID String Representation</a></h2>
<p>IDs are represented as standard UUID strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert ID to string
let id_string = actor_id.to_string();  // Format: "550e8400-e29b-41d4-a716-446655440000"

// Parse string back to ID
let parsed_id = TheaterId::parse("550e8400-e29b-41d4-a716-446655440000").unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="serialization-support"><a class="header" href="#serialization-support">Serialization Support</a></h2>
<p>Actor IDs are designed to work seamlessly with serde for JSON serialization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct ActorState {
    id: TheaterId,
    // Other state fields...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-actor-ids"><a class="header" href="#using-actor-ids">Using Actor IDs</a></h2>
<h3 id="in-actor-manifests"><a class="header" href="#in-actor-manifests">In Actor Manifests</a></h3>
<p>Actor IDs can be referenced in manifest files:</p>
<pre><code class="language-toml">[dependencies]
parent_actor = "550e8400-e29b-41d4-a716-446655440000"
</code></pre>
<h3 id="in-message-routing"><a class="header" href="#in-message-routing">In Message Routing</a></h3>
<p>IDs are used for message routing between actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Send a message to a specific actor by ID
theater_runtime::send_message_to_actor(&amp;target_id, message);
<span class="boring">}</span></code></pre></pre>
<h3 id="in-supervision"><a class="header" href="#in-supervision">In Supervision</a></h3>
<p>Parent actors reference children by their IDs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get a child actor's status
let status = supervisor::get_child_status(&amp;child_id)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="id-validation"><a class="header" href="#id-validation">ID Validation</a></h2>
<p>When working with IDs from external sources, always validate them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match TheaterId::parse(input_string) {
    Ok(id) =&gt; {
        // Valid ID, proceed with operation
    },
    Err(_) =&gt; {
        // Invalid ID, handle the error
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li>
<p><strong>Never Generate IDs Manually</strong></p>
<ul>
<li>Always use <code>TheaterId::generate()</code> to ensure proper randomness</li>
</ul>
</li>
<li>
<p><strong>Store Full IDs</strong></p>
<ul>
<li>Don't truncate or modify IDs as this reduces their uniqueness properties</li>
</ul>
</li>
<li>
<p><strong>Use Type Safety</strong></p>
<ul>
<li>Prefer the <code>TheaterId</code> type over raw strings when possible</li>
<li>This provides compile-time guarantees and better error handling</li>
</ul>
</li>
<li>
<p><strong>Handle Parse Errors</strong></p>
<ul>
<li>Always check for errors when parsing IDs from strings</li>
<li>Invalid IDs should be treated as authentication/authorization failures</li>
</ul>
</li>
<li>
<p><strong>Include IDs in Logs</strong></p>
<ul>
<li>Log actor IDs with operations for easier debugging</li>
<li>Use the string representation in log entries</li>
</ul>
</li>
</ol>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<ul>
<li>The ID system uses the <code>uuid</code> crate with the <code>v4</code> feature for generation</li>
<li>The implementation includes comprehensive tests for generation, parsing, and serialization</li>
<li>Future enhancements may include:
<ul>
<li>Alternative ID formats for specific use cases</li>
<li>ID collision detection for large-scale deployments</li>
<li>Hierarchical ID systems for parent-child relationships</li>
</ul>
</li>
</ul>
<h2 id="planned-enhancements"><a class="header" href="#planned-enhancements">Planned Enhancements</a></h2>
<blockquote>
<p><strong>Note</strong>: The following enhancements are planned for future releases:</p>
</blockquote>
<ol>
<li><strong>Secure Random ID System</strong>: A new system using 16-byte random IDs with base64url encoding</li>
<li><strong>Host CSPRNG Integration</strong>: Using the host system's cryptographically secure random number generator</li>
<li><strong>Improved Format</strong>: Shorter string representation (22 characters vs 36 for UUIDs)</li>
<li><strong>Backward Compatibility</strong>: Support for both new and legacy ID formats</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface-system"><a class="header" href="#interface-system">Interface System</a></h1>
<p>Theater's interface system is built on the WebAssembly Component Model and WebAssembly Interface Types (WIT), providing a type-safe and flexible way for actors to expose and consume functionality while maintaining verifiable state transitions.</p>
<h2 id="webassembly-interface-types-wit"><a class="header" href="#webassembly-interface-types-wit">WebAssembly Interface Types (WIT)</a></h2>
<p>Theater defines its interfaces using WIT, providing a language-agnostic way to describe component interfaces. The core WIT files are located in the <code>wit/</code> directory:</p>
<h3 id="core-interfaces"><a class="header" href="#core-interfaces">Core Interfaces</a></h3>
<ol>
<li><strong>actor.wit</strong> - Basic actor interface:</li>
</ol>
<pre><code class="language-wit">interface actor {
    use types.{state};
    
    init: func(state: state, params: tuple&lt;string&gt;) -&gt; result&lt;tuple&lt;state&gt;, string&gt;;
}
</code></pre>
<ol start="2">
<li><strong>message-server.wit</strong> - Message handling interface:</li>
</ol>
<pre><code class="language-wit">interface message-server-client {
    use types.{json, event};

    handle-send: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
    handle-request: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;, tuple&lt;json&gt;&gt;, string&gt;;
}

interface message-server-host {
    use types.{json, actor-id};

    send: func(actor-id: actor-id, msg: json) -&gt; result&lt;_, string&gt;;
    request: func(actor-id: actor-id, msg: json) -&gt; result&lt;json, string&gt;;
}
</code></pre>
<ol start="3">
<li><strong>http.wit</strong> - HTTP server and client interfaces:</li>
</ol>
<pre><code class="language-wit">interface http-server {
    use types.{state};
    use http-types.{http-request, http-response};

    handle-request: func(state: state, params: tuple&lt;http-request&gt;) -&gt; result&lt;tuple&lt;state, tuple&lt;http-response&gt;&gt;, string&gt;;
}

interface http-client {
    use types.{json};
    use http-types.{http-request, http-response};

    send-http: func(req: http-request) -&gt; result&lt;http-response, string&gt;;
}
</code></pre>
<ol start="4">
<li><strong>supervisor.wit</strong> - Parent-child supervision:</li>
</ol>
<pre><code class="language-wit">interface supervisor {
    spawn: func(manifest: string) -&gt; result&lt;string, string&gt;;
    list-children: func() -&gt; list&lt;string&gt;;
    stop-child: func(child-id: string) -&gt; result&lt;_, string&gt;;
    restart-child: func(child-id: string) -&gt; result&lt;_, string&gt;;
    get-child-state: func(child-id: string) -&gt; result&lt;list&lt;u8&gt;, string&gt;;
    get-child-events: func(child-id: string) -&gt; result&lt;list&lt;chain-event&gt;, string&gt;;
    // ...
}
</code></pre>
<ol start="5">
<li><strong>types.wit</strong> - Common data types:</li>
</ol>
<pre><code class="language-wit">interface types {
    type json = list&lt;u8&gt;;
    type state = option&lt;list&lt;u8&gt;&gt;;
    type actor-id = string;
    // ...
}
</code></pre>
<h2 id="handler-system-1"><a class="header" href="#handler-system-1">Handler System</a></h2>
<p>Theater uses a handler system to connect actor interfaces with their implementations:</p>
<h3 id="handler-types-1"><a class="header" href="#handler-types-1">Handler Types</a></h3>
<p>The current implementation includes several handler types:</p>
<ol>
<li>
<p><strong>Message Server Handler</strong>:</p>
<ul>
<li>Handles direct actor-to-actor messaging</li>
<li>Supports both request/response and one-way sends</li>
<li>Serializes messages as JSON bytes</li>
</ul>
</li>
<li>
<p><strong>HTTP Server Handler</strong>:</p>
<ul>
<li>Exposes actor functionality via HTTP endpoints</li>
<li>Converts HTTP requests to actor messages</li>
<li>Transforms responses back to HTTP</li>
</ul>
</li>
<li>
<p><strong>Supervisor Handler</strong>:</p>
<ul>
<li>Enables parent-child supervision</li>
<li>Provides lifecycle management functions</li>
<li>Access to child state and events</li>
</ul>
</li>
</ol>
<h3 id="handler-configuration"><a class="header" href="#handler-configuration">Handler Configuration</a></h3>
<p>Handlers are configured in actor manifests:</p>
<pre><code class="language-toml">name = "my-actor"
component_path = "my_actor.wasm"

# Message server handler
[[handlers]]
type = "message-server"
config = { port = 8080 }
interface = "theater:simple/message-server-client"

# HTTP server handler
[[handlers]]
type = "http-server"
config = { port = 8081 }

# Supervisor handler
[[handlers]]
type = "supervisor"
config = {}
</code></pre>
<h2 id="message-flow"><a class="header" href="#message-flow">Message Flow</a></h2>
<h3 id="actor-to-actor-messaging"><a class="header" href="#actor-to-actor-messaging">Actor-to-Actor Messaging</a></h3>
<ol>
<li>
<p><strong>Send Message</strong> (one-way):</p>
<ul>
<li>Sender actor calls <code>message-server-host::send</code></li>
<li>Message is routed through TheaterRuntime</li>
<li>Recipient actor's <code>handle-send</code> is called</li>
<li>State is updated and recorded in hash chain</li>
<li>No response is returned to sender</li>
</ul>
</li>
<li>
<p><strong>Request Message</strong> (request/response):</p>
<ul>
<li>Sender actor calls <code>message-server-host::request</code></li>
<li>Message is routed through TheaterRuntime</li>
<li>Recipient actor's <code>handle-request</code> is called</li>
<li>State is updated and recorded in hash chain</li>
<li>Response is returned to sender</li>
</ul>
</li>
</ol>
<h3 id="http-integration"><a class="header" href="#http-integration">HTTP Integration</a></h3>
<ol>
<li>
<p><strong>Incoming HTTP Request</strong>:</p>
<ul>
<li>HTTP request arrives at server</li>
<li>Request is converted to <code>http-request</code> struct</li>
<li>Actor's <code>handle-request</code> function is called</li>
<li>Response is converted back to HTTP and returned</li>
</ul>
</li>
<li>
<p><strong>Outgoing HTTP Request</strong>:</p>
<ul>
<li>Actor calls <code>http-client::send-http</code></li>
<li>Request is made to external service</li>
<li>Response is returned to actor</li>
<li>Interaction is recorded in hash chain</li>
</ul>
</li>
</ol>
<h2 id="interface-implementation"><a class="header" href="#interface-implementation">Interface Implementation</a></h2>
<p>Actors implement interfaces through WebAssembly components:</p>
<h3 id="required-component-structure"><a class="header" href="#required-component-structure">Required Component Structure</a></h3>
<p>A Theater actor component must:</p>
<ol>
<li>Implement required interfaces (based on handlers)</li>
<li>Export interface functions with correct signatures</li>
<li>Handle state consistently</li>
<li>Process messages according to interface specifications</li>
</ol>
<h3 id="example-actor-implementation"><a class="header" href="#example-actor-implementation">Example Actor Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use theater_sdk::{actor, message_server};

struct CounterActor;

#[actor::export]
impl actor::Actor for CounterActor {
    fn init(state: Option&lt;Vec&lt;u8&gt;&gt;, params: (String,)) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;,), String&gt; {
        // Initialize with either existing state or new state
        let state = state.unwrap_or_else(|| {
            let initial_state = serde_json::json!({ "count": 0 });
            serde_json::to_vec(&amp;initial_state).unwrap()
        });
        
        Ok((Some(state),))
    }
}

#[message_server::export]
impl message_server::MessageServerClient for CounterActor {
    fn handle_send(
        state: Option&lt;Vec&lt;u8&gt;&gt;,
        params: (Vec&lt;u8&gt;,)
    ) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;,), String&gt; {
        // Process one-way message
        // ...
        Ok((new_state,))
    }
    
    fn handle_request(
        state: Option&lt;Vec&lt;u8&gt;&gt;,
        params: (Vec&lt;u8&gt;,)
    ) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, (Vec&lt;u8&gt;,)), String&gt; {
        // Process request/response message
        // ...
        Ok((new_state, (response,)))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-state"><a class="header" href="#working-with-state">Working with State</a></h2>
<p>The interface system consistently handles state:</p>
<ol>
<li>
<p><strong>State Representation</strong>:</p>
<ul>
<li>State is represented as <code>Option&lt;Vec&lt;u8&gt;&gt;</code> (optional bytes)</li>
<li>Typically contains serialized JSON or other format</li>
<li>State is passed to and from interface functions</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong>:</p>
<ul>
<li>Functions return new state</li>
<li>Changes are recorded in hash chain</li>
<li>State is available for inspection and verification</li>
</ul>
</li>
<li>
<p><strong>State Access</strong>:</p>
<ul>
<li>Current state is provided to interface functions</li>
<li>Functions can modify state by returning new version</li>
<li>Parent actors can access child state via supervision</li>
</ul>
</li>
</ol>
<h2 id="actor-manifest-2"><a class="header" href="#actor-manifest-2">Actor Manifest</a></h2>
<p>The manifest connects interfaces to implementations:</p>
<pre><code class="language-toml">name = "counter-actor"
component_path = "counter.wasm"

# Interfaces implemented by this actor
[interface]
implements = [
    "theater:simple/actor",
    "theater:simple/message-server-client",
    "theater:simple/http-server"
]

# Interfaces required by this actor
requires = [
    "theater:simple/message-server-host"
]

# Message server handler
[[handlers]]
type = "message-server"
config = {}

# HTTP server handler
[[handlers]]
type = "http-server"
config = { port = 8080 }
</code></pre>
<h2 id="interface-composition"><a class="header" href="#interface-composition">Interface Composition</a></h2>
<p>Theater's interface system is designed for composition, allowing actors to:</p>
<ol>
<li>
<p><strong>Implement Multiple Interfaces</strong>:</p>
<ul>
<li>Core actor functionality</li>
<li>Message handling</li>
<li>HTTP serving</li>
<li>Custom functionality</li>
</ul>
</li>
<li>
<p><strong>Depend on Host Interfaces</strong>:</p>
<ul>
<li>Message sending</li>
<li>HTTP client</li>
<li>Supervision</li>
<li>File system access</li>
</ul>
</li>
<li>
<p><strong>Combine Interface Types</strong>:</p>
<ul>
<li>One interface can extend another</li>
<li>Interfaces can share common types</li>
<li>Versioning through interface namespaces</li>
</ul>
</li>
</ol>
<p>Each interface maintains state chain integrity while providing a specific capability.</p>
<h2 id="message-structure"><a class="header" href="#message-structure">Message Structure</a></h2>
<p>While the interface system is flexible, messages typically follow a standard structure:</p>
<pre><code class="language-json">{
  "type": "request_type",
  "action": "specific_operation",
  "payload": {
    "param1": "value1",
    "param2": 42
  },
  "metadata": {
    "timestamp": "2025-02-26T12:34:56Z",
    "request_id": "req-123456"
  }
}
</code></pre>
<p>Responses typically include:</p>
<pre><code class="language-json">{
  "type": "response",
  "status": "success",
  "payload": {
    "result": "value"
  },
  "metadata": {
    "timestamp": "2025-02-26T12:34:57Z",
    "request_id": "req-123456"
  }
}
</code></pre>
<h2 id="debugging-interfaces"><a class="header" href="#debugging-interfaces">Debugging Interfaces</a></h2>
<p>Theater provides several mechanisms for debugging interfaces:</p>
<ol>
<li>
<p><strong>Tracing</strong>:</p>
<ul>
<li>All interface calls are logged</li>
<li>State transitions are recorded</li>
<li>Message flow can be traced end-to-end</li>
</ul>
</li>
<li>
<p><strong>Interface Inspection</strong>:</p>
<ul>
<li>WIT interfaces can be introspected</li>
<li>Available functions can be listed</li>
<li>Type checking for message formats</li>
</ul>
</li>
<li>
<p><strong>State Verification</strong>:</p>
<ul>
<li>Hash chain can be verified at any point</li>
<li>State history can be examined</li>
<li>State transitions can be replayed</li>
</ul>
</li>
</ol>
<h2 id="custom-interface-development"><a class="header" href="#custom-interface-development">Custom Interface Development</a></h2>
<p>Creating new interfaces requires:</p>
<ol>
<li>
<p><strong>WIT Definition</strong>:</p>
<ul>
<li>Define interface functions and types</li>
<li>Document expected behavior</li>
<li>Specify state handling patterns</li>
</ul>
</li>
<li>
<p><strong>Handler Implementation</strong>:</p>
<ul>
<li>Create handler in Theater runtime</li>
<li>Connect WIT interface to actor</li>
<li>Handle message routing correctly</li>
</ul>
</li>
<li>
<p><strong>Actor Implementation</strong>:</p>
<ul>
<li>Implement interface functions</li>
<li>Handle state properly</li>
<li>Process messages according to spec</li>
</ul>
</li>
</ol>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li>
<p><strong>Interface Design</strong></p>
<ul>
<li>Keep interfaces focused on single responsibility</li>
<li>Use clear, descriptive function names</li>
<li>Document expected behavior</li>
<li>Provide meaningful error messages</li>
<li>Consider versioning strategy</li>
</ul>
</li>
<li>
<p><strong>Message Design</strong></p>
<ul>
<li>Use consistent type field for categorization</li>
<li>Include action field for specific operations</li>
<li>Structure payloads logically</li>
<li>Add metadata for debugging</li>
<li>Handle errors consistently</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Keep state serializable</li>
<li>Handle state transitions atomically</li>
<li>Validate state after changes</li>
<li>Consider state size impacts</li>
<li>Test state rollback scenarios</li>
</ul>
</li>
<li>
<p><strong>Security Considerations</strong></p>
<ul>
<li>Validate all input messages</li>
<li>Sanitize data crossing interface boundaries</li>
<li>Control access to sensitive interfaces</li>
<li>Verify state integrity frequently</li>
<li>Test for message injection risks</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theater-handlers"><a class="header" href="#theater-handlers">Theater Handlers</a></h1>
<p>Handlers are the primary way actors interact with the outside world and with each other in Theater. This section provides an overview and links to detailed documentation for each handler type.</p>
<h2 id="handler-system-overview"><a class="header" href="#handler-system-overview">Handler System Overview</a></h2>
<p>The <a href="services/handlers/README.html">Handler System</a> documentation provides a comprehensive overview of how handlers work in Theater, including:</p>
<ul>
<li>What handlers are and their role in the Theater architecture</li>
<li>How handlers connect actors to the outside world and with other actors</li>
<li>The distinction between "host" functions (imports) and "export" functions</li>
<li>The handler lifecycle within the actor runtime</li>
<li>How handlers are configured in manifests</li>
</ul>
<h2 id="available-handlers"><a class="header" href="#available-handlers">Available Handlers</a></h2>
<p>Theater provides several built-in handlers that enable different capabilities:</p>
<h3 id="message-server-handler"><a class="header" href="#message-server-handler"><a href="services/handlers/message-server.html">Message Server Handler</a></a></h3>
<p>The Message Server Handler is the primary mechanism for actor-to-actor communication, enabling:</p>
<ul>
<li>One-way message sending</li>
<li>Request-response patterns</li>
<li>Channel-based communication</li>
</ul>
<h3 id="http-client-handler"><a class="header" href="#http-client-handler"><a href="services/handlers/http-client.html">HTTP Client Handler</a></a></h3>
<p>The HTTP Client Handler allows actors to make HTTP requests to external services, with:</p>
<ul>
<li>Support for all HTTP methods</li>
<li>Header and body customization</li>
<li>Automatic state chain recording</li>
</ul>
<h3 id="http-framework-handler"><a class="header" href="#http-framework-handler"><a href="services/handlers/http-framework.html">HTTP Framework Handler</a></a></h3>
<p>The HTTP Framework Handler exposes actor functionality via HTTP endpoints, enabling:</p>
<ul>
<li>HTTP server capabilities</li>
<li>RESTful API development</li>
<li>Web service creation</li>
</ul>
<h3 id="filesystem-handler"><a class="header" href="#filesystem-handler"><a href="services/handlers/filesystem.html">Filesystem Handler</a></a></h3>
<p>The Filesystem Handler provides actors with controlled access to the local filesystem for:</p>
<ul>
<li>Reading and writing files</li>
<li>Directory operations</li>
<li>File metadata access</li>
</ul>
<h3 id="supervisor-handler"><a class="header" href="#supervisor-handler"><a href="services/handlers/supervisor.html">Supervisor Handler</a></a></h3>
<p>The Supervisor Handler enables parent-child relationships between actors, supporting:</p>
<ul>
<li>Spawning child actors</li>
<li>Lifecycle management</li>
<li>Supervision strategies</li>
</ul>
<h3 id="store-handler"><a class="header" href="#store-handler"><a href="services/handlers/store.html">Store Handler</a></a></h3>
<p>The Store Handler provides access to Theater's content-addressable storage system for:</p>
<ul>
<li>Content-addressed storage</li>
<li>Label management</li>
<li>Persistent data storage</li>
</ul>
<h3 id="runtime-handler"><a class="header" href="#runtime-handler"><a href="services/handlers/runtime.html">Runtime Handler</a></a></h3>
<p>The Runtime Handler provides information about and control over the actor's runtime environment:</p>
<ul>
<li>System information</li>
<li>Environment variables</li>
<li>Logging and metrics</li>
</ul>
<h3 id="timing-handler"><a class="header" href="#timing-handler"><a href="services/handlers/timing.html">Timing Handler</a></a></h3>
<p>The Timing Handler provides time-related capabilities:</p>
<ul>
<li>Controlled delays</li>
<li>Timeout patterns</li>
<li>High-resolution timing</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Choose a handler from the list above to learn more about its capabilities, configuration options, and usage patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler-system-2"><a class="header" href="#handler-system-2">Handler System</a></h1>
<p>The handler system is the core of how actors interact with the outside world and with each other in Theater. Handlers provide the bridge between WebAssembly actors and host capabilities, enabling actors to send messages, access resources, and participate in supervision hierarchies.</p>
<h2 id="what-are-handlers"><a class="header" href="#what-are-handlers">What Are Handlers?</a></h2>
<p>Handlers are specialized components that:</p>
<ol>
<li><strong>Connect Actors with Host Capabilities</strong>: Handlers expose host functions to WebAssembly actors, allowing them to interact with the host system and other actors</li>
<li><strong>Process Messages and Events</strong>: Handlers receive and process incoming messages, translating them into actor function calls</li>
<li><strong>Maintain Chain Integrity</strong>: All handler operations are recorded in the actor's chain, maintaining the verifiable history</li>
<li><strong>Provide Standard Interfaces</strong>: Handlers implement standard WebAssembly Interface Type (WIT) interfaces, ensuring consistency across actors</li>
</ol>
<h2 id="handler-architecture"><a class="header" href="#handler-architecture">Handler Architecture</a></h2>
<p>Each handler consists of two main parts:</p>
<ol>
<li>
<p><strong>Host Functions</strong> (Imports): Functions provided by the host environment that actors can call. These are integrated into the actor's WebAssembly module during instantiation.</p>
</li>
<li>
<p><strong>Exported Functions</strong> (Exports): Functions that the actor implements and the handler calls in response to external events or messages.</p>
</li>
</ol>
<p>This bidirectional interface allows for complete interaction patterns while maintaining the security boundaries provided by WebAssembly.</p>
<h2 id="handler-lifecycle"><a class="header" href="#handler-lifecycle">Handler Lifecycle</a></h2>
<p>When an actor is started:</p>
<ol>
<li><strong>Registration</strong>: Handlers specified in the actor's manifest are registered with the actor runtime</li>
<li><strong>Initialization</strong>: Each handler is initialized and connected to the actor component</li>
<li><strong>Host Function Setup</strong>: The handler adds its host functions to the actor's WebAssembly linker</li>
<li><strong>Export Function Registration</strong>: The handler registers the actor's exported functions for callbacks</li>
<li><strong>Start</strong>: The handler's event loop is started in a separate task</li>
</ol>
<p>During operation:</p>
<ol>
<li><strong>Message Processing</strong>: Handlers receive messages or events and process them</li>
<li><strong>Function Calls</strong>: Handlers call actor functions or respond to actor requests to host functions</li>
<li><strong>State Recording</strong>: All interactions are recorded in the actor's state chain</li>
</ol>
<p>During shutdown:</p>
<ol>
<li><strong>Graceful Termination</strong>: Handlers receive shutdown signals and perform cleanup</li>
<li><strong>Resource Release</strong>: All resources owned by handlers are released</li>
</ol>
<h2 id="handler-configuration-1"><a class="header" href="#handler-configuration-1">Handler Configuration</a></h2>
<p>Handlers are configured in the actor's manifest file (TOML format):</p>
<pre><code class="language-toml">name = "my-actor"
component_path = "my_actor.wasm"

[[handlers]]
type = "message-server"
config = {}

[[handlers]]
type = "http-client"
config = {}

[[handlers]]
type = "filesystem"
config = { new_dir = true }
</code></pre>
<p>Each handler entry includes:</p>
<ul>
<li><code>type</code>: The handler type identifier</li>
<li><code>config</code>: Handler-specific configuration options</li>
</ul>
<h2 id="available-handler-types"><a class="header" href="#available-handler-types">Available Handler Types</a></h2>
<p>Theater provides several built-in handler types:</p>
<ol>
<li><strong>message-server</strong>: Enables actor-to-actor messaging using both synchronous (request/response) and asynchronous (fire-and-forget) patterns</li>
<li><strong>http-client</strong>: Allows actors to make HTTP requests to external services</li>
<li><strong>http-framework</strong>: Exposes actor functionality via HTTP endpoints</li>
<li><strong>filesystem</strong>: Provides access to the filesystem with appropriate sandboxing</li>
<li><strong>supervisor</strong>: Enables parent-child actor relationships for supervision</li>
<li><strong>store</strong>: Provides content-addressable storage for actors</li>
<li><strong>runtime</strong>: Gives access to runtime information and operations</li>
<li><strong>timing</strong>: Provides timing and scheduling capabilities</li>
</ol>
<h2 id="webassembly-interface-types-wit-1"><a class="header" href="#webassembly-interface-types-wit-1">WebAssembly Interface Types (WIT)</a></h2>
<p>Handler abilitiesare exposed to the actors using WebAssembly Interface Types (WIT), which provide a language-agnostic way to describe component interfaces. For example, the message-server interface is defined as:</p>
<pre><code class="language-wit">interface message-server-client {
    use types.{json, event};

    handle-send: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
    handle-request: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;, tuple&lt;json&gt;&gt;, string&gt;;
}

interface message-server-host {
    use types.{json, actor-id};

    send: func(actor-id: actor-id, msg: json) -&gt; result&lt;_, string&gt;;
    request: func(actor-id: actor-id, msg: json) -&gt; result&lt;json, string&gt;;
}
</code></pre>
<h2 id="handler-implementation-details"><a class="header" href="#handler-implementation-details">Handler Implementation Details</a></h2>
<p>Under the hood, handlers are implemented as Rust structs that:</p>
<ol>
<li>Implement the <code>Handler</code> trait</li>
<li>Handle setup of host functions</li>
<li>Process messages and events</li>
<li>Call actor functions when needed</li>
<li>Maintain appropriate state</li>
</ol>
<p>For example, the <code>MessageServerHost</code> implements handler functionality for actor-to-actor messaging.</p>
<h2 id="handler-security-model"><a class="header" href="#handler-security-model">Handler Security Model</a></h2>
<p>The handler system is designed with security in mind:</p>
<ol>
<li><strong>Sandboxed Access</strong>: Handlers provide controlled access to host resources</li>
<li><strong>Verifiable State</strong>: All handler operations are recorded in the chain</li>
<li><strong>Explicit Permissions</strong>: Actors must explicitly declare which handlers they use</li>
</ol>
<h2 id="developing-custom-handlers"><a class="header" href="#developing-custom-handlers">Developing Custom Handlers</a></h2>
<p>To develop a new handler for Theater:</p>
<ol>
<li><strong>Define the WIT Interface</strong>: Create a new <code>.wit</code> file defining the interface</li>
<li><strong>Implement the Handler</strong>: Create a new handler implementation in Rust</li>
<li><strong>Register the Handler</strong>: Add the handler to the configuration system</li>
<li><strong>Connect to Actor Runtime</strong>: Integrate the handler with the actor runtime</li>
</ol>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Handler Selection</strong>: Only include handlers that your actor actually needs</li>
<li><strong>Resource Management</strong>: Configure appropriate resource limits for handlers</li>
<li><strong>Error Handling</strong>: Implement proper error handling for handler operations</li>
<li><strong>Testing</strong>: Test handlers in isolation before integrating them</li>
</ol>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>In the following sections, we'll explore each handler type in detail, including:</p>
<ul>
<li>Specific configuration options</li>
<li>Available functions</li>
<li>Usage patterns</li>
<li>Examples</li>
</ul>
<p>See the individual handler documentation for more details:</p>
<ul>
<li><a href="services/handlers/message-server.html">Message Server Handler</a></li>
<li><a href="services/handlers/http-client.html">HTTP Client Handler</a></li>
<li><a href="services/handlers/http-framework.html">HTTP Framework Handler</a></li>
<li><a href="services/handlers/filesystem.html">File System Handler</a></li>
<li><a href="services/handlers/supervisor.html">Supervisor Handler</a></li>
<li><a href="services/handlers/store.html">Store Handler</a></li>
<li><a href="services/handlers/runtime.html">Runtime Handler</a></li>
<li><a href="services/handlers/timing.html">Timing Handler</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-server-handler-1"><a class="header" href="#message-server-handler-1">Message Server Handler</a></h1>
<p>The Message Server Handler is the primary mechanism for actor-to-actor communication in Theater. It enables actors to send messages to each other, establish request-response patterns, and create persistent communication channels.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The Message Server Handler implements two key interfaces:</p>
<ol>
<li><strong>message-server-host</strong>: Functions that actors can call to send messages to other actors</li>
<li><strong>message-server-client</strong>: Functions that actors implement to receive and process messages</li>
</ol>
<p>Together, these interfaces enable a complete messaging system within the Theater ecosystem.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The Message Server Handler requires minimal configuration in the actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "message-server"
config = {}
</code></pre>
<p>The handler is automatically added to all actors, so you don't need to explicitly include it in your manifest.</p>
<h2 id="messaging-patterns"><a class="header" href="#messaging-patterns">Messaging Patterns</a></h2>
<p>The Message Server Handler supports three primary communication patterns:</p>
<h3 id="1-one-way-messages-send"><a class="header" href="#1-one-way-messages-send">1. One-Way Messages (Send)</a></h3>
<p>Send messages are "fire-and-forget" - the sender doesn't wait for a response.</p>
<p><strong>Host Interface (actor calling)</strong>:</p>
<pre><code class="language-wit">send: func(actor-id: actor-id, msg: json) -&gt; result&lt;_, string&gt;;
</code></pre>
<p><strong>Client Interface (actor implementing)</strong>:</p>
<pre><code class="language-wit">handle-send: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sending a message
message_server_host::send(target_id, message_data)?;

// Handling a message
fn handle_send(state: Option&lt;Vec&lt;u8&gt;&gt;, params: (Vec&lt;u8&gt;,)) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;,), String&gt; {
    // Process message and update state
    Ok((new_state,))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-request-response-messages"><a class="header" href="#2-request-response-messages">2. Request-Response Messages</a></h3>
<p>Request messages expect a response from the recipient.</p>
<p><strong>Host Interface (actor calling)</strong>:</p>
<pre><code class="language-wit">request: func(actor-id: actor-id, msg: json) -&gt; result&lt;json, string&gt;;
</code></pre>
<p><strong>Client Interface (actor implementing)</strong>:</p>
<pre><code class="language-wit">handle-request: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;, tuple&lt;json&gt;&gt;, string&gt;;
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sending a request
let response = message_server_host::request(target_id, request_data)?;

// Handling a request
fn handle_request(state: Option&lt;Vec&lt;u8&gt;&gt;, params: (Vec&lt;u8&gt;,)) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, (Vec&lt;u8&gt;,)), String&gt; {
    // Process request, update state, and prepare response
    Ok((new_state, (response,)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-channel-based-communication"><a class="header" href="#3-channel-based-communication">3. Channel-Based Communication</a></h3>
<p>Channels provide a persistent communication pathway between actors.</p>
<p><strong>Host Interface (actor calling)</strong>:</p>
<pre><code class="language-wit">open-channel: func(actor-id: actor-id, initial-msg: json) -&gt; result&lt;string, string&gt;;
send-on-channel: func(channel-id: string, msg: json) -&gt; result&lt;_, string&gt;;
close-channel: func(channel-id: string) -&gt; result&lt;_, string&gt;;
</code></pre>
<p><strong>Client Interface (actor implementing)</strong>:</p>
<pre><code class="language-wit">handle-channel-open: func(state: option&lt;json&gt;, params: tuple&lt;json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;, tuple&lt;channel-accept&gt;&gt;, string&gt;;
handle-channel-message: func(state: option&lt;json&gt;, params: tuple&lt;string, json&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
handle-channel-close: func(state: option&lt;json&gt;, params: tuple&lt;string&gt;) -&gt; result&lt;tuple&lt;option&lt;json&gt;&gt;, string&gt;;
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Opening a channel
let channel_id = message_server_host::open_channel(target_id, initial_message)?;

// Sending on a channel
message_server_host::send_on_channel(channel_id, message_data)?;

// Closing a channel
message_server_host::close_channel(channel_id)?;

// Handling channel operations
fn handle_channel_open(state: Option&lt;Vec&lt;u8&gt;&gt;, params: (Vec&lt;u8&gt;,)) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, (ChannelAccept,)), String&gt; {
    // Process channel open request and decide whether to accept
    Ok((new_state, (channel_accept,)))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-format"><a class="header" href="#message-format">Message Format</a></h2>
<p>Messages are typically serialized as JSON bytes with a standard structure:</p>
<pre><code class="language-json">{
  "type": "message_type",
  "action": "specific_action",
  "payload": {
    "key1": "value1",
    "key2": 42
  },
  "metadata": {
    "timestamp": "2025-03-20T12:34:56Z",
    "message_id": "msg-12345"
  }
}
</code></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<p>Every message operation is recorded in the actor's state chain, maintaining a verifiable history of all communications. The event data includes:</p>
<ul>
<li>Message type (send, request, channel)</li>
<li>Timestamp</li>
<li>Recipient information</li>
<li>Success/failure status</li>
<li>Message size</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The Message Server Handler provides detailed error information for various failure scenarios:</p>
<ol>
<li><strong>Invalid Actor ID</strong>: When the target actor doesn't exist</li>
<li><strong>Delivery Failure</strong>: When the message can't be delivered</li>
<li><strong>Processing Error</strong>: When the target actor fails to process the message</li>
<li><strong>Channel Errors</strong>: When channel operations fail (non-existent channel, closed channel)</li>
</ol>
<p>All errors are properly recorded in the state chain for debugging.</p>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<p>The Message Server Handler processes messages through a dedicated task that:</p>
<ol>
<li>Receives incoming messages from the actor's mailbox</li>
<li>Processes messages based on their type</li>
<li>Calls the appropriate actor function</li>
<li>Updates the actor's state</li>
<li>Returns responses (for request messages)</li>
<li>Records all operations in the state chain</li>
</ol>
<h2 id="channel-management"><a class="header" href="#channel-management">Channel Management</a></h2>
<p>Channels have additional lifecycle management:</p>
<ol>
<li><strong>Channel Creation</strong>: A unique channel ID is generated for each channel</li>
<li><strong>Channel Acceptance</strong>: The target actor must explicitly accept the channel</li>
<li><strong>Channel State</strong>: The handler tracks which channels are open</li>
<li><strong>Channel Closure</strong>: Either participant can close the channel</li>
</ol>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ol>
<li><strong>Message Structure</strong>: Use consistent message structures with clear type and action fields</li>
<li><strong>Error Handling</strong>: Always handle potential errors from message operations</li>
<li><strong>Channel Management</strong>: Close channels when they're no longer needed</li>
<li><strong>State Design</strong>: Keep message handlers focused on state transitions</li>
<li><strong>Timeout Handling</strong>: Consider implementing timeouts for request operations</li>
</ol>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<ol>
<li><strong>Message Validation</strong>: Always validate incoming messages before processing</li>
<li><strong>Actor ID Verification</strong>: Verify actor IDs before sending messages</li>
<li><strong>Payload Size</strong>: Be mindful of message payload sizes</li>
<li><strong>Error Exposure</strong>: Don't expose sensitive information in error messages</li>
</ol>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="example-1-simple-request-response"><a class="header" href="#example-1-simple-request-response">Example 1: Simple Request-Response</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Actor sending a request
pub fn get_data_from_actor(target_id: &amp;str) -&gt; Result&lt;Data, String&gt; {
    let request = serde_json::json!({
        "type": "request",
        "action": "get_data",
        "payload": {}
    });
    
    let request_bytes = serde_json::to_vec(&amp;request).unwrap();
    let response_bytes = message_server_host::request(target_id, request_bytes)?;
    let response: Data = serde_json::from_slice(&amp;response_bytes).unwrap();
    
    Ok(response)
}

// Actor handling the request
fn handle_request(state: Option&lt;Vec&lt;u8&gt;&gt;, params: (Vec&lt;u8&gt;,)) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, (Vec&lt;u8&gt;,)), String&gt; {
    let message: serde_json::Value = serde_json::from_slice(&amp;params.0).unwrap();
    
    if message["action"] == "get_data" {
        let data = serde_json::to_vec(&amp;get_data()).unwrap();
        Ok((state, (data,)))
    } else {
        Err("Unknown action".to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-channel-communication"><a class="header" href="#example-2-channel-communication">Example 2: Channel Communication</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Actor opening a channel
pub fn open_data_stream(target_id: &amp;str) -&gt; Result&lt;String, String&gt; {
    let initial_message = serde_json::json!({
        "type": "channel",
        "action": "open_data_stream",
        "payload": {
            "frequency": "1s"
        }
    });
    
    let message_bytes = serde_json::to_vec(&amp;initial_message).unwrap();
    let channel_id = message_server_host::open_channel(target_id, message_bytes)?;
    
    Ok(channel_id)
}

// Actor handling channel open
fn handle_channel_open(state: Option&lt;Vec&lt;u8&gt;&gt;, params: (Vec&lt;u8&gt;,)) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, (ChannelAccept,)), String&gt; {
    let message: serde_json::Value = serde_json::from_slice(&amp;params.0).unwrap();
    
    if message["action"] == "open_data_stream" {
        // Accept the channel
        let channel_accept = ChannelAccept {
            accepted: true,
            message: None,
        };
        
        Ok((state, (channel_accept,)))
    } else {
        // Reject the channel
        let channel_accept = ChannelAccept {
            accepted: false,
            message: Some(b"Unsupported action".to_vec()),
        };
        
        Ok((state, (channel_accept,)))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/http-framework.html">HTTP Framework Handler</a> - For HTTP-based communication</li>
<li><a href="services/handlers/supervisor.html">Supervisor Handler</a> - For parent-child communication</li>
<li><a href="services/handlers/../core-concepts/state-management.html">State Management</a> - For understanding state chain integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-client-handler-1"><a class="header" href="#http-client-handler-1">HTTP Client Handler</a></h1>
<p>The HTTP Client Handler enables actors to make HTTP requests to external services while maintaining Theater's state verification and security principles. This handler allows actors to interact with external APIs, fetch resources, and communicate with web services.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The HTTP Client Handler implements the <code>theater:simple/http-client</code> interface, providing a way for actors to:</p>
<ol>
<li>Send HTTP requests to external services</li>
<li>Process HTTP responses</li>
<li>Record all HTTP interactions in the state chain</li>
<li>Handle errors in a consistent way</li>
</ol>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>To use the HTTP Client Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "http-client"
config = {}
</code></pre>
<p>Currently, the HTTP Client Handler doesn't require any specific configuration parameters.</p>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>The HTTP Client Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface http-client {
    use types.{json};
    use http-types.{http-request, http-response};

    send-http: func(req: http-request) -&gt; result&lt;http-response, string&gt;;
}
</code></pre>
<h3 id="http-request-structure"><a class="header" href="#http-request-structure">HTTP Request Structure</a></h3>
<p>The <code>HttpRequest</code> type has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HttpRequest {
    method: String,
    uri: String,
    headers: Vec&lt;(String, String)&gt;,
    body: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>method</code>: The HTTP method (GET, POST, PUT, DELETE, etc.)</li>
<li><code>uri</code>: The target URL</li>
<li><code>headers</code>: A list of HTTP headers as key-value pairs</li>
<li><code>body</code>: Optional request body as bytes</li>
</ul>
<h3 id="http-response-structure"><a class="header" href="#http-response-structure">HTTP Response Structure</a></h3>
<p>The <code>HttpResponse</code> type has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HttpResponse {
    status: u16,
    headers: Vec&lt;(String, String)&gt;,
    body: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>status</code>: The HTTP status code</li>
<li><code>headers</code>: A list of response headers as key-value pairs</li>
<li><code>body</code>: Optional response body as bytes</li>
</ul>
<h2 id="making-http-requests"><a class="header" href="#making-http-requests">Making HTTP Requests</a></h2>
<p>To make an HTTP request, actors call the <code>send-http</code> function with an <code>HttpRequest</code> object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let request = HttpRequest {
    method: "GET".to_string(),
    uri: "https://api.example.com/data".to_string(),
    headers: vec![
        ("Content-Type".to_string(), "application/json".to_string()),
        ("Authorization".to_string(), "Bearer token123".to_string()),
    ],
    body: None,
};

match http_client::send_http(request) {
    Ok(response) =&gt; {
        // Process response
        println!("Status: {}", response.status);
        if let Some(body) = response.body {
            // Handle response body
        }
    },
    Err(error) =&gt; {
        // Handle error
        println!("Request failed: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-chain-integration"><a class="header" href="#state-chain-integration">State Chain Integration</a></h2>
<p>Every HTTP request and response is recorded in the actor's state chain, creating a verifiable history of all external interactions. The chain events include:</p>
<ol>
<li>
<p><strong>HttpClientRequestCall</strong>: Records when a request is made, including:</p>
<ul>
<li>HTTP method</li>
<li>Target URL</li>
<li>Headers count</li>
<li>Body size</li>
</ul>
</li>
<li>
<p><strong>HttpClientRequestResult</strong>: Records the result of a request, including:</p>
<ul>
<li>Status code</li>
<li>Headers count</li>
<li>Body size</li>
<li>Success indicator</li>
</ul>
</li>
<li>
<p><strong>Error</strong>: Records any errors that occur during the request, including:</p>
<ul>
<li>Operation type</li>
<li>URL path</li>
<li>Error message</li>
</ul>
</li>
</ol>
<p>This state chain integration ensures that all external interactions are:</p>
<ul>
<li>Traceable</li>
<li>Verifiable</li>
<li>Reproducible</li>
<li>Auditable</li>
</ul>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The HTTP Client Handler provides detailed error information for various failure scenarios:</p>
<ol>
<li><strong>Invalid Method</strong>: When an invalid HTTP method is specified</li>
<li><strong>Network Errors</strong>: When network issues prevent the request from completing</li>
<li><strong>Timeout Errors</strong>: When the request times out</li>
<li><strong>Parser Errors</strong>: When response parsing fails</li>
</ol>
<p>All errors are returned as strings and are also recorded in the state chain.</p>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<p>When using the HTTP Client Handler, consider the following security aspects:</p>
<ol>
<li><strong>URL Validation</strong>: Validate URLs before making requests to prevent SSRF attacks</li>
<li><strong>Sensitive Data</strong>: Be careful with sensitive data in requests, as they are recorded in the state chain</li>
<li><strong>Authentication</strong>: Use secure methods for authentication in external APIs</li>
<li><strong>TLS Verification</strong>: The handler performs TLS verification by default</li>
<li><strong>Timeouts</strong>: Set appropriate timeouts for requests to prevent resource exhaustion</li>
</ol>
<h2 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h2>
<p>Under the hood, the HTTP Client Handler:</p>
<ol>
<li>Converts the <code>HttpRequest</code> into a reqwest client request</li>
<li>Sets up headers, body, and method</li>
<li>Executes the request asynchronously</li>
<li>Processes the response into an <code>HttpResponse</code></li>
<li>Records all operations in the state chain</li>
<li>Returns the response or error to the actor</li>
</ol>
<p>The handler uses the reqwest crate for HTTP functionality, providing a robust and well-tested HTTP client implementation.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The current HTTP Client Handler implementation has some limitations:</p>
<ol>
<li><strong>No Direct Streaming</strong>: Large responses are loaded fully into memory</li>
<li><strong>No WebSocket Support</strong>: For WebSocket connections, use a dedicated WebSocket client</li>
<li><strong>No Client Certificate Authentication</strong>: TLS client certificates are not currently supported</li>
<li><strong>No Direct Proxy Configuration</strong>: Proxy settings cannot be configured per-request</li>
</ol>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ol>
<li><strong>Error Handling</strong>: Always handle errors from HTTP requests properly</li>
<li><strong>Response Size</strong>: Be mindful of response sizes to avoid memory issues</li>
<li><strong>Request Rate</strong>: Implement rate limiting for external API calls</li>
<li><strong>Timeout Handling</strong>: Set appropriate timeouts for your use case</li>
<li><strong>Idempotency</strong>: Design requests to be idempotent when possible</li>
<li><strong>Retries</strong>: Implement retry logic for transient failures</li>
</ol>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="example-1-simple-get-request"><a class="header" href="#example-1-simple-get-request">Example 1: Simple GET Request</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch_json_data() -&gt; Result&lt;serde_json::Value, String&gt; {
    let request = HttpRequest {
        method: "GET".to_string(),
        uri: "https://api.example.com/data.json".to_string(),
        headers: vec![("Accept".to_string(), "application/json".to_string())],
        body: None,
    };
    
    let response = http_client::send_http(request)?;
    
    if response.status != 200 {
        return Err(format!("API returned status code: {}", response.status));
    }
    
    if let Some(body) = response.body {
        let json = serde_json::from_slice(&amp;body)
            .map_err(|e| format!("Failed to parse JSON: {}", e))?;
        Ok(json)
    } else {
        Err("Response body was empty".to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-post-request-with-json-body"><a class="header" href="#example-2-post-request-with-json-body">Example 2: POST Request with JSON Body</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_resource(data: &amp;CreateResourceRequest) -&gt; Result&lt;ResourceResponse, String&gt; {
    let json_body = serde_json::to_vec(data)
        .map_err(|e| format!("Failed to serialize request: {}", e))?;
    
    let request = HttpRequest {
        method: "POST".to_string(),
        uri: "https://api.example.com/resources".to_string(),
        headers: vec![
            ("Content-Type".to_string(), "application/json".to_string()),
            ("Authorization".to_string(), format!("Bearer {}", get_token())),
        ],
        body: Some(json_body),
    };
    
    let response = http_client::send_http(request)?;
    
    match response.status {
        201 =&gt; {
            // Resource created successfully
            if let Some(body) = response.body {
                let resource: ResourceResponse = serde_json::from_slice(&amp;body)
                    .map_err(|e| format!("Failed to parse response: {}", e))?;
                Ok(resource)
            } else {
                Err("Response body was empty".to_string())
            }
        },
        400..=499 =&gt; {
            // Client error
            Err(format!("Client error: {}", response.status))
        },
        500..=599 =&gt; {
            // Server error
            Err(format!("Server error: {}", response.status))
        },
        _ =&gt; {
            // Unexpected status code
            Err(format!("Unexpected status code: {}", response.status))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-file-download"><a class="header" href="#example-3-file-download">Example 3: File Download</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn download_file(url: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
    let request = HttpRequest {
        method: "GET".to_string(),
        uri: url.to_string(),
        headers: vec![],
        body: None,
    };
    
    let response = http_client::send_http(request)?;
    
    if response.status != 200 {
        return Err(format!("Download failed with status: {}", response.status));
    }
    
    if let Some(body) = response.body {
        Ok(body)
    } else {
        Err("Download resulted in empty file".to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics-1"><a class="header" href="#related-topics-1">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/http-framework.html">HTTP Framework Handler</a> - For creating HTTP servers</li>
<li><a href="services/handlers/store.html">Store Handler</a> - For storing downloaded content</li>
<li><a href="services/handlers/message-server.html">Message Server Handler</a> - For actor-to-actor communication</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-framework-handler-1"><a class="header" href="#http-framework-handler-1">HTTP Framework Handler</a></h1>
<p>The HTTP Framework Handler enables actors to serve HTTP requests, turning them into fully-functional web services. It provides a bridge between incoming HTTP requests and actor functions, allowing actors to respond to web traffic while maintaining Theater's state verification model.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The HTTP Framework Handler implements the <code>theater:simple/http-framework</code> interface, providing:</p>
<ol>
<li>A way for actors to receive and respond to HTTP requests</li>
<li>Conversion between HTTP requests and actor-friendly formats</li>
<li>Automatic state chain recording of all HTTP interactions</li>
<li>Comprehensive error handling</li>
</ol>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>To use the HTTP Framework Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "http-framework"
config = {}
</code></pre>
<p>The HTTP Framework Handler works in conjunction with the built-in HTTP server capability in Theater, which routes requests to the appropriate actors based on path configurations.</p>
<h2 id="interface-1"><a class="header" href="#interface-1">Interface</a></h2>
<p>The HTTP Framework Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface http-framework {
    use types.{state};
    use http-types.{http-request, http-response};

    handle-request: func(state: state, req: http-request) -&gt; result&lt;tuple&lt;state, http-response&gt;, string&gt;;
}
</code></pre>
<h3 id="http-request-structure-1"><a class="header" href="#http-request-structure-1">HTTP Request Structure</a></h3>
<p>The <code>HttpRequest</code> type has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HttpRequest {
    method: String,
    uri: String,
    path: String,
    query: Option&lt;String&gt;,
    headers: Vec&lt;(String, String)&gt;,
    body: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>method</code>: The HTTP method (GET, POST, PUT, DELETE, etc.)</li>
<li><code>uri</code>: The full request URI</li>
<li><code>path</code>: The path component of the URI</li>
<li><code>query</code>: Optional query string</li>
<li><code>headers</code>: A list of HTTP headers as key-value pairs</li>
<li><code>body</code>: Optional request body as bytes</li>
</ul>
<h3 id="http-response-structure-1"><a class="header" href="#http-response-structure-1">HTTP Response Structure</a></h3>
<p>The <code>HttpResponse</code> type has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HttpResponse {
    status: u16,
    headers: Vec&lt;(String, String)&gt;,
    body: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>status</code>: The HTTP status code</li>
<li><code>headers</code>: A list of response headers as key-value pairs</li>
<li><code>body</code>: Optional response body as bytes</li>
</ul>
<h2 id="handling-http-requests"><a class="header" href="#handling-http-requests">Handling HTTP Requests</a></h2>
<p>To handle HTTP requests, actors implement the <code>handle-request</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_request(state: Option&lt;Vec&lt;u8&gt;&gt;, req: HttpRequest) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, HttpResponse), String&gt; {
    // Process the request and update state
    let new_state = process_request(&amp;state, &amp;req)?;
    
    // Generate a response
    let response = HttpResponse {
        status: 200,
        headers: vec![
            ("Content-Type".to_string(), "application/json".to_string()),
        ],
        body: Some(b"Hello, world!".to_vec()),
    };
    
    Ok((new_state, response))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="routing"><a class="header" href="#routing">Routing</a></h2>
<p>The HTTP Framework Handler maps incoming HTTP requests to actor functions based on the request path. This is configured through the Theater system's HTTP server configuration.</p>
<p>For example, to route all requests to <code>/api/users</code> to a specific actor:</p>
<pre><code class="language-toml"># System configuration
[[http_routes]]
path = "/api/users"
actor_id = "user-service-actor"

# In the actor's manifest
[[handlers]]
type = "http-framework"
config = {}
</code></pre>
<h2 id="state-chain-integration-1"><a class="header" href="#state-chain-integration-1">State Chain Integration</a></h2>
<p>Every HTTP request and response is recorded in the actor's state chain, creating a verifiable history of all web interactions. The chain events include:</p>
<ol>
<li>
<p><strong>HttpFrameworkRequestCall</strong>: Records when a request is received, including:</p>
<ul>
<li>HTTP method</li>
<li>Path</li>
<li>Headers count</li>
<li>Body size</li>
</ul>
</li>
<li>
<p><strong>HttpFrameworkRequestResult</strong>: Records the result of processing a request, including:</p>
<ul>
<li>Status code</li>
<li>Headers count</li>
<li>Body size</li>
<li>Processing time</li>
</ul>
</li>
<li>
<p><strong>Error</strong>: Records any errors that occur during request processing, including:</p>
<ul>
<li>Operation type</li>
<li>Path</li>
<li>Error message</li>
</ul>
</li>
</ol>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>The HTTP Framework Handler provides two layers of error handling:</p>
<ol>
<li>
<p><strong>Framework-Level Errors</strong>: Handled by the framework itself, such as:</p>
<ul>
<li>Routing errors</li>
<li>Method not allowed</li>
<li>Actor not found</li>
<li>Malformed requests</li>
</ul>
</li>
<li>
<p><strong>Actor-Level Errors</strong>: Returned by the actor's <code>handle-request</code> function, which can:</p>
<ul>
<li>Return a custom error response</li>
<li>Provide detailed error information</li>
<li>Choose appropriate HTTP status codes</li>
</ul>
</li>
</ol>
<p>If an actor returns an error, the framework generates a 500 Internal Server Error response with the error message in the body (in development mode only).</p>
<h2 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h2>
<p>When using the HTTP Framework Handler, consider the following security aspects:</p>
<ol>
<li><strong>Input Validation</strong>: Always validate and sanitize all HTTP request data</li>
<li><strong>Authentication</strong>: Implement proper authentication for protected endpoints</li>
<li><strong>Rate Limiting</strong>: Consider rate limiting to prevent abuse</li>
<li><strong>Error Information</strong>: Be careful about exposing error details in production</li>
<li><strong>CORS Policies</strong>: Implement appropriate CORS headers for browser security</li>
<li><strong>Content Security</strong>: Set proper content security policies</li>
</ol>
<h2 id="implementation-details-3"><a class="header" href="#implementation-details-3">Implementation Details</a></h2>
<p>Under the hood, the HTTP Framework Handler:</p>
<ol>
<li>Receives HTTP requests from the Theater HTTP server</li>
<li>Converts them to the <code>HttpRequest</code> format</li>
<li>Retrieves the current actor state</li>
<li>Calls the actor's <code>handle-request</code> function</li>
<li>Updates the actor's state with the new state</li>
<li>Converts the <code>HttpResponse</code> back to an HTTP response</li>
<li>Records all operations in the state chain</li>
<li>Returns the response to the client</li>
</ol>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ol>
<li><strong>RESTful Design</strong>: Follow RESTful principles for API design</li>
<li><strong>Stateless Design</strong>: Keep HTTP handlers as stateless as possible</li>
<li><strong>Error Handling</strong>: Implement proper error handling with appropriate status codes</li>
<li><strong>Content Types</strong>: Set appropriate Content-Type headers</li>
<li><strong>Validation</strong>: Validate all incoming data</li>
<li><strong>Testing</strong>: Test all endpoints with various input scenarios</li>
<li><strong>Documentation</strong>: Document your API endpoints clearly</li>
</ol>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="example-1-simple-json-api"><a class="header" href="#example-1-simple-json-api">Example 1: Simple JSON API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_request(state: Option&lt;Vec&lt;u8&gt;&gt;, req: HttpRequest) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, HttpResponse), String&gt; {
    // Parse the current state or initialize it
    let current_state: AppState = match state {
        Some(data) =&gt; serde_json::from_slice(&amp;data).map_err(|e| e.to_string())?,
        None =&gt; AppState::default(),
    };
    
    match (req.method.as_str(), req.path.as_str()) {
        ("GET", "/api/items") =&gt; {
            // Return all items
            let items_json = serde_json::to_vec(&amp;current_state.items).map_err(|e| e.to_string())?;
            Ok((
                state,
                HttpResponse {
                    status: 200,
                    headers: vec![
                        ("Content-Type".to_string(), "application/json".to_string()),
                    ],
                    body: Some(items_json),
                }
            ))
        },
        ("POST", "/api/items") =&gt; {
            // Add a new item
            if let Some(body) = req.body {
                let new_item: Item = serde_json::from_slice(&amp;body).map_err(|e| e.to_string())?;
                
                // Update state
                let mut new_state = current_state.clone();
                new_state.items.push(new_item);
                
                // Serialize new state
                let new_state_bytes = serde_json::to_vec(&amp;new_state).map_err(|e| e.to_string())?;
                
                // Return success response
                Ok((
                    Some(new_state_bytes),
                    HttpResponse {
                        status: 201,
                        headers: vec![
                            ("Content-Type".to_string(), "application/json".to_string()),
                        ],
                        body: Some(b"{\"status\":\"created\"}".to_vec()),
                    }
                ))
            } else {
                // Return error for missing body
                Ok((
                    state,
                    HttpResponse {
                        status: 400,
                        headers: vec![
                            ("Content-Type".to_string(), "application/json".to_string()),
                        ],
                        body: Some(b"{\"error\":\"Missing request body\"}".to_vec()),
                    }
                ))
            }
        },
        _ =&gt; {
            // Return 404 for unmatched routes
            Ok((
                state,
                HttpResponse {
                    status: 404,
                    headers: vec![
                        ("Content-Type".to_string(), "application/json".to_string()),
                    ],
                    body: Some(b"{\"error\":\"Not found\"}".to_vec()),
                }
            ))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-file-serving"><a class="header" href="#example-2-file-serving">Example 2: File Serving</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_request(state: Option&lt;Vec&lt;u8&gt;&gt;, req: HttpRequest) -&gt; Result&lt;(Option&lt;Vec&lt;u8&gt;&gt;, HttpResponse), String&gt; {
    // Only handle GET requests
    if req.method != "GET" {
        return Ok((
            state,
            HttpResponse {
                status: 405,
                headers: vec![
                    ("Content-Type".to_string(), "text/plain".to_string()),
                    ("Allow".to_string(), "GET".to_string()),
                ],
                body: Some(b"Method Not Allowed".to_vec()),
            }
        ));
    }
    
    // Extract the requested file path
    let path = req.path.trim_start_matches('/');
    
    // Use the filesystem handler to read the file
    match filesystem::read_file(path) {
        Ok(file_content) =&gt; {
            // Determine content type based on file extension
            let content_type = match path.split('.').last() {
                Some("html") =&gt; "text/html",
                Some("css") =&gt; "text/css",
                Some("js") =&gt; "application/javascript",
                Some("json") =&gt; "application/json",
                Some("png") =&gt; "image/png",
                Some("jpg") | Some("jpeg") =&gt; "image/jpeg",
                Some("svg") =&gt; "image/svg+xml",
                _ =&gt; "application/octet-stream",
            };
            
            // Return the file content
            Ok((
                state,
                HttpResponse {
                    status: 200,
                    headers: vec![
                        ("Content-Type".to_string(), content_type.to_string()),
                    ],
                    body: Some(file_content),
                }
            ))
        },
        Err(_) =&gt; {
            // File not found
            Ok((
                state,
                HttpResponse {
                    status: 404,
                    headers: vec![
                        ("Content-Type".to_string(), "text/plain".to_string()),
                    ],
                    body: Some(b"File Not Found".to_vec()),
                }
            ))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics-2"><a class="header" href="#related-topics-2">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/http-client.html">HTTP Client Handler</a> - For making HTTP requests from actors</li>
<li><a href="services/handlers/message-server.html">Message Server Handler</a> - For actor-to-actor communication</li>
<li><a href="services/handlers/filesystem.html">File System Handler</a> - For accessing the file system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystem-handler-1"><a class="header" href="#filesystem-handler-1">Filesystem Handler</a></h1>
<p>The Filesystem Handler provides actors with controlled access to the local filesystem. It enables reading and writing files, directory operations, and file metadata access, all while maintaining the Theater security model and state verification.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The Filesystem Handler implements the <code>theater:simple/filesystem</code> interface, providing actors with the ability to:</p>
<ol>
<li>Read and write files securely</li>
<li>Create and manage directories</li>
<li>Get file metadata</li>
<li>List directory contents</li>
<li>Safely access files within a specified path boundary</li>
</ol>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>To use the Filesystem Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "filesystem"
config = { 
    path = "data/my-actor",
    allowed_commands = ["read", "write"]
}
</code></pre>
<p>Configuration options:</p>
<ul>
<li><code>path</code>: (Optional) The base directory for all file operations, restricting access to this directory and its subdirectories</li>
<li><code>new_dir</code>: (Optional) If <code>true</code>, creates a new directory in /tmp/theater for the actor; if <code>false</code>, uses the specified path directly</li>
<li><code>allowed_commands</code>: (Optional) List of allowed filesystem operations; if not specified, all operations are allowed</li>
</ul>
<h2 id="interface-2"><a class="header" href="#interface-2">Interface</a></h2>
<p>The Filesystem Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface filesystem {
    read-file: func(path: string) -&gt; result&lt;list&lt;u8&gt;, string&gt;;
    write-file: func(path: string, content: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;
    append-file: func(path: string, content: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;
    exists: func(path: string) -&gt; result&lt;bool, string&gt;;
    is-file: func(path: string) -&gt; result&lt;bool, string&gt;;
    is-dir: func(path: string) -&gt; result&lt;bool, string&gt;;
    create-dir: func(path: string) -&gt; result&lt;_, string&gt;;
    remove-file: func(path: string) -&gt; result&lt;_, string&gt;;
    remove-dir: func(path: string) -&gt; result&lt;_, string&gt;;
    list-dir: func(path: string) -&gt; result&lt;list&lt;file-entry&gt;, string&gt;;
    metadata: func(path: string) -&gt; result&lt;file-metadata, string&gt;;

    record file-entry {
        name: string,
        is-file: bool,
        is-dir: bool,
    }

    record file-metadata {
        name: string,
        path: string,
        size: u64,
        is-file: bool,
        is-dir: bool,
        created: option&lt;u64&gt;,
        modified: option&lt;u64&gt;,
        accessed: option&lt;u64&gt;,
    }
}
</code></pre>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<h3 id="reading-files"><a class="header" href="#reading-files">Reading Files</a></h3>
<p>To read a file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match filesystem::read_file("config.json") {
    Ok(content) =&gt; {
        // Process file content
        let config: Config = serde_json::from_slice(&amp;content).unwrap();
        // ...
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to read file: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="writing-files"><a class="header" href="#writing-files">Writing Files</a></h3>
<p>To write a file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = serde_json::to_vec(&amp;config).unwrap();
match filesystem::write_file("config.json", data) {
    Ok(_) =&gt; {
        // File written successfully
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to write file: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="appending-to-files"><a class="header" href="#appending-to-files">Appending to Files</a></h3>
<p>To append to a file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_entry = format!("[{}] User logged in\n", get_timestamp());
match filesystem::append_file("logs/app.log", log_entry.into_bytes()) {
    Ok(_) =&gt; {
        // Log entry added successfully
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to append to log: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="directory-operations"><a class="header" href="#directory-operations">Directory Operations</a></h2>
<h3 id="creating-directories"><a class="header" href="#creating-directories">Creating Directories</a></h3>
<p>To create a directory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match filesystem::create_dir("data/uploads") {
    Ok(_) =&gt; {
        // Directory created successfully
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to create directory: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="listing-directory-contents"><a class="header" href="#listing-directory-contents">Listing Directory Contents</a></h3>
<p>To list directory contents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match filesystem::list_dir("data") {
    Ok(entries) =&gt; {
        for entry in entries {
            println!(
                "{}: {}",
                if entry.is_file { "FILE" } else { "DIR " },
                entry.name
            );
        }
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to list directory: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="file-information"><a class="header" href="#file-information">File Information</a></h2>
<h3 id="checking-if-a-file-exists"><a class="header" href="#checking-if-a-file-exists">Checking if a File Exists</a></h3>
<p>To check if a file or directory exists:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match filesystem::exists("config.json") {
    Ok(exists) =&gt; {
        if exists {
            // File exists, proceed with operation
        } else {
            // File doesn't exist, handle accordingly
        }
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to check file existence: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-file-metadata"><a class="header" href="#getting-file-metadata">Getting File Metadata</a></h3>
<p>To get file metadata:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match filesystem::metadata("data/file.txt") {
    Ok(metadata) =&gt; {
        println!("Name: {}", metadata.name);
        println!("Size: {} bytes", metadata.size);
        println!("Is file: {}", metadata.is_file);
        println!("Is directory: {}", metadata.is_dir);
        
        if let Some(created) = metadata.created {
            println!("Created: {}", format_timestamp(created));
        }
        
        if let Some(modified) = metadata.modified {
            println!("Modified: {}", format_timestamp(modified));
        }
    },
    Err(error) =&gt; {
        // Handle error
        println!("Failed to get file metadata: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="path-resolution"><a class="header" href="#path-resolution">Path Resolution</a></h2>
<p>All paths in the Filesystem Handler are resolved relative to the base directory specified in the configuration. This provides a security boundary that prevents actors from accessing files outside their designated area.</p>
<p>For example, if the base directory is configured as <code>data/my-actor</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Actual path: data/my-actor/config.json
filesystem::read_file("config.json");

// Actual path: data/my-actor/logs/app.log
filesystem::write_file("logs/app.log", content);
<span class="boring">}</span></code></pre></pre>
<p>Attempts to access files outside this boundary using path traversal (e.g., <code>../other-actor/file.txt</code>) will be blocked by the handler.</p>
<h2 id="state-chain-integration-2"><a class="header" href="#state-chain-integration-2">State Chain Integration</a></h2>
<p>All filesystem operations are recorded in the actor's state chain, creating a verifiable history. The chain events include:</p>
<ol>
<li>
<p><strong>FilesystemOperation</strong>: Records details of the operation:</p>
<ul>
<li>Operation type (read, write, list, etc.)</li>
<li>Path</li>
<li>Size (for read/write operations)</li>
<li>Success/failure status</li>
</ul>
</li>
<li>
<p><strong>Error</strong>: Records any errors that occur:</p>
<ul>
<li>Operation type</li>
<li>Path</li>
<li>Error message</li>
</ul>
</li>
</ol>
<p>This integration ensures that all file interactions are:</p>
<ul>
<li>Traceable</li>
<li>Verifiable</li>
<li>Reproducible</li>
<li>Auditable</li>
</ul>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>The Filesystem Handler provides detailed error information for various failure scenarios:</p>
<ol>
<li><strong>Permission Errors</strong>: When trying to access files outside the allowed path</li>
<li><strong>Not Found Errors</strong>: When a file or directory doesn't exist</li>
<li><strong>IO Errors</strong>: When read/write operations fail</li>
<li><strong>Format Errors</strong>: When paths are invalid</li>
<li><strong>Operation Not Allowed</strong>: When trying to use a disabled operation</li>
</ol>
<p>All errors are returned as strings and are also recorded in the state chain.</p>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<p>When using the Filesystem Handler, consider the following security aspects:</p>
<ol>
<li><strong>Path Configuration</strong>: Set the base path to limit file access</li>
<li><strong>Limited Permissions</strong>: Use <code>allowed_commands</code> to restrict operations</li>
<li><strong>Input Validation</strong>: Validate file paths before using them</li>
<li><strong>Content Validation</strong>: Validate file contents before writing</li>
<li><strong>Error Handling</strong>: Properly handle all error cases</li>
<li><strong>Resource Limits</strong>: Be mindful of file sizes and disk usage</li>
</ol>
<h2 id="implementation-details-4"><a class="header" href="#implementation-details-4">Implementation Details</a></h2>
<p>Under the hood, the Filesystem Handler:</p>
<ol>
<li>Validates all paths against the configured base directory</li>
<li>Translates WIT interface calls to Rust's standard library file operations</li>
<li>Handles errors and security checks</li>
<li>Records all operations in the state chain</li>
<li>Manages file handles and resources properly</li>
</ol>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>The current Filesystem Handler implementation has some limitations:</p>
<ol>
<li><strong>No Streaming</strong>: Large files are loaded fully into memory</li>
<li><strong>No Symbolic Link Following</strong>: Symbolic links are not followed</li>
<li><strong>Limited Metadata</strong>: Some platform-specific file metadata is not available</li>
<li><strong>No File Locking</strong>: Concurrent access is not protected by file locks</li>
<li><strong>No Special Files</strong>: Device files, sockets, etc. are not supported</li>
</ol>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<ol>
<li><strong>Path Management</strong>: Use relative paths within your base directory</li>
<li><strong>Error Handling</strong>: Always handle file operation errors properly</li>
<li><strong>Resource Cleanup</strong>: Clean up temporary files when they're no longer needed</li>
<li><strong>Directory Structure</strong>: Create a clear directory structure for your actor's data</li>
<li><strong>Rate Limiting</strong>: Implement rate limiting for frequent file operations</li>
<li><strong>Backups</strong>: Implement backup mechanisms for important data</li>
</ol>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="example-1-configuration-management"><a class="header" href="#example-1-configuration-management">Example 1: Configuration Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load configuration
fn load_config() -&gt; Result&lt;Config, String&gt; {
    match filesystem::exists("config.json") {
        Ok(exists) =&gt; {
            if exists {
                match filesystem::read_file("config.json") {
                    Ok(content) =&gt; {
                        let config: Config = serde_json::from_slice(&amp;content)
                            .map_err(|e| format!("Failed to parse config: {}", e))?;
                        Ok(config)
                    },
                    Err(e) =&gt; Err(format!("Failed to read config: {}", e)),
                }
            } else {
                // Create default config if not exists
                let default_config = Config::default();
                save_config(&amp;default_config)?;
                Ok(default_config)
            }
        },
        Err(e) =&gt; Err(format!("Failed to check config existence: {}", e)),
    }
}

// Save configuration
fn save_config(config: &amp;Config) -&gt; Result&lt;(), String&gt; {
    let content = serde_json::to_vec(config)
        .map_err(|e| format!("Failed to serialize config: {}", e))?;
    
    filesystem::write_file("config.json", content)
        .map_err(|e| format!("Failed to write config: {}", e))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-log-management"><a class="header" href="#example-2-log-management">Example 2: Log Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn log_event(event: &amp;Event) -&gt; Result&lt;(), String&gt; {
    // Create logs directory if not exists
    match filesystem::exists("logs") {
        Ok(exists) =&gt; {
            if !exists {
                filesystem::create_dir("logs")
                    .map_err(|e| format!("Failed to create logs directory: {}", e))?;
            }
        },
        Err(e) =&gt; return Err(format!("Failed to check logs directory: {}", e)),
    }
    
    // Format log entry
    let timestamp = chrono::Utc::now().to_rfc3339();
    let log_entry = format!("[{}] {}\n", timestamp, event.to_string());
    
    // Append to log file
    filesystem::append_file("logs/events.log", log_entry.into_bytes())
        .map_err(|e| format!("Failed to write log: {}", e))
}

// Rotate logs if they get too large
fn rotate_logs_if_needed() -&gt; Result&lt;(), String&gt; {
    match filesystem::metadata("logs/events.log") {
        Ok(metadata) =&gt; {
            if metadata.size &gt; MAX_LOG_SIZE {
                // Generate backup filename with timestamp
                let timestamp = chrono::Utc::now().timestamp();
                let backup_name = format!("logs/events-{}.log", timestamp);
                
                // Read current log
                let content = filesystem::read_file("logs/events.log")
                    .map_err(|e| format!("Failed to read log for rotation: {}", e))?;
                
                // Write to backup file
                filesystem::write_file(&amp;backup_name, content)
                    .map_err(|e| format!("Failed to write backup log: {}", e))?;
                
                // Clear original log
                filesystem::write_file("logs/events.log", vec![])
                    .map_err(|e| format!("Failed to clear log: {}", e))?;
            }
            Ok(())
        },
        Err(_) =&gt; Ok(()), // Log file doesn't exist yet, nothing to rotate
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics-3"><a class="header" href="#related-topics-3">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/store.html">Store Handler</a> - Alternative storage mechanism with content-addressable features</li>
<li><a href="services/handlers/http-framework.html">HTTP Framework Handler</a> - For creating HTTP endpoints that serve files</li>
<li><a href="services/handlers/runtime.html">Runtime Handler</a> - For accessing runtime information and operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supervisor-handler-1"><a class="header" href="#supervisor-handler-1">Supervisor Handler</a></h1>
<p>The Supervisor Handler enables parent-child relationships between actors in Theater. It provides the foundation for actor supervision hierarchies, allowing parent actors to spawn, monitor, and control child actors while maintaining the Theater security and verification model.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>The Supervisor Handler implements the <code>theater:simple/supervisor</code> interface, enabling actors to:</p>
<ol>
<li>Spawn new child actors</li>
<li>Monitor child actor lifecycle events</li>
<li>Access child actor state and events</li>
<li>Stop and restart child actors</li>
<li>Implement supervision strategies for fault tolerance</li>
</ol>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>To use the Supervisor Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "supervisor"
config = {}
</code></pre>
<p>The Supervisor Handler doesn't currently require any specific configuration parameters.</p>
<h2 id="interface-3"><a class="header" href="#interface-3">Interface</a></h2>
<p>The Supervisor Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface supervisor {
    // Spawn a new child actor from a manifest
    spawn: func(manifest: string) -&gt; result&lt;string, string&gt;;
    
    // List all child actor IDs
    list-children: func() -&gt; list&lt;string&gt;;
    
    // Stop a specific child actor
    stop-child: func(child-id: string) -&gt; result&lt;_, string&gt;;
    
    // Restart a specific child actor
    restart-child: func(child-id: string) -&gt; result&lt;_, string&gt;;
    
    // Get the current state of a child actor
    get-child-state: func(child-id: string) -&gt; result&lt;list&lt;u8&gt;, string&gt;;
    
    // Get the event history of a child actor
    get-child-events: func(child-id: string) -&gt; result&lt;list&lt;chain-event&gt;, string&gt;;
    
    // Record structure for chain events
    record chain-event {
        hash: list&lt;u8&gt;,
        parent-hash: option&lt;list&lt;u8&gt;&gt;,
        event-type: string,
        data: list&lt;u8&gt;,
        timestamp: u64
    }
}
</code></pre>
<h2 id="spawning-child-actors"><a class="header" href="#spawning-child-actors">Spawning Child Actors</a></h2>
<p>The most fundamental operation in the supervision system is spawning child actors. This is done using the <code>spawn</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manifest can be a path to a TOML file or the TOML content as a string
let manifest = r#"
name = "child-actor"
component_path = "child_actor.wasm"

[[handlers]]
type = "message-server"
config = {}
"#;

match supervisor::spawn(manifest) {
    Ok(child_id) =&gt; {
        println!("Spawned child actor with ID: {}", child_id);
        // Store the child ID for future reference
    },
    Err(error) =&gt; {
        println!("Failed to spawn child actor: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="managing-child-actors"><a class="header" href="#managing-child-actors">Managing Child Actors</a></h2>
<h3 id="listing-children"><a class="header" href="#listing-children">Listing Children</a></h3>
<p>To get a list of all child actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let children = supervisor::list_children();
println!("Child actors: {:?}", children);
<span class="boring">}</span></code></pre></pre>
<h3 id="stopping-a-child"><a class="header" href="#stopping-a-child">Stopping a Child</a></h3>
<p>To gracefully stop a child actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match supervisor::stop_child(child_id) {
    Ok(_) =&gt; {
        println!("Child actor stopped successfully");
    },
    Err(error) =&gt; {
        println!("Failed to stop child actor: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="restarting-a-child"><a class="header" href="#restarting-a-child">Restarting a Child</a></h3>
<p>To restart a child actor (useful after failures):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match supervisor::restart_child(child_id) {
    Ok(_) =&gt; {
        println!("Child actor restarted successfully");
    },
    Err(error) =&gt; {
        println!("Failed to restart child actor: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-child-state-and-events"><a class="header" href="#accessing-child-state-and-events">Accessing Child State and Events</a></h2>
<p>One of the powerful features of the supervision system is the ability to access child actor state and event history.</p>
<h3 id="getting-child-state"><a class="header" href="#getting-child-state">Getting Child State</a></h3>
<p>To get the current state of a child actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match supervisor::get_child_state(child_id) {
    Ok(state_bytes) =&gt; {
        // Process the child state
        if let Some(bytes) = state_bytes {
            let state: ChildState = serde_json::from_slice(&amp;bytes)
                .expect("Failed to deserialize child state");
            println!("Child state: {:?}", state);
        } else {
            println!("Child has no state");
        }
    },
    Err(error) =&gt; {
        println!("Failed to get child state: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-child-events"><a class="header" href="#getting-child-events">Getting Child Events</a></h3>
<p>To get the event history of a child actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match supervisor::get_child_events(child_id) {
    Ok(events) =&gt; {
        println!("Child has {} events", events.len());
        
        for event in events {
            println!("Event type: {}", event.event_type);
            println!("Timestamp: {}", event.timestamp);
            
            // Process event data based on type
            // ...
        }
    },
    Err(error) =&gt; {
        println!("Failed to get child events: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="supervision-strategies"><a class="header" href="#supervision-strategies">Supervision Strategies</a></h2>
<p>The Supervisor Handler enables the implementation of different supervision strategies inspired by the Erlang/OTP model:</p>
<h3 id="one-for-one-strategy"><a class="header" href="#one-for-one-strategy">One-for-One Strategy</a></h3>
<p>Restart only the failed child:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_child_failure(child_id: &amp;str) -&gt; Result&lt;(), String&gt; {
    // Attempt to restart the failed child
    supervisor::restart_child(child_id)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="all-for-one-strategy"><a class="header" href="#all-for-one-strategy">All-for-One Strategy</a></h3>
<p>Restart all children when one fails:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_child_failure(failed_child_id: &amp;str) -&gt; Result&lt;(), String&gt; {
    // Get all children
    let children = supervisor::list_children();
    
    // Restart all children
    for child_id in children {
        supervisor::restart_child(&amp;child_id)?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rest-for-one-strategy"><a class="header" href="#rest-for-one-strategy">Rest-for-One Strategy</a></h3>
<p>Restart the failed child and all children that depend on it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_child_failure(failed_child_id: &amp;str) -&gt; Result&lt;(), String&gt; {
    // Get dependency tree (implementation specific)
    let dependent_children = get_dependent_children(failed_child_id);
    
    // Restart the failed child first
    supervisor::restart_child(failed_child_id)?;
    
    // Then restart dependent children
    for child_id in dependent_children {
        supervisor::restart_child(&amp;child_id)?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-chain-integration-3"><a class="header" href="#state-chain-integration-3">State Chain Integration</a></h2>
<p>All supervision operations are recorded in the parent actor's state chain, creating a verifiable history. The chain events include:</p>
<ol>
<li>
<p><strong>SupervisorOperation</strong>: Records details of supervision operations:</p>
<ul>
<li>Operation type (spawn, stop, restart, etc.)</li>
<li>Child actor ID</li>
<li>Result (success/failure)</li>
</ul>
</li>
<li>
<p><strong>ChildLifecycleEvent</strong>: Records child lifecycle events:</p>
<ul>
<li>Child actor ID</li>
<li>Event type (started, stopped, crashed, etc.)</li>
<li>Timestamp</li>
</ul>
</li>
</ol>
<p>This integration ensures that all supervision activities are:</p>
<ul>
<li>Traceable</li>
<li>Verifiable</li>
<li>Reproducible</li>
<li>Auditable</li>
</ul>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<p>The Supervisor Handler provides detailed error information for various failure scenarios:</p>
<ol>
<li><strong>Spawn Errors</strong>: When child actor creation fails</li>
<li><strong>Stop Errors</strong>: When child actor termination fails</li>
<li><strong>Restart Errors</strong>: When child actor restart fails</li>
<li><strong>Not Found Errors</strong>: When the specified child actor doesn't exist</li>
<li><strong>Access Errors</strong>: When accessing child state or events fails</li>
</ol>
<h2 id="security-considerations-4"><a class="header" href="#security-considerations-4">Security Considerations</a></h2>
<p>When using the Supervisor Handler, consider the following security aspects:</p>
<ol>
<li><strong>Child Isolation</strong>: Child actors run in separate WebAssembly sandboxes</li>
<li><strong>State Access Controls</strong>: Only direct parent actors can access child state</li>
<li><strong>Manifest Validation</strong>: Validate manifests before spawning actors</li>
<li><strong>Resource Limits</strong>: Consider setting limits on child actor resource usage</li>
<li><strong>Privilege Separation</strong>: Design actor hierarchies with security in mind</li>
</ol>
<h2 id="implementation-details-5"><a class="header" href="#implementation-details-5">Implementation Details</a></h2>
<p>Under the hood, the Supervisor Handler:</p>
<ol>
<li>Communicates with the Theater runtime to manage child actors</li>
<li>Tracks parent-child relationships in the actor system</li>
<li>Routes supervision commands to the appropriate actors</li>
<li>Manages actor processes and mailboxes</li>
<li>Handles actor lifecycle events</li>
<li>Records all supervision activities in the state chain</li>
</ol>
<h2 id="building-supervision-trees"><a class="header" href="#building-supervision-trees">Building Supervision Trees</a></h2>
<p>Supervision trees are a powerful pattern for structuring actor systems. Here's how to build a basic supervision tree:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn root supervisor actor
fn init() -&gt; Result&lt;(), String&gt; {
    // Spawn worker actors
    let worker1_id = spawn_worker("worker1")?;
    let worker2_id = spawn_worker("worker2")?;
    
    // Spawn supervisor for a group of related workers
    let group_supervisor_id = spawn_group_supervisor()?;
    
    // Store child IDs for future reference
    let mut state = get_current_state();
    state.children = vec![worker1_id, worker2_id, group_supervisor_id];
    update_state(state);
    
    Ok(())
}

// Function to spawn a worker actor
fn spawn_worker(name: &amp;str) -&gt; Result&lt;String, String&gt; {
    let manifest = format!(r#"
        name = "{}"
        component_path = "worker.wasm"

        [[handlers]]
        type = "message-server"
        config = {{}}
    "#, name);
    
    supervisor::spawn(&amp;manifest)
}

// Function to spawn a group supervisor
fn spawn_group_supervisor() -&gt; Result&lt;String, String&gt; {
    let manifest = r#"
        name = "group-supervisor"
        component_path = "supervisor.wasm"

        [[handlers]]
        type = "supervisor"
        config = {}

        [[handlers]]
        type = "message-server"
        config = {}
    "#;
    
    let supervisor_id = supervisor::spawn(manifest)?;
    
    // Send message to initialize the group supervisor
    // This will cause it to spawn its own child workers
    message_server::request(supervisor_id, init_message())?;
    
    Ok(supervisor_id)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<ol>
<li><strong>Hierarchical Design</strong>: Design clear supervision hierarchies</li>
<li><strong>Failure Domains</strong>: Group related actors under the same supervisor</li>
<li><strong>Restart Strategies</strong>: Choose appropriate restart strategies for different components</li>
<li><strong>State Recovery</strong>: Design child actors to recover gracefully from restarts</li>
<li><strong>Error Handling</strong>: Handle supervision errors properly</li>
<li><strong>Monitoring</strong>: Implement monitoring for supervisor decisions</li>
<li><strong>Testing</strong>: Test supervisor behavior with fault injection</li>
</ol>
<h2 id="dynamic-supervision"><a class="header" href="#dynamic-supervision">Dynamic Supervision</a></h2>
<p>You can implement dynamic supervision patterns where actors are spawned and managed at runtime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Handle a request to create a new worker
fn handle_create_worker_request(params: CreateWorkerParams) -&gt; Result&lt;WorkerCreatedResponse, String&gt; {
    // Create a manifest dynamically based on parameters
    let manifest = format!(r#"
        name = "{}"
        component_path = "{}"

        [[handlers]]
        type = "message-server"
        config = {{}}
        
<span class="boring">        Additional handlers based on parameters
</span>        {}
    "#, params.name, params.component_path, generate_handler_config(&amp;params));
    
    // Spawn the worker
    let worker_id = supervisor::spawn(&amp;manifest)?;
    
    // Update supervisor state with new worker
    let mut current_state = get_current_state();
    current_state.workers.push(WorkerInfo {
        id: worker_id.clone(),
        name: params.name.clone(),
        created_at: get_current_time(),
    });
    update_state(current_state);
    
    // Return worker ID to requester
    Ok(WorkerCreatedResponse {
        worker_id,
        status: "created".to_string(),
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics-4"><a class="header" href="#related-topics-4">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/message-server.html">Message Server Handler</a> - For actor-to-actor communication</li>
<li><a href="services/handlers/runtime.html">Runtime Handler</a> - For accessing runtime information and operations</li>
<li><a href="services/handlers/store.html">Store Handler</a> - For content-addressable storage</li>
<li><a href="services/handlers/../core-concepts/state-management.html">State Management</a> - For understanding state chain integration</li>
<li><a href="services/handlers/../core-concepts/supervision.html">Supervision</a> - For deeper supervision concepts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-handler-1"><a class="header" href="#store-handler-1">Store Handler</a></h1>
<p>The Store Handler provides actors with access to Theater's content-addressable storage system. It enables actors to store and retrieve data using content hashes, create and manage labels for easier reference, and maintain persistent data across actor restarts.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>The Store Handler implements the <code>theater:simple/store</code> interface, enabling actors to:</p>
<ol>
<li>Create and manage store instances</li>
<li>Store and retrieve data using content-addressable storage</li>
<li>Create and manage labels for easy content reference</li>
<li>Check for content existence and calculate storage size</li>
<li>Efficiently deduplicate content</li>
<li>Persistently store data across actor restarts and system reboots</li>
</ol>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<p>To use the Store Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "store"
config = {}
</code></pre>
<p>The Store Handler doesn't currently require any specific configuration parameters.</p>
<h2 id="interface-4"><a class="header" href="#interface-4">Interface</a></h2>
<p>The Store Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface store {
    /// A reference to content in the store
    record content-ref {
        hash: string,
    }

    /// Create a new store
    new: func() -&gt; result&lt;string, string&gt;;

    /// Store content and return a reference
    store: func(store-id: string, content: list&lt;u8&gt;) -&gt; result&lt;content-ref, string&gt;;

    /// Retrieve content by reference
    get: func(store-id: string, content-ref: content-ref) -&gt; result&lt;list&lt;u8&gt;, string&gt;;

    /// Check if content exists
    exists: func(store-id: string, content-ref: content-ref) -&gt; result&lt;bool, string&gt;;

    /// Label content with a string identifier
    label: func(store-id: string, label: string, content-ref: content-ref) -&gt; result&lt;_, string&gt;;

    /// Get content reference by label (returns None if label doesn't exist)
    get-by-label: func(store-id: string, label: string) -&gt; result&lt;option&lt;content-ref&gt;, string&gt;;

    /// Store content and label it in one operation
    store-at-label: func(store-id: string, label: string, content: list&lt;u8&gt;) -&gt; result&lt;content-ref, string&gt;;

    /// Replace content at a label
    replace-content-at-label: func(store-id: string, label: string, content: list&lt;u8&gt;) -&gt; result&lt;content-ref, string&gt;;

    /// Replace a content reference at a label
    replace-at-label: func(store-id: string, label: string, content-ref: content-ref) -&gt; result&lt;_, string&gt;;

    /// Remove a label
    remove-label: func(store-id: string, label: string) -&gt; result&lt;_, string&gt;;

    /// List all labels in the store
    list-labels: func(store-id: string) -&gt; result&lt;list&lt;string&gt;, string&gt;;

    /// List all content in the store
    list-all-content: func(store-id: string) -&gt; result&lt;list&lt;content-ref&gt;, string&gt;;

    /// Calculate total size of all content in the store
    calculate-total-size: func(store-id: string) -&gt; result&lt;u64, string&gt;;
}
</code></pre>
<h2 id="store-management-operations"><a class="header" href="#store-management-operations">Store Management Operations</a></h2>
<h3 id="creating-a-store"><a class="header" href="#creating-a-store">Creating a Store</a></h3>
<p>To create a new store instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::new() {
    Ok(store_id) =&gt; {
        println!("Created new store with ID: {}", store_id);
        // Save the store ID for future operations
    },
    Err(error) =&gt; {
        println!("Failed to create store: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="content-storage-operations"><a class="header" href="#content-storage-operations">Content Storage Operations</a></h2>
<h3 id="storing-content"><a class="header" href="#storing-content">Storing Content</a></h3>
<p>To store content in the store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = b"Important data".to_vec();

match store::store(store_id.clone(), data) {
    Ok(content_ref) =&gt; {
        println!("Content stored with hash: {}", content_ref.hash);
        // Save the content reference for future use
    },
    Err(error) =&gt; {
        println!("Failed to store content: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="retrieving-content"><a class="header" href="#retrieving-content">Retrieving Content</a></h3>
<p>To retrieve content using a content reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::get(store_id.clone(), content_ref) {
    Ok(content) =&gt; {
        // Process the retrieved content
        let text = String::from_utf8(content).expect("Not valid UTF-8");
        println!("Retrieved content: {}", text);
    },
    Err(error) =&gt; {
        println!("Failed to retrieve content: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checking-content-existence"><a class="header" href="#checking-content-existence">Checking Content Existence</a></h3>
<p>To check if content exists in the store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::exists(store_id.clone(), content_ref) {
    Ok(exists) =&gt; {
        if exists {
            println!("Content exists in the store");
        } else {
            println!("Content does not exist in the store");
        }
    },
    Err(error) =&gt; {
        println!("Failed to check content existence: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="label-operations"><a class="header" href="#label-operations">Label Operations</a></h2>
<p>Labels provide a way to assign human-readable names to content references, making it easier to retrieve them later.</p>
<h3 id="creating-labels"><a class="header" href="#creating-labels">Creating Labels</a></h3>
<p>To create a label for content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::label(store_id.clone(), "important-data", content_ref) {
    Ok(_) =&gt; {
        println!("Label 'important-data' created successfully");
    },
    Err(error) =&gt; {
        println!("Failed to create label: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-content-by-label"><a class="header" href="#getting-content-by-label">Getting Content by Label</a></h3>
<p>To retrieve content reference using a label:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::get_by_label(store_id.clone(), "important-data") {
    Ok(content_ref_opt) =&gt; {
        if let Some(content_ref) = content_ref_opt {
            // Use the content reference to get the actual content
            let content = store::get(store_id.clone(), content_ref)?;
            println!("Retrieved content for label 'important-data'");
        } else {
            println!("Label 'important-data' does not exist");
        }
    },
    Err(error) =&gt; {
        println!("Failed to get content by label: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="storing-and-labeling-in-one-operation"><a class="header" href="#storing-and-labeling-in-one-operation">Storing and Labeling in One Operation</a></h3>
<p>To store content and create a label in one operation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = b"New data".to_vec();

match store::store_at_label(store_id.clone(), "new-data", data) {
    Ok(content_ref) =&gt; {
        println!("Content stored and labeled as 'new-data'");
    },
    Err(error) =&gt; {
        println!("Failed to store and label content: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="replacing-content-at-a-label"><a class="header" href="#replacing-content-at-a-label">Replacing Content at a Label</a></h3>
<p>To replace the content referenced by a label:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let updated_data = b"Updated data".to_vec();

match store::replace_content_at_label(store_id.clone(), "new-data", updated_data) {
    Ok(content_ref) =&gt; {
        println!("Content at label 'new-data' updated successfully");
    },
    Err(error) =&gt; {
        println!("Failed to update content: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="replacing-a-content-reference-at-a-label"><a class="header" href="#replacing-a-content-reference-at-a-label">Replacing a Content Reference at a Label</a></h3>
<p>To replace the content reference at a label with another existing reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::replace_at_label(store_id.clone(), "new-data", existing_content_ref) {
    Ok(_) =&gt; {
        println!("Content reference at label 'new-data' replaced successfully");
    },
    Err(error) =&gt; {
        println!("Failed to replace content reference: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="listing-labels"><a class="header" href="#listing-labels">Listing Labels</a></h3>
<p>To get a list of all labels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::list_labels(store_id.clone()) {
    Ok(labels) =&gt; {
        println!("Available labels:");
        for label in labels {
            println!("- {}", label);
        }
    },
    Err(error) =&gt; {
        println!("Failed to list labels: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-labels"><a class="header" href="#removing-labels">Removing Labels</a></h3>
<p>To remove a label:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::remove_label(store_id.clone(), "temporary-data") {
    Ok(_) =&gt; {
        println!("Label 'temporary-data' removed successfully");
    },
    Err(error) =&gt; {
        println!("Failed to remove label: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="store-management"><a class="header" href="#store-management">Store Management</a></h2>
<h3 id="calculating-total-size"><a class="header" href="#calculating-total-size">Calculating Total Size</a></h3>
<p>To calculate the total size of all stored content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::calculate_total_size(store_id.clone()) {
    Ok(size) =&gt; {
        println!("Total storage size: {} bytes", size);
    },
    Err(error) =&gt; {
        println!("Failed to calculate storage size: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="listing-all-content"><a class="header" href="#listing-all-content">Listing All Content</a></h3>
<p>To list all content references in the store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match store::list_all_content(store_id.clone()) {
    Ok(refs) =&gt; {
        println!("Total content items: {}", refs.len());
        for content_ref in refs {
            println!("- {}", content_ref.hash);
        }
    },
    Err(error) =&gt; {
        println!("Failed to list content: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="label-naming-conventions"><a class="header" href="#label-naming-conventions">Label Naming Conventions</a></h2>
<p>While you can use any string as a label, it's good practice to follow certain conventions:</p>
<ol>
<li>
<p><strong>Actor-Specific Labels</strong>: Prefix labels with the actor ID or name</p>
<pre><code>actor:12345:config
</code></pre>
</li>
<li>
<p><strong>Versioned Labels</strong>: Include version information in labels</p>
<pre><code>config:v1.0
</code></pre>
</li>
<li>
<p><strong>Type Labels</strong>: Include content type in the label</p>
<pre><code>image:logo
</code></pre>
</li>
<li>
<p><strong>Namespaced Labels</strong>: Use namespaces for organization</p>
<pre><code>app:settings:theme
</code></pre>
</li>
</ol>
<h2 id="state-chain-integration-4"><a class="header" href="#state-chain-integration-4">State Chain Integration</a></h2>
<p>Store operations are recorded in the actor's state chain, ensuring a verifiable history of all storage interactions. The chain events include:</p>
<h3 id="call-events"><a class="header" href="#call-events">Call Events</a></h3>
<ul>
<li><code>NewStoreCall</code></li>
<li><code>StoreCall</code></li>
<li><code>GetCall</code></li>
<li><code>ExistsCall</code></li>
<li><code>LabelCall</code></li>
<li><code>GetByLabelCall</code></li>
<li><code>StoreAtLabelCall</code></li>
<li><code>ReplaceContentAtLabelCall</code></li>
<li><code>ReplaceAtLabelCall</code></li>
<li><code>RemoveLabelCall</code></li>
<li><code>ListLabelsCall</code></li>
<li><code>ListAllContentCall</code></li>
<li><code>CalculateTotalSizeCall</code></li>
</ul>
<h3 id="result-events"><a class="header" href="#result-events">Result Events</a></h3>
<ul>
<li><code>NewStoreResult</code></li>
<li><code>StoreResult</code></li>
<li><code>GetResult</code></li>
<li><code>ExistsResult</code></li>
<li><code>LabelResult</code></li>
<li><code>GetByLabelResult</code></li>
<li><code>StoreAtLabelResult</code></li>
<li><code>ReplaceContentAtLabelResult</code></li>
<li><code>ReplaceAtLabelResult</code></li>
<li><code>RemoveLabelResult</code></li>
<li><code>ListLabelsResult</code></li>
<li><code>ListAllContentResult</code></li>
<li><code>CalculateTotalSizeResult</code></li>
</ul>
<h3 id="error-events"><a class="header" href="#error-events">Error Events</a></h3>
<ul>
<li><code>Error</code> (includes operation type and error message)</li>
</ul>
<p>Each event includes detailed information such as store ID, content references, labels, and success/failure status.</p>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<p>The Store Handler provides detailed error information for various failure scenarios:</p>
<ol>
<li><strong>Storage Errors</strong>: When content storage fails</li>
<li><strong>Retrieval Errors</strong>: When content retrieval fails</li>
<li><strong>Label Errors</strong>: When label operations fail</li>
<li><strong>Not Found Errors</strong>: When content or labels don't exist</li>
<li><strong>IO Errors</strong>: When disk operations fail</li>
</ol>
<h2 id="security-considerations-5"><a class="header" href="#security-considerations-5">Security Considerations</a></h2>
<p>When using the Store Handler, consider the following security aspects:</p>
<ol>
<li><strong>Content Validation</strong>: Validate data before storing it</li>
<li><strong>Label Namespaces</strong>: Use namespaced labels to avoid conflicts</li>
<li><strong>Size Limits</strong>: Be mindful of storage size and implement limits</li>
<li><strong>Sensitive Data</strong>: Consider encrypting sensitive data before storage</li>
<li><strong>Cleanup</strong>: Implement policies for removing unused content</li>
</ol>
<h2 id="implementation-details-6"><a class="header" href="#implementation-details-6">Implementation Details</a></h2>
<p>Under the hood, the Store Handler:</p>
<ol>
<li>Uses SHA-1 hashing to create unique content identifiers</li>
<li>Stores content in a directory structure organized by store ID</li>
<li>Maintains separate directories for content and label mappings</li>
<li>Records detailed events for all operations</li>
<li>Ensures data integrity through content verification</li>
</ol>
<h2 id="storage-structure"><a class="header" href="#storage-structure">Storage Structure</a></h2>
<p>The physical storage is organized as follows:</p>
<pre><code>store/
├── &lt;store-uuid1&gt;/         # Store instance 1
│   ├── data/             # Content files stored by hash
│   │   ├── &lt;hash1&gt;
│   │   ├── &lt;hash2&gt;
│   │   └── ...
│   └── labels/           # Labels pointing to content hashes
│       ├── &lt;label1&gt;
│       ├── &lt;label2&gt;
│       └── ...
├── &lt;store-uuid2&gt;/         # Store instance 2
...
└── manifest/             # System metadata
</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ol>
<li><strong>Store Management</strong>: Create separate stores for different use cases</li>
<li><strong>Content Size</strong>: The store is optimized for small to medium content sizes (&lt; 10MB)</li>
<li><strong>Reference Tracking</strong>: Keep track of content references for important data</li>
<li><strong>Label Schemes</strong>: Develop consistent label naming schemes</li>
<li><strong>Cleanup</strong>: Implement periodic cleanup for unused content</li>
<li><strong>Error Handling</strong>: Always handle store operation errors appropriately</li>
<li><strong>Caching</strong>: Consider implementing local caching for frequently accessed content</li>
</ol>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="configuration-storage"><a class="header" href="#configuration-storage">Configuration Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store configuration
fn save_config(store_id: &amp;str, config: &amp;Config) -&gt; Result&lt;(), String&gt; {
    let config_bytes = serde_json::to_vec(config)
        .map_err(|e| format!("Failed to serialize config: {}", e))?;
    
    store::store_at_label(store_id.to_string(), "app:config", config_bytes)
        .map(|_| ())
        .map_err(|e| format!("Failed to store config: {}", e))
}

// Load configuration
fn load_config(store_id: &amp;str) -&gt; Result&lt;Config, String&gt; {
    let content_ref_opt = store::get_by_label(store_id.to_string(), "app:config")
        .map_err(|e| format!("Failed to get config reference: {}", e))?;
    
    if let Some(content_ref) = content_ref_opt {
        let config_bytes = store::get(store_id.to_string(), content_ref)
            .map_err(|e| format!("Failed to retrieve config: {}", e))?;
        
        let config: Config = serde_json::from_slice(&amp;config_bytes)
            .map_err(|e| format!("Failed to deserialize config: {}", e))?;
        
        Ok(config)
    } else {
        Err("Configuration not found".to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="content-deduplication"><a class="header" href="#content-deduplication">Content Deduplication</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn store_with_deduplication(store_id: &amp;str, data: Vec&lt;u8&gt;) -&gt; Result&lt;ContentRef, String&gt; {
    // Generate a hash to check if the content already exists
    use sha1::{Sha1, Digest};
    let mut hasher = Sha1::new();
    hasher.update(&amp;data);
    let hash = format!("{:x}", hasher.finalize());
    
    // Create a content reference to check existence
    let content_ref = ContentRef { hash };
    
    // Check if the content already exists
    if store::exists(store_id.to_string(), content_ref.clone())? {
        println!("Content already exists in store, reusing existing reference");
        return Ok(content_ref);
    }
    
    // Content doesn't exist, store it
    store::store(store_id.to_string(), data)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="versioned-content"><a class="header" href="#versioned-content">Versioned Content</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn store_versioned_content(store_id: &amp;str, name: &amp;str, version: &amp;str, data: Vec&lt;u8&gt;) -&gt; Result&lt;(), String&gt; {
    // Store the content
    let content_ref = store::store(store_id.to_string(), data)?;
    
    // Create a versioned label
    let versioned_label = format!("{}:v{}", name, version);
    store::label(store_id.to_string(), versioned_label, content_ref.clone())?;
    
    // Always update the 'latest' label
    let latest_label = format!("{}:latest", name);
    store::label(store_id.to_string(), latest_label, content_ref)?;
    
    Ok(())
}

fn get_content_version(store_id: &amp;str, name: &amp;str, version: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
    let label = format!("{}:v{}", name, version);
    let content_ref_opt = store::get_by_label(store_id.to_string(), label)?;
    
    if let Some(content_ref) = content_ref_opt {
        store::get(store_id.to_string(), content_ref)
    } else {
        Err(format!("Version {} not found", version))
    }
}

fn get_latest_content(store_id: &amp;str, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
    let label = format!("{}:latest", name);
    let content_ref_opt = store::get_by_label(store_id.to_string(), label)?;
    
    if let Some(content_ref) = content_ref_opt {
        store::get(store_id.to_string(), content_ref)
    } else {
        Err(format!("No versions available for {}", name))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics-5"><a class="header" href="#related-topics-5">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/filesystem.html">Filesystem Handler</a> - Alternative file access mechanism</li>
<li><a href="services/handlers/../core-concepts/state-management.html">State Management</a> - For understanding state chain integration</li>
<li><a href="services/handlers/../core-concepts/store/README.html">Store System</a> - For deeper store concepts</li>
<li><a href="services/handlers/../core-concepts/store/actor-api.html">Store API for Actors</a> - For actor-specific store usage</li>
<li><a href="services/handlers/../core-concepts/store/usage-patterns.html">Store Usage Patterns</a> - For common usage patterns and examples</li>
</ul>
<h2 id="event-types-reference"><a class="header" href="#event-types-reference">Event Types Reference</a></h2>
<p>The Store Handler tracks detailed events for all operations. Here's a complete reference of the event types:</p>
<h3 id="call-events-1"><a class="header" href="#call-events-1">Call Events</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event Type</th><th>Description</th><th>Parameters</th></tr></thead><tbody>
<tr><td><code>NewStoreCall</code></td><td>Called when creating a new store</td><td>None</td></tr>
<tr><td><code>StoreCall</code></td><td>Called when storing content</td><td><code>store_id</code>, <code>content</code></td></tr>
<tr><td><code>GetCall</code></td><td>Called when retrieving content</td><td><code>store_id</code>, <code>content_ref</code></td></tr>
<tr><td><code>ExistsCall</code></td><td>Called when checking if content exists</td><td><code>store_id</code>, <code>content_ref</code></td></tr>
<tr><td><code>LabelCall</code></td><td>Called when labeling content</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code></td></tr>
<tr><td><code>GetByLabelCall</code></td><td>Called when getting content by label</td><td><code>store_id</code>, <code>label</code></td></tr>
<tr><td><code>StoreAtLabelCall</code></td><td>Called when storing and labeling content</td><td><code>store_id</code>, <code>label</code>, <code>content</code></td></tr>
<tr><td><code>ReplaceContentAtLabelCall</code></td><td>Called when replacing content at a label</td><td><code>store_id</code>, <code>label</code>, <code>content</code></td></tr>
<tr><td><code>ReplaceAtLabelCall</code></td><td>Called when replacing a reference at a label</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code></td></tr>
<tr><td><code>RemoveLabelCall</code></td><td>Called when removing a label</td><td><code>store_id</code>, <code>label</code></td></tr>
<tr><td><code>ListLabelsCall</code></td><td>Called when listing all labels</td><td><code>store_id</code></td></tr>
<tr><td><code>ListAllContentCall</code></td><td>Called when listing all content</td><td><code>store_id</code></td></tr>
<tr><td><code>CalculateTotalSizeCall</code></td><td>Called when calculating total size</td><td><code>store_id</code></td></tr>
</tbody></table>
</div>
<h3 id="result-events-1"><a class="header" href="#result-events-1">Result Events</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event Type</th><th>Description</th><th>Parameters</th></tr></thead><tbody>
<tr><td><code>NewStoreResult</code></td><td>Result of creating a new store</td><td><code>store_id</code>, <code>success</code></td></tr>
<tr><td><code>StoreResult</code></td><td>Result of storing content</td><td><code>store_id</code>, <code>content_ref</code>, <code>success</code></td></tr>
<tr><td><code>GetResult</code></td><td>Result of retrieving content</td><td><code>store_id</code>, <code>content_ref</code>, <code>content</code>, <code>success</code></td></tr>
<tr><td><code>ExistsResult</code></td><td>Result of checking if content exists</td><td><code>store_id</code>, <code>content_ref</code>, <code>exists</code>, <code>success</code></td></tr>
<tr><td><code>LabelResult</code></td><td>Result of labeling content</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code>, <code>success</code></td></tr>
<tr><td><code>GetByLabelResult</code></td><td>Result of getting content by label</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code>, <code>success</code></td></tr>
<tr><td><code>StoreAtLabelResult</code></td><td>Result of storing and labeling content</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code>, <code>success</code></td></tr>
<tr><td><code>ReplaceContentAtLabelResult</code></td><td>Result of replacing content at a label</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code>, <code>success</code></td></tr>
<tr><td><code>ReplaceAtLabelResult</code></td><td>Result of replacing a reference at a label</td><td><code>store_id</code>, <code>label</code>, <code>content_ref</code>, <code>success</code></td></tr>
<tr><td><code>RemoveLabelResult</code></td><td>Result of removing a label</td><td><code>store_id</code>, <code>label</code>, <code>success</code></td></tr>
<tr><td><code>ListLabelsResult</code></td><td>Result of listing all labels</td><td><code>store_id</code>, <code>labels</code>, <code>success</code></td></tr>
<tr><td><code>ListAllContentResult</code></td><td>Result of listing all content</td><td><code>store_id</code>, <code>content_refs</code>, <code>success</code></td></tr>
<tr><td><code>CalculateTotalSizeResult</code></td><td>Result of calculating total size</td><td><code>store_id</code>, <code>size</code>, <code>success</code></td></tr>
</tbody></table>
</div>
<h3 id="error-events-1"><a class="header" href="#error-events-1">Error Events</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event Type</th><th>Description</th><th>Parameters</th></tr></thead><tbody>
<tr><td><code>Error</code></td><td>Records an error with any operation</td><td><code>operation</code>, <code>message</code></td></tr>
</tbody></table>
</div>
<p>Each event includes a timestamp and optional description field in addition to the operation-specific parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-handler-1"><a class="header" href="#runtime-handler-1">Runtime Handler</a></h1>
<p>The Runtime Handler provides actors with information about and control over their runtime environment in Theater. It enables actors to access runtime metadata, manage their lifecycle, and interact with the Theater runtime system.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>The Runtime Handler implements the <code>theater:simple/runtime</code> interface, providing actors with the ability to:</p>
<ol>
<li>Access information about themselves and the runtime</li>
<li>Control their lifecycle</li>
<li>Get system and environment information</li>
<li>Record custom metrics and events</li>
<li>Manage runtime resources</li>
</ol>
<h2 id="configuration-6"><a class="header" href="#configuration-6">Configuration</a></h2>
<p>To use the Runtime Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "runtime"
config = {}
</code></pre>
<p>The Runtime Handler doesn't currently require any specific configuration parameters.</p>
<h2 id="interface-5"><a class="header" href="#interface-5">Interface</a></h2>
<p>The Runtime Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface runtime {
    // Get the actor's unique ID
    get-actor-id: func() -&gt; string;
    
    // Get the actor's name
    get-actor-name: func() -&gt; string;
    
    // Get current timestamp (milliseconds since epoch)
    get-current-time: func() -&gt; u64;
    
    // Get environment variable value
    get-env: func(name: string) -&gt; option&lt;string&gt;;
    
    // Log a message with specified level
    log: func(level: string, message: string) -&gt; result&lt;_, string&gt;;
    
    // Record a custom metric
    record-metric: func(name: string, value: float64) -&gt; result&lt;_, string&gt;;
    
    // Record a custom event
    record-event: func(event-type: string, data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;
    
    // Get theater version
    get-theater-version: func() -&gt; string;
    
    // Get system information
    get-system-info: func() -&gt; system-info;
    
    // Runtime statistics and information
    record system-info {
        hostname: string,
        os-type: string,
        os-release: string,
        cpu-count: u32,
        memory-total: u64,
        memory-available: u64,
        uptime: u64,
    }
}
</code></pre>
<h2 id="runtime-information"><a class="header" href="#runtime-information">Runtime Information</a></h2>
<h3 id="getting-actor-information"><a class="header" href="#getting-actor-information">Getting Actor Information</a></h3>
<p>To get the actor's ID and name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let actor_id = runtime::get_actor_id();
let actor_name = runtime::get_actor_name();

println!("Actor ID: {}", actor_id);
println!("Actor name: {}", actor_name);
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-current-time"><a class="header" href="#getting-current-time">Getting Current Time</a></h3>
<p>To get the current time (milliseconds since epoch):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let now = runtime::get_current_time();
println!("Current time: {} ms", now);
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-theater-version"><a class="header" href="#getting-theater-version">Getting Theater Version</a></h3>
<p>To get the current Theater runtime version:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let version = runtime::get_theater_version();
println!("Theater version: {}", version);
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-system-information"><a class="header" href="#getting-system-information">Getting System Information</a></h3>
<p>To get information about the system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let system_info = runtime::get_system_info();

println!("System Information:");
println!("Hostname: {}", system_info.hostname);
println!("OS Type: {}", system_info.os_type);
println!("OS Release: {}", system_info.os_release);
println!("CPU Count: {}", system_info.cpu_count);
println!("Total Memory: {} bytes", system_info.memory_total);
println!("Available Memory: {} bytes", system_info.memory_available);
println!("System Uptime: {} seconds", system_info.uptime);
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-environment-variables"><a class="header" href="#getting-environment-variables">Getting Environment Variables</a></h3>
<p>To access environment variables:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(log_level) = runtime::get_env("LOG_LEVEL") {
    println!("Log level from environment: {}", log_level);
} else {
    println!("LOG_LEVEL environment variable not set");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="logging-and-events"><a class="header" href="#logging-and-events">Logging and Events</a></h2>
<h3 id="logging-messages"><a class="header" href="#logging-messages">Logging Messages</a></h3>
<p>To log messages at different levels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Log with different levels
runtime::log("debug", "This is a debug message").unwrap();
runtime::log("info", "This is an info message").unwrap();
runtime::log("warn", "This is a warning message").unwrap();
runtime::log("error", "This is an error message").unwrap();
<span class="boring">}</span></code></pre></pre>
<h3 id="recording-custom-metrics"><a class="header" href="#recording-custom-metrics">Recording Custom Metrics</a></h3>
<p>To record custom metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Record a performance metric
runtime::record_metric("request_duration_ms", 42.5).unwrap();

// Record a counter
runtime::record_metric("requests_processed", 1.0).unwrap();

// Record memory usage
runtime::record_metric("memory_usage_bytes", 1024.0 * 1024.0).unwrap();
<span class="boring">}</span></code></pre></pre>
<h3 id="recording-custom-events"><a class="header" href="#recording-custom-events">Recording Custom Events</a></h3>
<p>To record custom events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Record a simple event
let event_data = b"User logged in".to_vec();
runtime::record_event("user_login", event_data).unwrap();

// Record a structured event
let complex_event = serde_json::json!({
    "action": "item_purchase",
    "user_id": "user123",
    "item_id": "item456",
    "amount": 29.99,
    "currency": "USD"
});
let event_bytes = serde_json::to_vec(&amp;complex_event).unwrap();
runtime::record_event("purchase", event_bytes).unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="state-chain-integration-5"><a class="header" href="#state-chain-integration-5">State Chain Integration</a></h2>
<p>All runtime operations are recorded in the actor's state chain, creating a verifiable history. The chain events include:</p>
<ol>
<li><strong>RuntimeOperation</strong>: Records runtime operations like environment variable access or system info requests</li>
<li><strong>CustomEvent</strong>: Records user-defined events with their data</li>
<li><strong>LogEvent</strong>: Records log messages with their level</li>
<li><strong>MetricEvent</strong>: Records custom metrics with their values</li>
</ol>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<p>The Runtime Handler provides error information for various failure scenarios:</p>
<ol>
<li><strong>Log Errors</strong>: When logging fails</li>
<li><strong>Metric Errors</strong>: When metric recording fails</li>
<li><strong>Event Errors</strong>: When custom event recording fails</li>
<li><strong>Environment Errors</strong>: When environment variable access fails</li>
</ol>
<h2 id="security-considerations-6"><a class="header" href="#security-considerations-6">Security Considerations</a></h2>
<p>When using the Runtime Handler, consider the following security aspects:</p>
<ol>
<li><strong>Environment Variables</strong>: Be careful with sensitive environment variables</li>
<li><strong>Logging</strong>: Don't log sensitive data like passwords or tokens</li>
<li><strong>Metrics</strong>: Avoid using personally identifiable information in metric names</li>
<li><strong>Custom Events</strong>: Be mindful of the data included in custom events</li>
<li><strong>System Information</strong>: Consider what system information is exposed to actors</li>
</ol>
<h2 id="implementation-details-7"><a class="header" href="#implementation-details-7">Implementation Details</a></h2>
<p>Under the hood, the Runtime Handler:</p>
<ol>
<li>Provides a bridge between WebAssembly actors and the host runtime</li>
<li>Translates WIT interface calls to host runtime operations</li>
<li>Records all operations in the state chain</li>
<li>Manages access to system resources and information</li>
<li>Interacts with the logging and metrics subsystems</li>
</ol>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="application-monitoring"><a class="header" href="#application-monitoring">Application Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Record application health metrics periodically
fn record_health_metrics() -&gt; Result&lt;(), String&gt; {
    // Get system information
    let system_info = runtime::get_system_info();
    
    // Record memory metrics
    let memory_used = system_info.memory_total - system_info.memory_available;
    runtime::record_metric("memory_used_bytes", memory_used as f64)?;
    
    // Record memory percentage
    let memory_percentage = (memory_used as f64 / system_info.memory_total as f64) * 100.0;
    runtime::record_metric("memory_usage_percent", memory_percentage)?;
    
    // Record CPU metrics (application-specific)
    let cpu_usage = calculate_cpu_usage();
    runtime::record_metric("cpu_usage_percent", cpu_usage)?;
    
    // Log status
    runtime::log("info", &amp;format!("Health metrics recorded: Memory {}%, CPU {}%", 
                                memory_percentage, cpu_usage))?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Structured logging helper
fn log_structured(level: &amp;str, message: &amp;str, context: &amp;serde_json::Value) -&gt; Result&lt;(), String&gt; {
    let log_entry = serde_json::json!({
        "message": message,
        "timestamp": runtime::get_current_time(),
        "actor": {
            "id": runtime::get_actor_id(),
            "name": runtime::get_actor_name(),
        },
        "context": context
    });
    
    let log_message = serde_json::to_string(&amp;log_entry)
        .map_err(|e| format!("Failed to serialize log: {}", e))?;
    
    runtime::log(level, &amp;log_message)
}

// Usage
fn process_request(request: &amp;Request) -&gt; Result&lt;Response, String&gt; {
    // Log request received
    log_structured("info", "Request received", &amp;serde_json::json!({
        "request_id": request.id,
        "client_ip": request.client_ip,
        "method": request.method,
        "path": request.path
    }))?;
    
    // Process request
    let start_time = runtime::get_current_time();
    let result = handle_request(request);
    let duration = runtime::get_current_time() - start_time;
    
    // Record processing time
    runtime::record_metric("request_duration_ms", duration as f64)?;
    
    // Log result
    match &amp;result {
        Ok(response) =&gt; {
            log_structured("info", "Request completed", &amp;serde_json::json!({
                "request_id": request.id,
                "status": response.status,
                "duration_ms": duration
            }))?;
        },
        Err(error) =&gt; {
            log_structured("error", "Request failed", &amp;serde_json::json!({
                "request_id": request.id,
                "error": error,
                "duration_ms": duration
            }))?;
        }
    }
    
    result
}
<span class="boring">}</span></code></pre></pre>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if a feature is enabled via environment variables
fn is_feature_enabled(feature_name: &amp;str) -&gt; bool {
    let env_var_name = format!("FEATURE_{}", feature_name.to_uppercase());
    
    match runtime::get_env(&amp;env_var_name) {
        Some(value) =&gt; {
            match value.to_lowercase().as_str() {
                "true" | "yes" | "1" =&gt; true,
                _ =&gt; false,
            }
        },
        None =&gt; false,
    }
}

// Usage
fn process_request(request: &amp;Request) -&gt; Response {
    if is_feature_enabled("new_ui") {
        // Use new UI processing
        process_with_new_ui(request)
    } else {
        // Use old UI processing
        process_with_old_ui(request)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<ol>
<li><strong>Consistent Logging</strong>: Use consistent log levels and formats</li>
<li><strong>Meaningful Metrics</strong>: Design metrics that provide actionable insights</li>
<li><strong>Error Handling</strong>: Always handle errors from runtime functions</li>
<li><strong>Resource Usage</strong>: Be mindful of resource usage in metrics collection</li>
<li><strong>Security</strong>: Never log sensitive information</li>
</ol>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<ol>
<li><strong>Logging Overhead</strong>: Excessive logging can impact performance</li>
<li><strong>Metric Cardinality</strong>: Too many unique metric names can cause issues</li>
<li><strong>Event Size</strong>: Large event payloads may impact performance</li>
<li><strong>System Info Calls</strong>: Frequent system info calls may have overhead</li>
</ol>
<h2 id="related-topics-6"><a class="header" href="#related-topics-6">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/message-server.html">Message Server Handler</a> - For actor-to-actor communication</li>
<li><a href="services/handlers/supervisor.html">Supervisor Handler</a> - For parent-child actor relationships</li>
<li><a href="services/handlers/timing.html">Timing Handler</a> - For timing and scheduling operations</li>
<li><a href="services/handlers/../core-concepts/state-management.html">State Management</a> - For state chain integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timing-handler-1"><a class="header" href="#timing-handler-1">Timing Handler</a></h1>
<p>The Timing Handler provides actors with time-related capabilities, including delays, periodic scheduling, and timeout management. It enables actors to control the timing of their operations while maintaining Theater's state verification model.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>The Timing Handler implements the <code>theater:simple/timing</code> interface, enabling actors to:</p>
<ol>
<li>Introduce controlled delays in their execution</li>
<li>Implement timeout patterns for operations</li>
<li>Enforce rate limits and throttling</li>
<li>Create periodic tasks and scheduled operations</li>
</ol>
<h2 id="configuration-7"><a class="header" href="#configuration-7">Configuration</a></h2>
<p>To use the Timing Handler, add it to your actor's manifest:</p>
<pre><code class="language-toml">[[handlers]]
type = "timing"
config = { 
    max_sleep_duration = 3600000,  # Maximum sleep duration in milliseconds (1 hour)
    min_sleep_duration = 1         # Minimum sleep duration in milliseconds
}
</code></pre>
<p>Configuration options:</p>
<ul>
<li><code>max_sleep_duration</code>: (Optional) Maximum allowed sleep duration in milliseconds, defaults to 3600000 (1 hour)</li>
<li><code>min_sleep_duration</code>: (Optional) Minimum allowed sleep duration in milliseconds, defaults to 1</li>
</ul>
<h2 id="interface-6"><a class="header" href="#interface-6">Interface</a></h2>
<p>The Timing Handler is defined using the following WIT interface:</p>
<pre><code class="language-wit">interface timing {
    // Sleep for the specified duration (in milliseconds)
    sleep: func(duration-ms: u64) -&gt; result&lt;_, string&gt;;
    
    // Get current timestamp (milliseconds since epoch)
    now: func() -&gt; u64;
    
    // Get high-resolution time for performance measurement (in nanoseconds)
    performance-now: func() -&gt; u64;
}
</code></pre>
<h2 id="basic-timing-operations"><a class="header" href="#basic-timing-operations">Basic Timing Operations</a></h2>
<h3 id="sleep"><a class="header" href="#sleep">Sleep</a></h3>
<p>The <code>sleep</code> function pauses actor execution for a specified duration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sleep for 1 second
match timing::sleep(1000) {
    Ok(_) =&gt; {
        println!("Resumed after 1 second");
    },
    Err(error) =&gt; {
        println!("Sleep operation failed: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the sleep duration must fall within the configured <code>min_sleep_duration</code> and <code>max_sleep_duration</code> range. Attempting to sleep for longer than the maximum or shorter than the minimum will result in an error.</p>
<h3 id="current-time"><a class="header" href="#current-time">Current Time</a></h3>
<p>The <code>now</code> function returns the current time in milliseconds since the Unix epoch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let current_time = timing::now();
println!("Current time: {} ms", current_time);
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-timing"><a class="header" href="#performance-timing">Performance Timing</a></h3>
<p>The <code>performance-now</code> function provides high-resolution timing for performance measurement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Measure operation duration
let start = timing::performance_now();

// Perform operation
perform_expensive_operation();

let end = timing::performance_now();
let duration_ns = end - start;
let duration_ms = duration_ns / 1_000_000;

println!("Operation took {} ms", duration_ms);
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="implementing-timeouts"><a class="header" href="#implementing-timeouts">Implementing Timeouts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Perform an operation with a timeout
fn perform_with_timeout&lt;F, T&gt;(operation: F, timeout_ms: u64) -&gt; Result&lt;T, String&gt;
where
    F: FnOnce() -&gt; Result&lt;T, String&gt;,
{
    // Create a oneshot channel for the result
    let (tx, rx) = tokio::sync::oneshot::channel();
    
    // Spawn a task to perform the operation
    tokio::spawn(async move {
        match operation() {
            Ok(result) =&gt; {
                let _ = tx.send(Ok(result));
            },
            Err(err) =&gt; {
                let _ = tx.send(Err(err));
            }
        }
    });
    
    // Wait for the result or timeout
    match tokio::time::timeout(std::time::Duration::from_millis(timeout_ms), rx).await {
        Ok(result) =&gt; result.unwrap(),
        Err(_) =&gt; Err("Operation timed out".to_string()),
    }
}

// Usage
let result = perform_with_timeout(|| {
    // Perform potentially long-running operation
    perform_api_call()
}, 5000); // 5 second timeout
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple rate limiter
struct RateLimiter {
    last_operation: u64,
    min_interval_ms: u64,
}

impl RateLimiter {
    fn new(min_interval_ms: u64) -&gt; Self {
        Self {
            last_operation: 0,
            min_interval_ms,
        }
    }
    
    fn check_and_update(&amp;mut self) -&gt; Result&lt;(), String&gt; {
        let now = timing::now();
        let elapsed = now - self.last_operation;
        
        if self.last_operation == 0 || elapsed &gt;= self.min_interval_ms {
            self.last_operation = now;
            Ok(())
        } else {
            let wait_time = self.min_interval_ms - elapsed;
            timing::sleep(wait_time)?;
            self.last_operation = timing::now();
            Ok(())
        }
    }
}

// Usage
let mut rate_limiter = RateLimiter::new(100); // 100ms between operations

for item in items {
    // Ensure we don't exceed rate limit
    rate_limiter.check_and_update()?;
    
    // Process item
    process_item(item)?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="periodic-tasks"><a class="header" href="#periodic-tasks">Periodic Tasks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Run a task periodically
fn run_periodically&lt;F&gt;(task: F, interval_ms: u64, max_iterations: Option&lt;usize&gt;) -&gt; Result&lt;(), String&gt;
where
    F: Fn() -&gt; Result&lt;(), String&gt;,
{
    let mut iterations = 0;
    
    loop {
        // Run the task
        task()?;
        
        // Check if we've reached the maximum iterations
        if let Some(max) = max_iterations {
            iterations += 1;
            if iterations &gt;= max {
                break;
            }
        }
        
        // Sleep until the next interval
        timing::sleep(interval_ms)?;
    }
    
    Ok(())
}

// Usage
run_periodically(|| {
    // Periodic task logic
    collect_metrics()
}, 5000, Some(10))?; // Run every 5 seconds, 10 times
<span class="boring">}</span></code></pre></pre>
<h2 id="state-chain-integration-6"><a class="header" href="#state-chain-integration-6">State Chain Integration</a></h2>
<p>All timing operations are recorded in the actor's state chain, creating a verifiable history. The chain events include:</p>
<ol>
<li>
<p><strong>TimingOperation</strong>: Records details of timing operations:</p>
<ul>
<li>Operation type (sleep, now, performance-now)</li>
<li>Duration (for sleep operations)</li>
<li>Timestamp</li>
</ul>
</li>
<li>
<p><strong>Error</strong>: Records any errors that occur:</p>
<ul>
<li>Operation type</li>
<li>Error message</li>
</ul>
</li>
</ol>
<p>This integration ensures that all timing activities are:</p>
<ul>
<li>Traceable</li>
<li>Verifiable</li>
<li>Reproducible</li>
<li>Auditable</li>
</ul>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<p>The Timing Handler provides error information for various failure scenarios:</p>
<ol>
<li><strong>Duration Errors</strong>: When sleep duration is outside allowed range</li>
<li><strong>Operation Errors</strong>: When timing operations fail</li>
<li><strong>Resource Errors</strong>: When system resources are unavailable</li>
</ol>
<h2 id="security-considerations-7"><a class="header" href="#security-considerations-7">Security Considerations</a></h2>
<p>When using the Timing Handler, consider the following security aspects:</p>
<ol>
<li><strong>Sleep Limits</strong>: The configuration enforces limits on sleep durations</li>
<li><strong>Resource Consumption</strong>: Long or frequent sleeps may impact system resources</li>
<li><strong>Timing Attacks</strong>: Be aware of potential timing side-channel attacks</li>
</ol>
<h2 id="implementation-details-8"><a class="header" href="#implementation-details-8">Implementation Details</a></h2>
<p>Under the hood, the Timing Handler:</p>
<ol>
<li>Uses the Tokio runtime for asynchronous sleep operations</li>
<li>Enforces configurable minimum and maximum sleep durations</li>
<li>Records all operations in the state chain</li>
<li>Provides consistent time sources across the actor system</li>
</ol>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<ol>
<li><strong>Sleep Overhead</strong>: There is a small overhead for each sleep operation</li>
<li><strong>Time Resolution</strong>: Time functions have platform-dependent resolution</li>
<li><strong>Resource Usage</strong>: Excessive sleep operations may impact system performance</li>
</ol>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<ol>
<li><strong>Error Handling</strong>: Always handle errors from timing functions</li>
<li><strong>Sleep Duration</strong>: Use reasonable sleep durations</li>
<li><strong>Batch Processing</strong>: Consider batching operations instead of sleeping between each</li>
<li><strong>Timeouts</strong>: Implement timeouts for operations that may not complete</li>
<li><strong>Rate Limiting</strong>: Use rate limiting for external API calls</li>
</ol>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="retry-logic"><a class="header" href="#retry-logic">Retry Logic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Retry an operation with exponential backoff
fn retry_with_backoff&lt;F, T&gt;(
    operation: F,
    initial_backoff_ms: u64,
    max_backoff_ms: u64,
    max_retries: usize
) -&gt; Result&lt;T, String&gt;
where
    F: Fn() -&gt; Result&lt;T, String&gt;,
{
    let mut backoff = initial_backoff_ms;
    let mut attempts = 0;
    
    loop {
        match operation() {
            Ok(result) =&gt; return Ok(result),
            Err(error) =&gt; {
                attempts += 1;
                
                if attempts &gt;= max_retries {
                    return Err(format!("Operation failed after {} attempts: {}", attempts, error));
                }
                
                // Log the failure and retry plan
                println!("Attempt {} failed: {}. Retrying in {} ms", attempts, error, backoff);
                
                // Wait before next attempt
                timing::sleep(backoff)?;
                
                // Exponential backoff with jitter
                let jitter = (backoff as f64 * 0.1 * rand::random::&lt;f64&gt;()) as u64;
                backoff = std::cmp::min(backoff * 2 + jitter, max_backoff_ms);
            }
        }
    }
}

// Usage
let result = retry_with_backoff(
    || external_api_call("https://api.example.com/data"),
    100,    // Initial backoff of 100ms
    30000,  // Maximum backoff of 30 seconds
    5       // Maximum 5 retry attempts
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="debouncing"><a class="header" href="#debouncing">Debouncing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debounce a function call
struct Debouncer {
    last_call: u64,
    timeout_ms: u64,
}

impl Debouncer {
    fn new(timeout_ms: u64) -&gt; Self {
        Self {
            last_call: 0,
            timeout_ms,
        }
    }
    
    fn should_call(&amp;mut self) -&gt; bool {
        let now = timing::now();
        
        if now - self.last_call &gt;= self.timeout_ms {
            self.last_call = now;
            true
        } else {
            false
        }
    }
}

// Usage
let mut input_debouncer = Debouncer::new(500); // 500ms debounce

fn process_input(input: &amp;str) {
    if input_debouncer.should_call() {
        // Process the input
        println!("Processing input: {}", input);
    } else {
        // Skip processing this input
        println!("Debounced input: {}", input);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="measuring-request-latency"><a class="header" href="#measuring-request-latency">Measuring Request Latency</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Measure and log request latency
fn measure_request_latency&lt;F, T&gt;(operation_name: &amp;str, operation: F) -&gt; Result&lt;T, String&gt;
where
    F: FnOnce() -&gt; Result&lt;T, String&gt;,
{
    // Get start time in high resolution
    let start = timing::performance_now();
    
    // Perform the operation
    let result = operation()?;
    
    // Calculate duration
    let end = timing::performance_now();
    let duration_ns = end - start;
    let duration_ms = duration_ns / 1_000_000;
    
    // Log the latency
    println!("{} took {} ms", operation_name, duration_ms);
    
    // Record metric
    runtime::record_metric(&amp;format!("{}_latency_ms", operation_name), duration_ms as f64)?;
    
    // Return the result
    Ok(result)
}

// Usage
let user_data = measure_request_latency("fetch_user_data", || {
    api_client::get_user_data(user_id)
})?;
<span class="boring">}</span></code></pre></pre>
<h2 id="related-topics-7"><a class="header" href="#related-topics-7">Related Topics</a></h2>
<ul>
<li><a href="services/handlers/runtime.html">Runtime Handler</a> - For runtime information and operations</li>
<li><a href="services/handlers/message-server.html">Message Server Handler</a> - For actor-to-actor communication</li>
<li><a href="services/handlers/../core-concepts/state-management.html">State Management</a> - For state chain integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theater-api-documentation"><a class="header" href="#theater-api-documentation">Theater API Documentation</a></h1>
<p>This page provides an overview of the Theater API. For detailed reference documentation, you can check out the <a href="api-reference//theater/api/theater/index.html">auto-generated rustdoc API Reference</a>.</p>
<div class="api-note">
<p><strong>Note:</strong> The rustdoc API Reference provides detailed information about all types, functions, and modules directly from the code annotations.</p>
</div>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<p>Theater uses WebAssembly components to create isolated, deterministic actors that communicate through a message-passing interface. Each actor is a WebAssembly component that implements specific interfaces defined using the WebAssembly Interface Type (WIT) system.</p>
<h2 id="key-api-components"><a class="header" href="#key-api-components">Key API Components</a></h2>
<p>Here are some key components in the API:</p>
<ul>
<li><a href="api-reference//theater/api/theater/actor_runtime/struct.ActorRuntime.html">ActorRuntime</a> - Manages the lifecycle of an actor</li>
<li><a href="api-reference//theater/api/theater/actor_executor/struct.ActorExecutor.html">ActorExecutor</a> - Executes actor code in WebAssembly</li>
<li><a href="api-reference//theater/api/theater/chain/struct.StateChain.html">StateChain</a> - Maintains the verifiable chain of state changes</li>
<li><a href="api-reference//theater/api/theater/id/struct.TheaterId.html">TheaterId</a> - Unique identifier for actors</li>
<li><a href="api-reference//theater/api/theater/store/struct.ContentStore.html">ContentStore</a> - Content-addressable storage system</li>
</ul>
<h2 id="core-actor-interface"><a class="header" href="#core-actor-interface">Core Actor Interface</a></h2>
<p>Every Theater actor must implement the core actor interface:</p>
<pre><code class="language-wit">// theater:simple/actor interface
package theater:simple

interface types {
    /// JSON-encoded data
    type json = list&lt;u8&gt;
    
    /// Event structure for actor messages
    record event {
        event-type: string,
        parent: option&lt;u64&gt;,
        data: json
    }
}

interface actor {
    use types.{json, event}

    /// Initialize actor state
    init: func() -&gt; json

    /// Handle an incoming event, returning new state
    handle: func(evt: event, state: json) -&gt; json
}
</code></pre>
<h3 id="implementation-example"><a class="header" href="#implementation-example">Implementation Example</a></h3>
<p>Here's how to implement the core actor interface in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bindings::exports::ntwk::theater::actor::Guest as ActorGuest;
use bindings::ntwk::theater::types::{Event, Json};
use serde::{Deserialize, Serialize};

// Define your actor's state
#[derive(Serialize, Deserialize)]
struct State {
    count: i32,
    last_updated: String,
}

struct Component;

impl ActorGuest for Component {
    // Initialize actor state
    fn init() -&gt; Vec&lt;u8&gt; {
        let initial_state = State {
            count: 0,
            last_updated: chrono::Utc::now().to_string(),
        };
        
        serde_json::to_vec(&amp;initial_state).unwrap()
    }

    // Handle incoming messages
    fn handle(evt: Event, state: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
        let mut current_state: State = serde_json::from_slice(&amp;state).unwrap();
        
        // Process the event
        if let Ok(message) = serde_json::from_slice(&amp;evt.data) {
            // Update state based on message...
        }
        
        serde_json::to_vec(&amp;current_state).unwrap()
    }
}

bindings::export!(Component with_types_in bindings);
<span class="boring">}</span></code></pre></pre>
<h2 id="available-host-functions"><a class="header" href="#available-host-functions">Available Host Functions</a></h2>
<p>Theater provides several host functions that actors can use. For complete details, see the <a href="api-reference//theater/api/theater/host/index.html">host module documentation</a>.</p>
<h3 id="runtime-interface"><a class="header" href="#runtime-interface">Runtime Interface</a></h3>
<pre><code class="language-wit">// theater:simple/runtime interface
interface runtime {
    /// Log a message to the host system
    log: func(msg: string)

    /// Spawn a new actor from a manifest
    spawn: func(manifest: string)

    /// Get the current event chain
    get-chain: func() -&gt; chain
}
</code></pre>
<h3 id="http-server-interface"><a class="header" href="#http-server-interface">HTTP Server Interface</a></h3>
<pre><code class="language-wit">// theater:simple/http-server interface
interface http-server {
    record http-request {
        method: string,
        path: string,
        headers: list&lt;tuple&lt;string, string&gt;&gt;,
        body: option&lt;list&lt;u8&gt;&gt;
    }

    record http-response {
        status: u16,
        headers: list&lt;tuple&lt;string, string&gt;&gt;,
        body: option&lt;list&lt;u8&gt;&gt;
    }

    handle-request: func(req: http-request, state: json) -&gt; tuple&lt;http-response, json&gt;
}
</code></pre>
<p>The <a href="api-reference//theater/api/theater/host/framework/struct.HttpFramework.html">HttpFramework</a> provides the implementation of this interface.</p>
<h3 id="websocket-server-interface"><a class="header" href="#websocket-server-interface">WebSocket Server Interface</a></h3>
<pre><code class="language-wit">// theater:simple/websocket-server interface
interface websocket-server {
    use types.{json}

    /// Types of WebSocket messages
    enum message-type {
        text,
        binary,
        connect,
        close,
        ping,
        pong,
        other(string)
    }

    /// WebSocket message structure
    record websocket-message {
        ty: message-type,
        data: option&lt;list&lt;u8&gt;&gt;,
        text: option&lt;string&gt;
    }

    /// WebSocket response structure
    record websocket-response {
        messages: list&lt;websocket-message&gt;
    }

    /// Handle an incoming WebSocket message
    handle-message: func(msg: websocket-message, state: json) -&gt; tuple&lt;json, websocket-response&gt;
}
</code></pre>
<h2 id="handler-implementation-examples"><a class="header" href="#handler-implementation-examples">Handler Implementation Examples</a></h2>
<h3 id="http-server-handler"><a class="header" href="#http-server-handler">HTTP Server Handler</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bindings::exports::ntwk::theater::http_server::Guest as HttpGuest;
use bindings::ntwk::theater::types::Json;
use bindings::ntwk::theater::http_server::{HttpRequest, HttpResponse};

impl HttpGuest for Component {
    fn handle_request(req: HttpRequest, state: Json) -&gt; (HttpResponse, Json) {
        match (req.method.as_str(), req.path.as_str()) {
            ("GET", "/count") =&gt; {
                let current_state: State = serde_json::from_slice(&amp;state).unwrap();
                
                (HttpResponse {
                    status: 200,
                    headers: vec![
                        ("Content-Type".to_string(), "application/json".to_string())
                    ],
                    body: Some(serde_json::json!({
                        "count": current_state.count
                    }).to_string().into_bytes()),
                }, state)
            },
            _ =&gt; (HttpResponse {
                status: 404,
                headers: vec![],
                body: None,
            }, state)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For more details on HTTP handling, see the <a href="api-reference//theater/api/theater/host/http_client/struct.HttpClientHost.html">HTTP Client documentation</a>.</p>
<h3 id="websocket-server-handler"><a class="header" href="#websocket-server-handler">WebSocket Server Handler</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bindings::exports::ntwk::theater::websocket_server::Guest as WebSocketGuest;
use bindings::ntwk::theater::types::Json;
use bindings::ntwk::theater::websocket_server::{
    WebSocketMessage,
    WebSocketResponse,
    MessageType
};

impl WebSocketGuest for Component {
    fn handle_message(msg: WebSocketMessage, state: Json) -&gt; (Json, WebSocketResponse) {
        let mut current_state: State = serde_json::from_slice(&amp;state).unwrap();
        
        let response = match msg.ty {
            MessageType::Text =&gt; {
                if let Some(text) = msg.text {
                    // Process text message...
                    WebSocketResponse {
                        messages: vec![WebSocketMessage {
                            ty: MessageType::Text,
                            text: Some("Message received".to_string()),
                            data: None,
                        }]
                    }
                } else {
                    WebSocketResponse { messages: vec![] }
                }
            },
            _ =&gt; WebSocketResponse { messages: vec![] }
        };
        
        (serde_json::to_vec(&amp;current_state).unwrap(), response)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-configuration"><a class="header" href="#actor-configuration">Actor Configuration</a></h2>
<p>Actors are configured using TOML manifests. See the <a href="api-reference//theater/api/theater/config/struct.ManifestConfig.html">ManifestConfig</a> for details on the configuration options.</p>
<pre><code class="language-toml">name = "example-actor"
component_path = "target/wasm32-wasi/release/example_actor.wasm"

[interface]
implements = "theater:simple/websocket-server"
requires = []

[[handlers]]
type = "websocket-server"
config = { port = 8080 }

[logging]
level = "debug"
</code></pre>
<h2 id="hash-chain-integration"><a class="header" href="#hash-chain-integration">Hash Chain Integration</a></h2>
<p>Theater uses a hash chain to track state transitions. See the <a href="api-reference//theater/api/theater/chain/struct.StateChain.html">StateChain</a> for more details.</p>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<ol>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Use serde for state serialization</li>
<li>Keep state JSON-serializable</li>
<li>Include timestamps in state</li>
<li>Handle serialization errors</li>
</ul>
</li>
<li>
<p><strong>Message Handling</strong></p>
<ul>
<li>Validate message format</li>
<li>Handle all message types</li>
<li>Return consistent responses</li>
<li>Preserve state on errors</li>
</ul>
</li>
<li>
<p><strong>Handler Implementation</strong></p>
<ul>
<li>Implement appropriate interfaces</li>
<li>Handle all request types</li>
<li>Return proper responses</li>
<li>Maintain state consistency</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Log errors with context</li>
<li>Return unchanged state on error</li>
<li>Validate all inputs</li>
<li>Handle all error cases</li>
</ul>
</li>
</ol>
<h2 id="development-tips-1"><a class="header" href="#development-tips-1">Development Tips</a></h2>
<ol>
<li>Use the chat-room example as a reference implementation</li>
<li>Test with multiple handler types</li>
<li>Monitor the hash chain during development</li>
<li>Use logging for debugging</li>
<li>Validate state transitions</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
