
{
	"max_tokens":8192,
	"messages":[
		{"content":[{"text":"Hello!","type":"text"}],"role":"user"},
		{"content":[{"text":"Hello! How can I assist you today?","type":"text"}],"role":"assistant"},
		{"content":[{"text":"You have access to filesystem tools to help implement changes. These tools allow you to create, read, write, and manage files and directories.\n\nYou have been given the following change request:\nPrint 'Hello Fun World!' when handling a request\n\n-------------------\n\nEnsure you read the source file located at src/lib.rs before making any changes. This project is compiled to a WebAssembly component, so the structure is a bit unique. This project does not use the wit-bindgen! macro, but instead generates bindings with cargo component build, so if you would like to look at the bindings available to the actor you can check out the src/bindings.rs file, or the wit/ directory, especially wit/world.wit.\n\nTake your time! There is no rush to complete this task. Do not jump into writing code, instead explore the directory, see what's going on, and then think about making changes!\n\nOnce you have read the existing files, considered the possibilities of changes, and implemented the changes, please respond with the <TASK_COMPLETE> token to indicate that the task has been finished and the project can be built.\n            ","type":"text"}],"role":"user"},
		{"content":[{"text":"I'll help you implement this change request. Let's start by exploring the project structure to get a better understanding of what we're working with.","type":"text"},{"id":"toolu_01JHkMt4VVUXE9G8YxS45pS5","input":{"path":"."},"name":"list_files","type":"tool_use"}],"role":"assistant"},
		{"content":[{"content":"Contents of './.': \n [FILE] Cargo.lock\n [FILE] .gitignore\n [FILE] flake.nix\n [FILE] manifest.toml\n [DIR] src\n [FILE] flake.lock\n [DIR] wit\n [FILE] README.md\n [FILE] Cargo.toml","tool_use_id":"toolu_01JHkMt4VVUXE9G8YxS45pS5","type":"tool_result"}],"role":"user"},
		{"content":[{"text":"Good, I can see the main project structure. Let's examine the src directory contents and check out the main source file:","type":"text"},{"id":"toolu_01VW71hS8aqCxvsyB211xkPB","input":{"path":"src"},"name":"list_files","type":"tool_use"}],"role":"assistant"},
		{"content":[{"content":"Contents of './src': \n [FILE] bindings.rs\n [FILE] lib.rs","tool_use_id":"toolu_01VW71hS8aqCxvsyB211xkPB","type":"tool_result"}],"role":"user"},{"content":[{"text":"Let's first read the primary source file, lib.rs:","type":"text"},{"id":"toolu_01HzpqVNDRsCzJvpAbonmXAn","input":{"path":"src/lib.rs"},"name":"read_file","type":"tool_use"}],"role":"assistant"},
		{"content":[{"content":"Contents of './src/lib.rs': mod bindings;\n\nuse crate::bindings::exports::ntwk::theater::actor::Guest;\nuse crate::bindings::exports::ntwk::theater::http_handlers::Guest as HttpHandlers;\nuse crate::bindings::exports::ntwk::theater::message_server_client::Guest as MessageServerClient;\nuse crate::bindings::ntwk::theater::http_framework::{\n    add_middleware, add_route, create_server, enable_websocket, register_handler, start_server,\n    ServerConfig,\n};\nuse crate::bindings::ntwk::theater::http_types::{HttpRequest, HttpResponse, MiddlewareResult};\nuse crate::bindings::ntwk::theater::runtime::log;\nuse crate::bindings::ntwk::theater::types::State;\nuse crate::bindings::ntwk::theater::websocket_types::{MessageType, WebsocketMessage};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize)]\nstruct AppState {}\n\nimpl Default for AppState {\n    fn default() -> Self {\n        Self {}\n    }\n}\n\nstruct Actor;\nimpl Guest for Actor {\n    fn init(_state: State, params: (String,)) -> Result<(State,), String> {\n        log(\"Initializing HTTP Actor\");\n        let (param,) = params;\n        log(&format!(\"Init parameter: {}\", param));\n\n        let app_state = AppState::default();\n        log(\"Created default app state\");\n        let state_bytes = serde_json::to_vec(&app_state).map_err(|e| e.to_string())?;\n\n        // Create the initial state\n        let new_state = Some(state_bytes);\n\n        // Set up the HTTP server\n        log(\"Setting up HTTP server...\");\n        setup_http_server().map_err(|e| e.to_string())?;\n        log(\"HTTP server set up successfully\");\n\n        Ok((new_state,))\n    }\n}\n\n// Setup the HTTP server and return the server ID\nfn setup_http_server() -> Result<u64, String> {\n    log(\"Setting up HTTP server\");\n\n    // Create server configuration\n    let config = ServerConfig {\n        port: Some(8080),\n        host: Some(\"0.0.0.0\".to_string()),\n        tls_config: None,\n    };\n\n    // Create a new HTTP server\n    let server_id = create_server(&config)?;\n    log(&format!(\"Created server with ID: {}\", server_id));\n\n    // Register handlers\n    let handler_id = register_handler(\"handle_api\")?;\n\n    log(&format!(\"Registered handlers - API: {}\", handler_id));\n\n    // Add routes\n    add_route(server_id, \"/\", \"GET\", handler_id)?;\n\n    // Start the server\n    let port = start_server(server_id)?;\n    log(&format!(\"Server started on port {}\", port));\n\n    Ok(server_id)\n}\n\nimpl HttpHandlers for Actor {\n    // HTTP Request Handler\n    fn handle_request(\n        state: State,\n        params: (u64, HttpRequest),\n    ) -> Result<(State, (HttpResponse,)), String> {\n        let (handler_id, request) = params;\n        log(&format!(\n            \"Handling HTTP request with handler ID: {}\",\n            handler_id\n        ));\n        log(&format!(\n            \"  Method: {}, Path: {}\",\n            request.method, request.uri\n        ));\n\n        // Parse the current state\n        let state_bytes = state.unwrap_or_default();\n        let mut app_state: AppState = if !state_bytes.is_empty() {\n            log(\"Deserializing existing state\");\n            let app_state: AppState =\n                serde_json::from_slice(&state_bytes).map_err(|e| e.to_string())?;\n            log(&format!(\n                \"App state: {}\",\n                serde_json::to_string_pretty(&app_state).unwrap()\n            ));\n            app_state\n        } else {\n            log(\"Creating default state\");\n            AppState::default()\n        };\n\n        // Process the request based on the path and method\n        log(&format!(\n            \"Processing request: {} {}\",\n            request.method, request.uri\n        ));\n        let response = match (request.uri.as_str(), request.method.as_str()) {\n            (\"/\", \"GET\") => {\n                log(\"Handling GET /\");\n\n                let data = \"Hello World\";\n                let body = data.as_bytes().to_vec();\n\n                HttpResponse {\n                    status: 200,\n                    headers: vec![(\"content-type\".to_string(), \"application/json\".to_string())],\n                    body: Some(body),\n                }\n            }\n            _ => {\n                // Path not found\n                log(&format!(\n                    \"Error: Path not found - {} {}\",\n                    request.method, request.uri\n                ));\n                let data = serde_json::json!({\n                    \"success\": false,\n                    \"error\": \"Not found\"\n                });\n                let body = serde_json::to_vec(&data).map_err(|e| e.to_string())?;\n\n                HttpResponse {\n                    status: 404,\n                    headers: vec![(\"content-type\".to_string(), \"application/json\".to_string())],\n                    body: Some(body),\n                }\n            }\n        };\n\n        log(&format!(\"Response: {:?}\", response));\n        let updated_state_bytes = serde_json::to_vec(&app_state).map_err(|e| e.to_string())?;\n        let updated_state = Some(updated_state_bytes);\n\n        Ok((updated_state, (response,)))\n    }\n\n    // Middleware Handler\n    fn handle_middleware(\n        state: State,\n        params: (u64, HttpRequest),\n    ) -> Result<(State, (MiddlewareResult,)), String> {\n        let (handler_id, request) = params;\n        log(&format!(\n            \"Handling middleware with handler ID: {}\",\n            handler_id\n        ));\n        Ok((\n            state,\n            (MiddlewareResult {\n                proceed: true,\n                request,\n            },),\n        ))\n    }\n\n    // WebSocket Connect Handler\n    fn handle_websocket_connect(\n        state: State,\n        params: (u64, u64, String, Option<String>),\n    ) -> Result<(State,), String> {\n        let (handler_id, connection_id, path, _query) = params;\n        log(&format!(\n            \"WebSocket connected - Handler: {}, Connection: {}, Path: {}\",\n            handler_id, connection_id, path\n        ));\n\n        Ok((state,))\n    }\n\n    // WebSocket Message Handler\n    fn handle_websocket_message(\n        state: State,\n        params: (u64, u64, WebsocketMessage),\n    ) -> Result<(State, (Vec<WebsocketMessage>,)), String> {\n        let (handler_id, connection_id, message) = params;\n        log(&format!(\n            \"WebSocket message received - Handler: {}, Connection: {}\",\n            handler_id, connection_id\n        ));\n\n        // Parse the current state\n        let state_bytes = state.unwrap_or_default();\n        let app_state: AppState = if !state_bytes.is_empty() {\n            log(\"WebSocket: Deserializing existing state\");\n            let app_state: AppState =\n                serde_json::from_slice(&state_bytes).map_err(|e| e.to_string())?;\n            app_state\n        } else {\n            log(\"WebSocket: Creating default state\");\n            AppState::default()\n        };\n\n        let responses = match message.ty {\n            _ => {\n                // Other message types\n                log(\"  Other message type\");\n                vec![]\n            }\n        };\n\n        // Save the updated state\n        let updated_state_bytes = serde_json::to_vec(&app_state).map_err(|e| e.to_string())?;\n        let updated_state = Some(updated_state_bytes);\n\n        Ok((updated_state, (responses,)))\n    }\n\n    // WebSocket Disconnect Handler\n    fn handle_websocket_disconnect(state: State, params: (u64, u64)) -> Result<(State,), String> {\n        let (handler_id, connection_id) = params;\n        log(&format!(\n            \"WebSocket disconnected - Handler: {}, Connection: {}\",\n            handler_id, connection_id\n        ));\n\n        Ok((state,))\n    }\n}\n\nimpl MessageServerClient for Actor {\n    fn handle_send(\n        state: Option<Vec<u8>>,\n        _params: (Vec<u8>,),\n    ) -> Result<(Option<Vec<u8>>,), String> {\n        Ok((state,))\n    }\n\n    fn handle_request(\n        state: Option<Vec<u8>>,\n        _params: (Vec<u8>,),\n    ) -> Result<(Option<Vec<u8>>, (Vec<u8>,)), String> {\n        Ok((state, (vec![],)))\n    }\n}\n\nbindings::export!(Actor with_types_in bindings);\n","tool_use_id":"toolu_01HzpqVNDRsCzJvpAbonmXAn","type":"tool_result"}],"role":"user"},{"content":[{"text":"Now let's also look at the bindings.rs file:","type":"text"},{"id":"toolu_01Xtd7P2E6fMNBXoshEqx7x7","input":{"path":"src/bindings.rs"},"name":"read_file","type":"tool_use"}],"role":"assistant"},{"content":[{"content":"Contents of './src/bindings.rs': // Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!\n// Options used:\n//   * runtime_path: \"wit_bindgen_rt\"\n#[rustfmt::skip]\n#[allow(dead_code, clippy::all)]\npub mod ntwk {\n    pub mod theater {\n        /// Define a shared type for messages\n        #[allow(dead_code, clippy::all)]\n        pub mod types {\n            #[used]\n            #[doc(hidden)]\n            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;\n            use super::super::super::_rt;\n            /// Generic message type as bytes that can be serialized/deserialized\n            pub type Json = _rt::Vec<u8>;\n            pub type State = Option<_rt::Vec<u8>>;\n            #[derive(Clone)]\n            pub struct Event {\n                pub event_type: _rt::String,\n                pub parent: Option<u64>,\n                pub data: Json,\n            }\n            impl ::core::fmt::Debug for Event {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"Event\")\n                        .field(\"event-type\", &self.event_type)\n                        .field(\"parent\", &self.parent)\n                        .field(\"data\", &self.data)\n                        .finish()\n                }\n            }\n            #[derive(Clone)]\n            pub struct MetaEvent {\n                pub hash: u64,\n                pub event: Event,\n            }\n            impl ::core::fmt::Debug for MetaEvent {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"MetaEvent\")\n                        .field(\"hash\", &self.hash)\n                        .field(\"event\", &self.event)\n                        .finish()\n                }\n            }\n            #[derive(Clone)]\n            pub struct Chain {\n                pub events: _rt::Vec<MetaEvent>,\n            }\n            impl ::core::fmt::Debug for Chain {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"Chain\").field(\"events\", &self.events).finish()\n                }\n            }\n        }\n        #[allow(dead_code, clippy::all)]\n        pub mod runtime {\n            #[used]\n            #[doc(hidden)]\n            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;\n            use super::super::super::_rt;\n            pub type Chain = super::super::super::ntwk::theater::types::Chain;\n            #[allow(unused_unsafe, clippy::all)]\n            pub fn log(msg: &str) {\n                unsafe {\n                    let vec0 = msg;\n                    let ptr0 = vec0.as_ptr().cast::<u8>();\n                    let len0 = vec0.len();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/runtime\")]\n                    extern \"C\" {\n                        #[link_name = \"log\"]\n                        fn wit_import(_: *mut u8, _: usize);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: *mut u8, _: usize) {\n                        unreachable!()\n                    }\n                    wit_import(ptr0.cast_mut(), len0);\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            pub fn get_chain() -> Chain {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/runtime\")]\n                    extern \"C\" {\n                        #[link_name = \"get-chain\"]\n                        fn wit_import(_: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(ptr0);\n                    let l1 = *ptr0.add(0).cast::<*mut u8>();\n                    let l2 = *ptr0.add(4).cast::<usize>();\n                    let base12 = l1;\n                    let len12 = l2;\n                    let mut result12 = _rt::Vec::with_capacity(len12);\n                    for i in 0..len12 {\n                        let base = base12.add(i * 40);\n                        let e12 = {\n                            let l3 = *base.add(0).cast::<i64>();\n                            let l4 = *base.add(8).cast::<*mut u8>();\n                            let l5 = *base.add(12).cast::<usize>();\n                            let len6 = l5;\n                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);\n                            let l7 = i32::from(*base.add(16).cast::<u8>());\n                            let l9 = *base.add(32).cast::<*mut u8>();\n                            let l10 = *base.add(36).cast::<usize>();\n                            let len11 = l10;\n                            super::super::super::ntwk::theater::types::MetaEvent {\n                                hash: l3 as u64,\n                                event: super::super::super::ntwk::theater::types::Event {\n                                    event_type: _rt::string_lift(bytes6),\n                                    parent: match l7 {\n                                        0 => None,\n                                        1 => {\n                                            let e = {\n                                                let l8 = *base.add(24).cast::<i64>();\n                                                l8 as u64\n                                            };\n                                            Some(e)\n                                        }\n                                        _ => _rt::invalid_enum_discriminant(),\n                                    },\n                                    data: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),\n                                },\n                            }\n                        };\n                        result12.push(e12);\n                    }\n                    _rt::cabi_dealloc(base12, len12 * 40, 8);\n                    super::super::super::ntwk::theater::types::Chain {\n                        events: result12,\n                    }\n                }\n            }\n        }\n        /// Types used by the HTTP framework\n        #[allow(dead_code, clippy::all)]\n        pub mod http_types {\n            #[used]\n            #[doc(hidden)]\n            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;\n            use super::super::super::_rt;\n            pub type Bytes = _rt::Vec<u8>;\n            #[derive(Clone)]\n            pub struct HttpRequest {\n                pub method: _rt::String,\n                pub uri: _rt::String,\n                pub headers: _rt::Vec<(_rt::String, _rt::String)>,\n                pub body: Option<Bytes>,\n            }\n            impl ::core::fmt::Debug for HttpRequest {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"HttpRequest\")\n                        .field(\"method\", &self.method)\n                        .field(\"uri\", &self.uri)\n                        .field(\"headers\", &self.headers)\n                        .field(\"body\", &self.body)\n                        .finish()\n                }\n            }\n            #[derive(Clone)]\n            pub struct HttpResponse {\n                pub status: u16,\n                pub headers: _rt::Vec<(_rt::String, _rt::String)>,\n                pub body: Option<Bytes>,\n            }\n            impl ::core::fmt::Debug for HttpResponse {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"HttpResponse\")\n                        .field(\"status\", &self.status)\n                        .field(\"headers\", &self.headers)\n                        .field(\"body\", &self.body)\n                        .finish()\n                }\n            }\n            /// TLS configuration\n            #[derive(Clone)]\n            pub struct TlsConfig {\n                /// Path to the certificate file\n                pub cert_path: _rt::String,\n                /// Path to the key file\n                pub key_path: _rt::String,\n            }\n            impl ::core::fmt::Debug for TlsConfig {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"TlsConfig\")\n                        .field(\"cert-path\", &self.cert_path)\n                        .field(\"key-path\", &self.key_path)\n                        .finish()\n                }\n            }\n            /// Configuration for an HTTP server\n            #[derive(Clone)]\n            pub struct ServerConfig {\n                /// Port to listen on, 0 means system-assigned\n                pub port: Option<u16>,\n                /// Host address to bind to\n                pub host: Option<_rt::String>,\n                /// TLS configuration\n                pub tls_config: Option<TlsConfig>,\n            }\n            impl ::core::fmt::Debug for ServerConfig {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"ServerConfig\")\n                        .field(\"port\", &self.port)\n                        .field(\"host\", &self.host)\n                        .field(\"tls-config\", &self.tls_config)\n                        .finish()\n                }\n            }\n            /// Information about a server\n            #[derive(Clone)]\n            pub struct ServerInfo {\n                /// Server ID\n                pub id: u64,\n                /// Current listening port\n                pub port: u16,\n                /// Host address\n                pub host: _rt::String,\n                /// Whether the server is running\n                pub running: bool,\n                /// Number of active routes\n                pub routes_count: u32,\n                /// Number of active middleware\n                pub middleware_count: u32,\n                /// Whether WebSocket is enabled\n                pub websocket_enabled: bool,\n            }\n            impl ::core::fmt::Debug for ServerInfo {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"ServerInfo\")\n                        .field(\"id\", &self.id)\n                        .field(\"port\", &self.port)\n                        .field(\"host\", &self.host)\n                        .field(\"running\", &self.running)\n                        .field(\"routes-count\", &self.routes_count)\n                        .field(\"middleware-count\", &self.middleware_count)\n                        .field(\"websocket-enabled\", &self.websocket_enabled)\n                        .finish()\n                }\n            }\n            /// Result from middleware processing\n            #[derive(Clone)]\n            pub struct MiddlewareResult {\n                /// Whether to continue processing the request\n                pub proceed: bool,\n                /// The modified request\n                pub request: HttpRequest,\n            }\n            impl ::core::fmt::Debug for MiddlewareResult {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"MiddlewareResult\")\n                        .field(\"proceed\", &self.proceed)\n                        .field(\"request\", &self.request)\n                        .finish()\n                }\n            }\n        }\n        /// Types used for WebSocket communication\n        #[allow(dead_code, clippy::all)]\n        pub mod websocket_types {\n            #[used]\n            #[doc(hidden)]\n            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;\n            use super::super::super::_rt;\n            /// The type of WebSocket message/event\n            #[derive(Clone)]\n            pub enum MessageType {\n                /// A text message\n                Text,\n                /// A binary message\n                Binary,\n                /// A new connection was established\n                Connect,\n                /// The connection was closed\n                Close,\n                /// A ping message (for keep-alive)\n                Ping,\n                /// A pong message (response to ping)\n                Pong,\n                /// Any other message type\n                Other(_rt::String),\n            }\n            impl ::core::fmt::Debug for MessageType {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    match self {\n                        MessageType::Text => f.debug_tuple(\"MessageType::Text\").finish(),\n                        MessageType::Binary => {\n                            f.debug_tuple(\"MessageType::Binary\").finish()\n                        }\n                        MessageType::Connect => {\n                            f.debug_tuple(\"MessageType::Connect\").finish()\n                        }\n                        MessageType::Close => {\n                            f.debug_tuple(\"MessageType::Close\").finish()\n                        }\n                        MessageType::Ping => f.debug_tuple(\"MessageType::Ping\").finish(),\n                        MessageType::Pong => f.debug_tuple(\"MessageType::Pong\").finish(),\n                        MessageType::Other(e) => {\n                            f.debug_tuple(\"MessageType::Other\").field(e).finish()\n                        }\n                    }\n                }\n            }\n            /// Represents a message sent or received over a WebSocket connection\n            #[derive(Clone)]\n            pub struct WebsocketMessage {\n                /// The type of the message\n                pub ty: MessageType,\n                /// Binary data payload (used for binary messages)\n                pub data: Option<_rt::Vec<u8>>,\n                /// Text payload (used for text messages)\n                pub text: Option<_rt::String>,\n            }\n            impl ::core::fmt::Debug for WebsocketMessage {\n                fn fmt(\n                    &self,\n                    f: &mut ::core::fmt::Formatter<'_>,\n                ) -> ::core::fmt::Result {\n                    f.debug_struct(\"WebsocketMessage\")\n                        .field(\"ty\", &self.ty)\n                        .field(\"data\", &self.data)\n                        .field(\"text\", &self.text)\n                        .finish()\n                }\n            }\n        }\n        /// The HTTP framework interface provides a comprehensive API for creating,\n        /// configuring, and managing HTTP and WebSocket servers from within WebAssembly actors.\n        #[allow(dead_code, clippy::all)]\n        pub mod http_framework {\n            #[used]\n            #[doc(hidden)]\n            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;\n            use super::super::super::_rt;\n            pub type ServerConfig = super::super::super::ntwk::theater::http_types::ServerConfig;\n            pub type ServerInfo = super::super::super::ntwk::theater::http_types::ServerInfo;\n            pub type WebsocketMessage = super::super::super::ntwk::theater::websocket_types::WebsocketMessage;\n            /// Core types\n            pub type ServerId = u64;\n            pub type HandlerId = u64;\n            pub type RouteId = u64;\n            pub type MiddlewareId = u64;\n            #[allow(unused_unsafe, clippy::all)]\n            /// Server lifecycle\n            /// Create a new HTTP server with the given configuration\n            pub fn create_server(\n                config: &ServerConfig,\n            ) -> Result<ServerId, _rt::String> {\n                unsafe {\n                    #[repr(align(8))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);\n                    let super::super::super::ntwk::theater::http_types::ServerConfig {\n                        port: port0,\n                        host: host0,\n                        tls_config: tls_config0,\n                    } = config;\n                    let (result1_0, result1_1) = match port0 {\n                        Some(e) => (1i32, _rt::as_i32(e)),\n                        None => (0i32, 0i32),\n                    };\n                    let (result3_0, result3_1, result3_2) = match host0 {\n                        Some(e) => {\n                            let vec2 = e;\n                            let ptr2 = vec2.as_ptr().cast::<u8>();\n                            let len2 = vec2.len();\n                            (1i32, ptr2.cast_mut(), len2)\n                        }\n                        None => (0i32, ::core::ptr::null_mut(), 0usize),\n                    };\n                    let (result7_0, result7_1, result7_2, result7_3, result7_4) = match tls_config0 {\n                        Some(e) => {\n                            let super::super::super::ntwk::theater::http_types::TlsConfig {\n                                cert_path: cert_path4,\n                                key_path: key_path4,\n                            } = e;\n                            let vec5 = cert_path4;\n                            let ptr5 = vec5.as_ptr().cast::<u8>();\n                            let len5 = vec5.len();\n                            let vec6 = key_path4;\n                            let ptr6 = vec6.as_ptr().cast::<u8>();\n                            let len6 = vec6.len();\n                            (1i32, ptr5.cast_mut(), len5, ptr6.cast_mut(), len6)\n                        }\n                        None => {\n                            (\n                                0i32,\n                                ::core::ptr::null_mut(),\n                                0usize,\n                                ::core::ptr::null_mut(),\n                                0usize,\n                            )\n                        }\n                    };\n                    let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"create-server\"]\n                        fn wit_import(\n                            _: i32,\n                            _: i32,\n                            _: i32,\n                            _: *mut u8,\n                            _: usize,\n                            _: i32,\n                            _: *mut u8,\n                            _: usize,\n                            _: *mut u8,\n                            _: usize,\n                            _: *mut u8,\n                        );\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(\n                        _: i32,\n                        _: i32,\n                        _: i32,\n                        _: *mut u8,\n                        _: usize,\n                        _: i32,\n                        _: *mut u8,\n                        _: usize,\n                        _: *mut u8,\n                        _: usize,\n                        _: *mut u8,\n                    ) {\n                        unreachable!()\n                    }\n                    wit_import(\n                        result1_0,\n                        result1_1,\n                        result3_0,\n                        result3_1,\n                        result3_2,\n                        result7_0,\n                        result7_1,\n                        result7_2,\n                        result7_3,\n                        result7_4,\n                        ptr8,\n                    );\n                    let l9 = i32::from(*ptr8.add(0).cast::<u8>());\n                    match l9 {\n                        0 => {\n                            let e = {\n                                let l10 = *ptr8.add(8).cast::<i64>();\n                                l10 as u64\n                            };\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l11 = *ptr8.add(8).cast::<*mut u8>();\n                                let l12 = *ptr8.add(12).cast::<usize>();\n                                let len13 = l12;\n                                let bytes13 = _rt::Vec::from_raw_parts(\n                                    l11.cast(),\n                                    len13,\n                                    len13,\n                                );\n                                _rt::string_lift(bytes13)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Get information about a server\n            pub fn get_server_info(\n                server_id: ServerId,\n            ) -> Result<ServerInfo, _rt::String> {\n                unsafe {\n                    #[repr(align(8))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 48]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 48]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"get-server-info\"]\n                        fn wit_import(_: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(server_id), ptr0);\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = {\n                                let l2 = *ptr0.add(8).cast::<i64>();\n                                let l3 = i32::from(*ptr0.add(16).cast::<u16>());\n                                let l4 = *ptr0.add(20).cast::<*mut u8>();\n                                let l5 = *ptr0.add(24).cast::<usize>();\n                                let len6 = l5;\n                                let bytes6 = _rt::Vec::from_raw_parts(\n                                    l4.cast(),\n                                    len6,\n                                    len6,\n                                );\n                                let l7 = i32::from(*ptr0.add(28).cast::<u8>());\n                                let l8 = *ptr0.add(32).cast::<i32>();\n                                let l9 = *ptr0.add(36).cast::<i32>();\n                                let l10 = i32::from(*ptr0.add(40).cast::<u8>());\n                                super::super::super::ntwk::theater::http_types::ServerInfo {\n                                    id: l2 as u64,\n                                    port: l3 as u16,\n                                    host: _rt::string_lift(bytes6),\n                                    running: _rt::bool_lift(l7 as u8),\n                                    routes_count: l8 as u32,\n                                    middleware_count: l9 as u32,\n                                    websocket_enabled: _rt::bool_lift(l10 as u8),\n                                }\n                            };\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l11 = *ptr0.add(8).cast::<*mut u8>();\n                                let l12 = *ptr0.add(12).cast::<usize>();\n                                let len13 = l12;\n                                let bytes13 = _rt::Vec::from_raw_parts(\n                                    l11.cast(),\n                                    len13,\n                                    len13,\n                                );\n                                _rt::string_lift(bytes13)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Start a server\n            pub fn start_server(server_id: ServerId) -> Result<u16, _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"start-server\"]\n                        fn wit_import(_: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(server_id), ptr0);\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = {\n                                let l2 = i32::from(*ptr0.add(4).cast::<u16>());\n                                l2 as u16\n                            };\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l3 = *ptr0.add(4).cast::<*mut u8>();\n                                let l4 = *ptr0.add(8).cast::<usize>();\n                                let len5 = l4;\n                                let bytes5 = _rt::Vec::from_raw_parts(\n                                    l3.cast(),\n                                    len5,\n                                    len5,\n                                );\n                                _rt::string_lift(bytes5)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Stop a server\n            pub fn stop_server(server_id: ServerId) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"stop-server\"]\n                        fn wit_import(_: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(server_id), ptr0);\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l2 = *ptr0.add(4).cast::<*mut u8>();\n                                let l3 = *ptr0.add(8).cast::<usize>();\n                                let len4 = l3;\n                                let bytes4 = _rt::Vec::from_raw_parts(\n                                    l2.cast(),\n                                    len4,\n                                    len4,\n                                );\n                                _rt::string_lift(bytes4)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Remove a server completely\n            pub fn destroy_server(server_id: ServerId) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"destroy-server\"]\n                        fn wit_import(_: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(server_id), ptr0);\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l2 = *ptr0.add(4).cast::<*mut u8>();\n                                let l3 = *ptr0.add(8).cast::<usize>();\n                                let len4 = l3;\n                                let bytes4 = _rt::Vec::from_raw_parts(\n                                    l2.cast(),\n                                    len4,\n                                    len4,\n                                );\n                                _rt::string_lift(bytes4)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Handler registration\n            /// Register a handler by name (the name is used to identify the handler function in the component)\n            pub fn register_handler(\n                handler_name: &str,\n            ) -> Result<HandlerId, _rt::String> {\n                unsafe {\n                    #[repr(align(8))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);\n                    let vec0 = handler_name;\n                    let ptr0 = vec0.as_ptr().cast::<u8>();\n                    let len0 = vec0.len();\n                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"register-handler\"]\n                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(ptr0.cast_mut(), len0, ptr1);\n                    let l2 = i32::from(*ptr1.add(0).cast::<u8>());\n                    match l2 {\n                        0 => {\n                            let e = {\n                                let l3 = *ptr1.add(8).cast::<i64>();\n                                l3 as u64\n                            };\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l4 = *ptr1.add(8).cast::<*mut u8>();\n                                let l5 = *ptr1.add(12).cast::<usize>();\n                                let len6 = l5;\n                                let bytes6 = _rt::Vec::from_raw_parts(\n                                    l4.cast(),\n                                    len6,\n                                    len6,\n                                );\n                                _rt::string_lift(bytes6)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Route management\n            /// Add a route to a server\n            pub fn add_route(\n                server_id: ServerId,\n                path: &str,\n                method: &str,\n                handler_id: HandlerId,\n            ) -> Result<RouteId, _rt::String> {\n                unsafe {\n                    #[repr(align(8))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);\n                    let vec0 = path;\n                    let ptr0 = vec0.as_ptr().cast::<u8>();\n                    let len0 = vec0.len();\n                    let vec1 = method;\n                    let ptr1 = vec1.as_ptr().cast::<u8>();\n                    let len1 = vec1.len();\n                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"add-route\"]\n                        fn wit_import(\n                            _: i64,\n                            _: *mut u8,\n                            _: usize,\n                            _: *mut u8,\n                            _: usize,\n                            _: i64,\n                            _: *mut u8,\n                        );\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(\n                        _: i64,\n                        _: *mut u8,\n                        _: usize,\n                        _: *mut u8,\n                        _: usize,\n                        _: i64,\n                        _: *mut u8,\n                    ) {\n                        unreachable!()\n                    }\n                    wit_import(\n                        _rt::as_i64(server_id),\n                        ptr0.cast_mut(),\n                        len0,\n                        ptr1.cast_mut(),\n                        len1,\n                        _rt::as_i64(handler_id),\n                        ptr2,\n                    );\n                    let l3 = i32::from(*ptr2.add(0).cast::<u8>());\n                    match l3 {\n                        0 => {\n                            let e = {\n                                let l4 = *ptr2.add(8).cast::<i64>();\n                                l4 as u64\n                            };\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l5 = *ptr2.add(8).cast::<*mut u8>();\n                                let l6 = *ptr2.add(12).cast::<usize>();\n                                let len7 = l6;\n                                let bytes7 = _rt::Vec::from_raw_parts(\n                                    l5.cast(),\n                                    len7,\n                                    len7,\n                                );\n                                _rt::string_lift(bytes7)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Remove a route\n            pub fn remove_route(route_id: RouteId) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"remove-route\"]\n                        fn wit_import(_: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(route_id), ptr0);\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l2 = *ptr0.add(4).cast::<*mut u8>();\n                                let l3 = *ptr0.add(8).cast::<usize>();\n                                let len4 = l3;\n                                let bytes4 = _rt::Vec::from_raw_parts(\n                                    l2.cast(),\n                                    len4,\n                                    len4,\n                                );\n                                _rt::string_lift(bytes4)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Middleware\n            /// Add middleware to a server path\n            pub fn add_middleware(\n                server_id: ServerId,\n                path: &str,\n                handler_id: HandlerId,\n            ) -> Result<MiddlewareId, _rt::String> {\n                unsafe {\n                    #[repr(align(8))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);\n                    let vec0 = path;\n                    let ptr0 = vec0.as_ptr().cast::<u8>();\n                    let len0 = vec0.len();\n                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"add-middleware\"]\n                        fn wit_import(_: i64, _: *mut u8, _: usize, _: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8, _: usize, _: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(\n                        _rt::as_i64(server_id),\n                        ptr0.cast_mut(),\n                        len0,\n                        _rt::as_i64(handler_id),\n                        ptr1,\n                    );\n                    let l2 = i32::from(*ptr1.add(0).cast::<u8>());\n                    match l2 {\n                        0 => {\n                            let e = {\n                                let l3 = *ptr1.add(8).cast::<i64>();\n                                l3 as u64\n                            };\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l4 = *ptr1.add(8).cast::<*mut u8>();\n                                let l5 = *ptr1.add(12).cast::<usize>();\n                                let len6 = l5;\n                                let bytes6 = _rt::Vec::from_raw_parts(\n                                    l4.cast(),\n                                    len6,\n                                    len6,\n                                );\n                                _rt::string_lift(bytes6)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Remove middleware\n            pub fn remove_middleware(\n                middleware_id: MiddlewareId,\n            ) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"remove-middleware\"]\n                        fn wit_import(_: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(middleware_id), ptr0);\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l2 = *ptr0.add(4).cast::<*mut u8>();\n                                let l3 = *ptr0.add(8).cast::<usize>();\n                                let len4 = l3;\n                                let bytes4 = _rt::Vec::from_raw_parts(\n                                    l2.cast(),\n                                    len4,\n                                    len4,\n                                );\n                                _rt::string_lift(bytes4)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// WebSocket support\n            /// Enable WebSocket support on a path\n            pub fn enable_websocket(\n                server_id: ServerId,\n                path: &str,\n                connect_handler_id: Option<HandlerId>,\n                message_handler_id: HandlerId,\n                disconnect_handler_id: Option<HandlerId>,\n            ) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let vec0 = path;\n                    let ptr0 = vec0.as_ptr().cast::<u8>();\n                    let len0 = vec0.len();\n                    let (result1_0, result1_1) = match connect_handler_id {\n                        Some(e) => (1i32, _rt::as_i64(e)),\n                        None => (0i32, 0i64),\n                    };\n                    let (result2_0, result2_1) = match disconnect_handler_id {\n                        Some(e) => (1i32, _rt::as_i64(e)),\n                        None => (0i32, 0i64),\n                    };\n                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"enable-websocket\"]\n                        fn wit_import(\n                            _: i64,\n                            _: *mut u8,\n                            _: usize,\n                            _: i32,\n                            _: i64,\n                            _: i64,\n                            _: i32,\n                            _: i64,\n                            _: *mut u8,\n                        );\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(\n                        _: i64,\n                        _: *mut u8,\n                        _: usize,\n                        _: i32,\n                        _: i64,\n                        _: i64,\n                        _: i32,\n                        _: i64,\n                        _: *mut u8,\n                    ) {\n                        unreachable!()\n                    }\n                    wit_import(\n                        _rt::as_i64(server_id),\n                        ptr0.cast_mut(),\n                        len0,\n                        result1_0,\n                        result1_1,\n                        _rt::as_i64(message_handler_id),\n                        result2_0,\n                        result2_1,\n                        ptr3,\n                    );\n                    let l4 = i32::from(*ptr3.add(0).cast::<u8>());\n                    match l4 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l5 = *ptr3.add(4).cast::<*mut u8>();\n                                let l6 = *ptr3.add(8).cast::<usize>();\n                                let len7 = l6;\n                                let bytes7 = _rt::Vec::from_raw_parts(\n                                    l5.cast(),\n                                    len7,\n                                    len7,\n                                );\n                                _rt::string_lift(bytes7)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Disable WebSocket support on a path\n            pub fn disable_websocket(\n                server_id: ServerId,\n                path: &str,\n            ) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let vec0 = path;\n                    let ptr0 = vec0.as_ptr().cast::<u8>();\n                    let len0 = vec0.len();\n                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"disable-websocket\"]\n                        fn wit_import(_: i64, _: *mut u8, _: usize, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: *mut u8, _: usize, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(_rt::as_i64(server_id), ptr0.cast_mut(), len0, ptr1);\n                    let l2 = i32::from(*ptr1.add(0).cast::<u8>());\n                    match l2 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l3 = *ptr1.add(4).cast::<*mut u8>();\n                                let l4 = *ptr1.add(8).cast::<usize>();\n                                let len5 = l4;\n                                let bytes5 = _rt::Vec::from_raw_parts(\n                                    l3.cast(),\n                                    len5,\n                                    len5,\n                                );\n                                _rt::string_lift(bytes5)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Send a message to a specific WebSocket connection\n            pub fn send_websocket_message(\n                server_id: ServerId,\n                connection_id: u64,\n                message: &WebsocketMessage,\n            ) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let super::super::super::ntwk::theater::websocket_types::WebsocketMessage {\n                        ty: ty0,\n                        data: data0,\n                        text: text0,\n                    } = message;\n                    use super::super::super::ntwk::theater::websocket_types::MessageType as V2;\n                    let (result3_0, result3_1, result3_2) = match ty0 {\n                        V2::Text => (0i32, ::core::ptr::null_mut(), 0usize),\n                        V2::Binary => (1i32, ::core::ptr::null_mut(), 0usize),\n                        V2::Connect => (2i32, ::core::ptr::null_mut(), 0usize),\n                        V2::Close => (3i32, ::core::ptr::null_mut(), 0usize),\n                        V2::Ping => (4i32, ::core::ptr::null_mut(), 0usize),\n                        V2::Pong => (5i32, ::core::ptr::null_mut(), 0usize),\n                        V2::Other(e) => {\n                            let vec1 = e;\n                            let ptr1 = vec1.as_ptr().cast::<u8>();\n                            let len1 = vec1.len();\n                            (6i32, ptr1.cast_mut(), len1)\n                        }\n                    };\n                    let (result5_0, result5_1, result5_2) = match data0 {\n                        Some(e) => {\n                            let vec4 = e;\n                            let ptr4 = vec4.as_ptr().cast::<u8>();\n                            let len4 = vec4.len();\n                            (1i32, ptr4.cast_mut(), len4)\n                        }\n                        None => (0i32, ::core::ptr::null_mut(), 0usize),\n                    };\n                    let (result7_0, result7_1, result7_2) = match text0 {\n                        Some(e) => {\n                            let vec6 = e;\n                            let ptr6 = vec6.as_ptr().cast::<u8>();\n                            let len6 = vec6.len();\n                            (1i32, ptr6.cast_mut(), len6)\n                        }\n                        None => (0i32, ::core::ptr::null_mut(), 0usize),\n                    };\n                    let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"send-websocket-message\"]\n                        fn wit_import(\n                            _: i64,\n                            _: i64,\n                            _: i32,\n                            _: *mut u8,\n                            _: usize,\n                            _: i32,\n                            _: *mut u8,\n                            _: usize,\n                            _: i32,\n                            _: *mut u8,\n                            _: usize,\n                            _: *mut u8,\n                        );\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(\n                        _: i64,\n                        _: i64,\n                        _: i32,\n                        _: *mut u8,\n                        _: usize,\n                        _: i32,\n                        _: *mut u8,\n                        _: usize,\n                        _: i32,\n                        _: *mut u8,\n                        _: usize,\n                        _: *mut u8,\n                    ) {\n                        unreachable!()\n                    }\n                    wit_import(\n                        _rt::as_i64(server_id),\n                        _rt::as_i64(&connection_id),\n                        result3_0,\n                        result3_1,\n                        result3_2,\n                        result5_0,\n                        result5_1,\n                        result5_2,\n                        result7_0,\n                        result7_1,\n                        result7_2,\n                        ptr8,\n                    );\n                    let l9 = i32::from(*ptr8.add(0).cast::<u8>());\n                    match l9 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l10 = *ptr8.add(4).cast::<*mut u8>();\n                                let l11 = *ptr8.add(8).cast::<usize>();\n                                let len12 = l11;\n                                let bytes12 = _rt::Vec::from_raw_parts(\n                                    l10.cast(),\n                                    len12,\n                                    len12,\n                                );\n                                _rt::string_lift(bytes12)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n            #[allow(unused_unsafe, clippy::all)]\n            /// Close a specific WebSocket connection\n            pub fn close_websocket(\n                server_id: ServerId,\n                connection_id: u64,\n            ) -> Result<(), _rt::String> {\n                unsafe {\n                    #[repr(align(4))]\n                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);\n                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);\n                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();\n                    #[cfg(target_arch = \"wasm32\")]\n                    #[link(wasm_import_module = \"ntwk:theater/http-framework\")]\n                    extern \"C\" {\n                        #[link_name = \"close-websocket\"]\n                        fn wit_import(_: i64, _: i64, _: *mut u8);\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    fn wit_import(_: i64, _: i64, _: *mut u8) {\n                        unreachable!()\n                    }\n                    wit_import(\n                        _rt::as_i64(server_id),\n                        _rt::as_i64(&connection_id),\n                        ptr0,\n                    );\n                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());\n                    match l1 {\n                        0 => {\n                            let e = ();\n                            Ok(e)\n                        }\n                        1 => {\n                            let e = {\n                                let l2 = *ptr0.add(4).cast::<*mut u8>();\n                                let l3 = *ptr0.add(8).cast::<usize>();\n                                let len4 = l3;\n                                let bytes4 = _rt::Vec::from_raw_parts(\n                                    l2.cast(),\n                                    len4,\n                                    len4,\n                                );\n                                _rt::string_lift(bytes4)\n                            };\n                            Err(e)\n                        }\n                        _ => _rt::invalid_enum_discriminant(),\n                    }\n                }\n            }\n        }\n    }\n}\n#[rustfmt::skip]\n#[allow(dead_code, clippy::all)]\npub mod exports {\n    pub mod ntwk {\n        pub mod theater {\n            #[allow(dead_code, clippy::all)]\n            pub mod message_server_client {\n                #[used]\n                #[doc(hidden)]\n                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;\n                use super::super::super::super::_rt;\n                pub type Json = super::super::super::super::ntwk::theater::types::Json;\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_send_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: *mut u8,\n                    arg4: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let len1 = arg4;\n                    let result2 = T::handle_send(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (_rt::Vec::from_raw_parts(arg3.cast(), len1, len1),),\n                    );\n                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result2 {\n                        Ok(e) => {\n                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t4_0,) = e;\n                            match t4_0 {\n                                Some(e) => {\n                                    *ptr3.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec5 = (e).into_boxed_slice();\n                                    let ptr5 = vec5.as_ptr().cast::<u8>();\n                                    let len5 = vec5.len();\n                                    ::core::mem::forget(vec5);\n                                    *ptr3.add(12).cast::<usize>() = len5;\n                                    *ptr3.add(8).cast::<*mut u8>() = ptr5.cast_mut();\n                                }\n                                None => {\n                                    *ptr3.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                        }\n                        Err(e) => {\n                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec6 = (e.into_bytes()).into_boxed_slice();\n                            let ptr6 = vec6.as_ptr().cast::<u8>();\n                            let len6 = vec6.len();\n                            ::core::mem::forget(vec6);\n                            *ptr3.add(8).cast::<usize>() = len6;\n                            *ptr3.add(4).cast::<*mut u8>() = ptr6.cast_mut();\n                        }\n                    };\n                    ptr3\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_send<T: Guest>(arg0: *mut u8) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                        }\n                        _ => {\n                            let l5 = *arg0.add(4).cast::<*mut u8>();\n                            let l6 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l5, l6, 1);\n                        }\n                    }\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_request_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: *mut u8,\n                    arg4: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let len1 = arg4;\n                    let result2 = T::handle_request(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (_rt::Vec::from_raw_parts(arg3.cast(), len1, len1),),\n                    );\n                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result2 {\n                        Ok(e) => {\n                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t4_0, t4_1) = e;\n                            match t4_0 {\n                                Some(e) => {\n                                    *ptr3.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec5 = (e).into_boxed_slice();\n                                    let ptr5 = vec5.as_ptr().cast::<u8>();\n                                    let len5 = vec5.len();\n                                    ::core::mem::forget(vec5);\n                                    *ptr3.add(12).cast::<usize>() = len5;\n                                    *ptr3.add(8).cast::<*mut u8>() = ptr5.cast_mut();\n                                }\n                                None => {\n                                    *ptr3.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                            let (t6_0,) = t4_1;\n                            let vec7 = (t6_0).into_boxed_slice();\n                            let ptr7 = vec7.as_ptr().cast::<u8>();\n                            let len7 = vec7.len();\n                            ::core::mem::forget(vec7);\n                            *ptr3.add(20).cast::<usize>() = len7;\n                            *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();\n                        }\n                        Err(e) => {\n                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec8 = (e.into_bytes()).into_boxed_slice();\n                            let ptr8 = vec8.as_ptr().cast::<u8>();\n                            let len8 = vec8.len();\n                            ::core::mem::forget(vec8);\n                            *ptr3.add(8).cast::<usize>() = len8;\n                            *ptr3.add(4).cast::<*mut u8>() = ptr8.cast_mut();\n                        }\n                    };\n                    ptr3\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_request<T: Guest>(arg0: *mut u8) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                            let l5 = *arg0.add(16).cast::<*mut u8>();\n                            let l6 = *arg0.add(20).cast::<usize>();\n                            let base7 = l5;\n                            let len7 = l6;\n                            _rt::cabi_dealloc(base7, len7 * 1, 1);\n                        }\n                        _ => {\n                            let l8 = *arg0.add(4).cast::<*mut u8>();\n                            let l9 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l8, l9, 1);\n                        }\n                    }\n                }\n                pub trait Guest {\n                    fn handle_send(\n                        state: Option<Json>,\n                        params: (Json,),\n                    ) -> Result<(Option<Json>,), _rt::String>;\n                    fn handle_request(\n                        state: Option<Json>,\n                        params: (Json,),\n                    ) -> Result<(Option<Json>, (Json,)), _rt::String>;\n                }\n                #[doc(hidden)]\n                macro_rules! __export_ntwk_theater_message_server_client_cabi {\n                    ($ty:ident with_types_in $($path_to_types:tt)*) => {\n                        const _ : () = { #[export_name =\n                        \"ntwk:theater/message-server-client#handle-send\"] unsafe extern\n                        \"C\" fn export_handle_send(arg0 : i32, arg1 : * mut u8, arg2 :\n                        usize, arg3 : * mut u8, arg4 : usize,) -> * mut u8 {\n                        $($path_to_types)*:: _export_handle_send_cabi::<$ty > (arg0,\n                        arg1, arg2, arg3, arg4) } #[export_name =\n                        \"cabi_post_ntwk:theater/message-server-client#handle-send\"]\n                        unsafe extern \"C\" fn _post_return_handle_send(arg0 : * mut u8,) {\n                        $($path_to_types)*:: __post_return_handle_send::<$ty > (arg0) }\n                        #[export_name =\n                        \"ntwk:theater/message-server-client#handle-request\"] unsafe\n                        extern \"C\" fn export_handle_request(arg0 : i32, arg1 : * mut u8,\n                        arg2 : usize, arg3 : * mut u8, arg4 : usize,) -> * mut u8 {\n                        $($path_to_types)*:: _export_handle_request_cabi::<$ty > (arg0,\n                        arg1, arg2, arg3, arg4) } #[export_name =\n                        \"cabi_post_ntwk:theater/message-server-client#handle-request\"]\n                        unsafe extern \"C\" fn _post_return_handle_request(arg0 : * mut\n                        u8,) { $($path_to_types)*:: __post_return_handle_request::<$ty >\n                        (arg0) } };\n                    };\n                }\n                #[doc(hidden)]\n                pub(crate) use __export_ntwk_theater_message_server_client_cabi;\n                #[repr(align(4))]\n                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);\n                static mut _RET_AREA: _RetArea = _RetArea(\n                    [::core::mem::MaybeUninit::uninit(); 24],\n                );\n            }\n            #[allow(dead_code, clippy::all)]\n            pub mod actor {\n                #[used]\n                #[doc(hidden)]\n                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;\n                use super::super::super::super::_rt;\n                pub type State = super::super::super::super::ntwk::theater::types::State;\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_init_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: *mut u8,\n                    arg4: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let len1 = arg4;\n                    let bytes1 = _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);\n                    let result2 = T::init(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (_rt::string_lift(bytes1),),\n                    );\n                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result2 {\n                        Ok(e) => {\n                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t4_0,) = e;\n                            match t4_0 {\n                                Some(e) => {\n                                    *ptr3.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec5 = (e).into_boxed_slice();\n                                    let ptr5 = vec5.as_ptr().cast::<u8>();\n                                    let len5 = vec5.len();\n                                    ::core::mem::forget(vec5);\n                                    *ptr3.add(12).cast::<usize>() = len5;\n                                    *ptr3.add(8).cast::<*mut u8>() = ptr5.cast_mut();\n                                }\n                                None => {\n                                    *ptr3.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                        }\n                        Err(e) => {\n                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec6 = (e.into_bytes()).into_boxed_slice();\n                            let ptr6 = vec6.as_ptr().cast::<u8>();\n                            let len6 = vec6.len();\n                            ::core::mem::forget(vec6);\n                            *ptr3.add(8).cast::<usize>() = len6;\n                            *ptr3.add(4).cast::<*mut u8>() = ptr6.cast_mut();\n                        }\n                    };\n                    ptr3\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_init<T: Guest>(arg0: *mut u8) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                        }\n                        _ => {\n                            let l5 = *arg0.add(4).cast::<*mut u8>();\n                            let l6 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l5, l6, 1);\n                        }\n                    }\n                }\n                pub trait Guest {\n                    fn init(\n                        state: State,\n                        params: (_rt::String,),\n                    ) -> Result<(State,), _rt::String>;\n                }\n                #[doc(hidden)]\n                macro_rules! __export_ntwk_theater_actor_cabi {\n                    ($ty:ident with_types_in $($path_to_types:tt)*) => {\n                        const _ : () = { #[export_name = \"ntwk:theater/actor#init\"]\n                        unsafe extern \"C\" fn export_init(arg0 : i32, arg1 : * mut u8,\n                        arg2 : usize, arg3 : * mut u8, arg4 : usize,) -> * mut u8 {\n                        $($path_to_types)*:: _export_init_cabi::<$ty > (arg0, arg1, arg2,\n                        arg3, arg4) } #[export_name =\n                        \"cabi_post_ntwk:theater/actor#init\"] unsafe extern \"C\" fn\n                        _post_return_init(arg0 : * mut u8,) { $($path_to_types)*::\n                        __post_return_init::<$ty > (arg0) } };\n                    };\n                }\n                #[doc(hidden)]\n                pub(crate) use __export_ntwk_theater_actor_cabi;\n                #[repr(align(4))]\n                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);\n                static mut _RET_AREA: _RetArea = _RetArea(\n                    [::core::mem::MaybeUninit::uninit(); 16],\n                );\n            }\n            /// The HTTP handlers interface defines the callback functions that are used\n            /// to handle HTTP requests and WebSocket events.\n            #[allow(dead_code, clippy::all)]\n            pub mod http_handlers {\n                #[used]\n                #[doc(hidden)]\n                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;\n                use super::super::super::super::_rt;\n                pub type State = super::super::super::super::ntwk::theater::types::State;\n                pub type HttpRequest = super::super::super::super::ntwk::theater::http_types::HttpRequest;\n                pub type HttpResponse = super::super::super::super::ntwk::theater::http_types::HttpResponse;\n                pub type WebsocketMessage = super::super::super::super::ntwk::theater::websocket_types::WebsocketMessage;\n                pub type MiddlewareResult = super::super::super::super::ntwk::theater::http_types::MiddlewareResult;\n                pub type HandlerId = super::super::super::super::ntwk::theater::http_framework::HandlerId;\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_request_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: i64,\n                    arg4: *mut u8,\n                    arg5: usize,\n                    arg6: *mut u8,\n                    arg7: usize,\n                    arg8: *mut u8,\n                    arg9: usize,\n                    arg10: i32,\n                    arg11: *mut u8,\n                    arg12: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let len1 = arg5;\n                    let bytes1 = _rt::Vec::from_raw_parts(arg4.cast(), len1, len1);\n                    let len2 = arg7;\n                    let bytes2 = _rt::Vec::from_raw_parts(arg6.cast(), len2, len2);\n                    let base9 = arg8;\n                    let len9 = arg9;\n                    let mut result9 = _rt::Vec::with_capacity(len9);\n                    for i in 0..len9 {\n                        let base = base9.add(i * 16);\n                        let e9 = {\n                            let l3 = *base.add(0).cast::<*mut u8>();\n                            let l4 = *base.add(4).cast::<usize>();\n                            let len5 = l4;\n                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);\n                            let l6 = *base.add(8).cast::<*mut u8>();\n                            let l7 = *base.add(12).cast::<usize>();\n                            let len8 = l7;\n                            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);\n                            (_rt::string_lift(bytes5), _rt::string_lift(bytes8))\n                        };\n                        result9.push(e9);\n                    }\n                    _rt::cabi_dealloc(base9, len9 * 16, 4);\n                    let result11 = T::handle_request(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (\n                            arg3 as u64,\n                            super::super::super::super::ntwk::theater::http_types::HttpRequest {\n                                method: _rt::string_lift(bytes1),\n                                uri: _rt::string_lift(bytes2),\n                                headers: result9,\n                                body: match arg10 {\n                                    0 => None,\n                                    1 => {\n                                        let e = {\n                                            let len10 = arg12;\n                                            _rt::Vec::from_raw_parts(arg11.cast(), len10, len10)\n                                        };\n                                        Some(e)\n                                    }\n                                    _ => _rt::invalid_enum_discriminant(),\n                                },\n                            },\n                        ),\n                    );\n                    let ptr12 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result11 {\n                        Ok(e) => {\n                            *ptr12.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t13_0, t13_1) = e;\n                            match t13_0 {\n                                Some(e) => {\n                                    *ptr12.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec14 = (e).into_boxed_slice();\n                                    let ptr14 = vec14.as_ptr().cast::<u8>();\n                                    let len14 = vec14.len();\n                                    ::core::mem::forget(vec14);\n                                    *ptr12.add(12).cast::<usize>() = len14;\n                                    *ptr12.add(8).cast::<*mut u8>() = ptr14.cast_mut();\n                                }\n                                None => {\n                                    *ptr12.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                            let (t15_0,) = t13_1;\n                            let super::super::super::super::ntwk::theater::http_types::HttpResponse {\n                                status: status16,\n                                headers: headers16,\n                                body: body16,\n                            } = t15_0;\n                            *ptr12.add(16).cast::<u16>() = (_rt::as_i32(status16))\n                                as u16;\n                            let vec20 = headers16;\n                            let len20 = vec20.len();\n                            let layout20 = _rt::alloc::Layout::from_size_align_unchecked(\n                                vec20.len() * 16,\n                                4,\n                            );\n                            let result20 = if layout20.size() != 0 {\n                                let ptr = _rt::alloc::alloc(layout20).cast::<u8>();\n                                if ptr.is_null() {\n                                    _rt::alloc::handle_alloc_error(layout20);\n                                }\n                                ptr\n                            } else {\n                                ::core::ptr::null_mut()\n                            };\n                            for (i, e) in vec20.into_iter().enumerate() {\n                                let base = result20.add(i * 16);\n                                {\n                                    let (t17_0, t17_1) = e;\n                                    let vec18 = (t17_0.into_bytes()).into_boxed_slice();\n                                    let ptr18 = vec18.as_ptr().cast::<u8>();\n                                    let len18 = vec18.len();\n                                    ::core::mem::forget(vec18);\n                                    *base.add(4).cast::<usize>() = len18;\n                                    *base.add(0).cast::<*mut u8>() = ptr18.cast_mut();\n                                    let vec19 = (t17_1.into_bytes()).into_boxed_slice();\n                                    let ptr19 = vec19.as_ptr().cast::<u8>();\n                                    let len19 = vec19.len();\n                                    ::core::mem::forget(vec19);\n                                    *base.add(12).cast::<usize>() = len19;\n                                    *base.add(8).cast::<*mut u8>() = ptr19.cast_mut();\n                                }\n                            }\n                            *ptr12.add(24).cast::<usize>() = len20;\n                            *ptr12.add(20).cast::<*mut u8>() = result20;\n                            match body16 {\n                                Some(e) => {\n                                    *ptr12.add(28).cast::<u8>() = (1i32) as u8;\n                                    let vec21 = (e).into_boxed_slice();\n                                    let ptr21 = vec21.as_ptr().cast::<u8>();\n                                    let len21 = vec21.len();\n                                    ::core::mem::forget(vec21);\n                                    *ptr12.add(36).cast::<usize>() = len21;\n                                    *ptr12.add(32).cast::<*mut u8>() = ptr21.cast_mut();\n                                }\n                                None => {\n                                    *ptr12.add(28).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                        }\n                        Err(e) => {\n                            *ptr12.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec22 = (e.into_bytes()).into_boxed_slice();\n                            let ptr22 = vec22.as_ptr().cast::<u8>();\n                            let len22 = vec22.len();\n                            ::core::mem::forget(vec22);\n                            *ptr12.add(8).cast::<usize>() = len22;\n                            *ptr12.add(4).cast::<*mut u8>() = ptr22.cast_mut();\n                        }\n                    };\n                    ptr12\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_request<T: Guest>(arg0: *mut u8) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                            let l5 = *arg0.add(20).cast::<*mut u8>();\n                            let l6 = *arg0.add(24).cast::<usize>();\n                            let base11 = l5;\n                            let len11 = l6;\n                            for i in 0..len11 {\n                                let base = base11.add(i * 16);\n                                {\n                                    let l7 = *base.add(0).cast::<*mut u8>();\n                                    let l8 = *base.add(4).cast::<usize>();\n                                    _rt::cabi_dealloc(l7, l8, 1);\n                                    let l9 = *base.add(8).cast::<*mut u8>();\n                                    let l10 = *base.add(12).cast::<usize>();\n                                    _rt::cabi_dealloc(l9, l10, 1);\n                                }\n                            }\n                            _rt::cabi_dealloc(base11, len11 * 16, 4);\n                            let l12 = i32::from(*arg0.add(28).cast::<u8>());\n                            match l12 {\n                                0 => {}\n                                _ => {\n                                    let l13 = *arg0.add(32).cast::<*mut u8>();\n                                    let l14 = *arg0.add(36).cast::<usize>();\n                                    let base15 = l13;\n                                    let len15 = l14;\n                                    _rt::cabi_dealloc(base15, len15 * 1, 1);\n                                }\n                            }\n                        }\n                        _ => {\n                            let l16 = *arg0.add(4).cast::<*mut u8>();\n                            let l17 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l16, l17, 1);\n                        }\n                    }\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_middleware_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: i64,\n                    arg4: *mut u8,\n                    arg5: usize,\n                    arg6: *mut u8,\n                    arg7: usize,\n                    arg8: *mut u8,\n                    arg9: usize,\n                    arg10: i32,\n                    arg11: *mut u8,\n                    arg12: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let len1 = arg5;\n                    let bytes1 = _rt::Vec::from_raw_parts(arg4.cast(), len1, len1);\n                    let len2 = arg7;\n                    let bytes2 = _rt::Vec::from_raw_parts(arg6.cast(), len2, len2);\n                    let base9 = arg8;\n                    let len9 = arg9;\n                    let mut result9 = _rt::Vec::with_capacity(len9);\n                    for i in 0..len9 {\n                        let base = base9.add(i * 16);\n                        let e9 = {\n                            let l3 = *base.add(0).cast::<*mut u8>();\n                            let l4 = *base.add(4).cast::<usize>();\n                            let len5 = l4;\n                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);\n                            let l6 = *base.add(8).cast::<*mut u8>();\n                            let l7 = *base.add(12).cast::<usize>();\n                            let len8 = l7;\n                            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);\n                            (_rt::string_lift(bytes5), _rt::string_lift(bytes8))\n                        };\n                        result9.push(e9);\n                    }\n                    _rt::cabi_dealloc(base9, len9 * 16, 4);\n                    let result11 = T::handle_middleware(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (\n                            arg3 as u64,\n                            super::super::super::super::ntwk::theater::http_types::HttpRequest {\n                                method: _rt::string_lift(bytes1),\n                                uri: _rt::string_lift(bytes2),\n                                headers: result9,\n                                body: match arg10 {\n                                    0 => None,\n                                    1 => {\n                                        let e = {\n                                            let len10 = arg12;\n                                            _rt::Vec::from_raw_parts(arg11.cast(), len10, len10)\n                                        };\n                                        Some(e)\n                                    }\n                                    _ => _rt::invalid_enum_discriminant(),\n                                },\n                            },\n                        ),\n                    );\n                    let ptr12 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result11 {\n                        Ok(e) => {\n                            *ptr12.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t13_0, t13_1) = e;\n                            match t13_0 {\n                                Some(e) => {\n                                    *ptr12.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec14 = (e).into_boxed_slice();\n                                    let ptr14 = vec14.as_ptr().cast::<u8>();\n                                    let len14 = vec14.len();\n                                    ::core::mem::forget(vec14);\n                                    *ptr12.add(12).cast::<usize>() = len14;\n                                    *ptr12.add(8).cast::<*mut u8>() = ptr14.cast_mut();\n                                }\n                                None => {\n                                    *ptr12.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                            let (t15_0,) = t13_1;\n                            let super::super::super::super::ntwk::theater::http_types::MiddlewareResult {\n                                proceed: proceed16,\n                                request: request16,\n                            } = t15_0;\n                            *ptr12.add(16).cast::<u8>() = (match proceed16 {\n                                true => 1,\n                                false => 0,\n                            }) as u8;\n                            let super::super::super::super::ntwk::theater::http_types::HttpRequest {\n                                method: method17,\n                                uri: uri17,\n                                headers: headers17,\n                                body: body17,\n                            } = request16;\n                            let vec18 = (method17.into_bytes()).into_boxed_slice();\n                            let ptr18 = vec18.as_ptr().cast::<u8>();\n                            let len18 = vec18.len();\n                            ::core::mem::forget(vec18);\n                            *ptr12.add(24).cast::<usize>() = len18;\n                            *ptr12.add(20).cast::<*mut u8>() = ptr18.cast_mut();\n                            let vec19 = (uri17.into_bytes()).into_boxed_slice();\n                            let ptr19 = vec19.as_ptr().cast::<u8>();\n                            let len19 = vec19.len();\n                            ::core::mem::forget(vec19);\n                            *ptr12.add(32).cast::<usize>() = len19;\n                            *ptr12.add(28).cast::<*mut u8>() = ptr19.cast_mut();\n                            let vec23 = headers17;\n                            let len23 = vec23.len();\n                            let layout23 = _rt::alloc::Layout::from_size_align_unchecked(\n                                vec23.len() * 16,\n                                4,\n                            );\n                            let result23 = if layout23.size() != 0 {\n                                let ptr = _rt::alloc::alloc(layout23).cast::<u8>();\n                                if ptr.is_null() {\n                                    _rt::alloc::handle_alloc_error(layout23);\n                                }\n                                ptr\n                            } else {\n                                ::core::ptr::null_mut()\n                            };\n                            for (i, e) in vec23.into_iter().enumerate() {\n                                let base = result23.add(i * 16);\n                                {\n                                    let (t20_0, t20_1) = e;\n                                    let vec21 = (t20_0.into_bytes()).into_boxed_slice();\n                                    let ptr21 = vec21.as_ptr().cast::<u8>();\n                                    let len21 = vec21.len();\n                                    ::core::mem::forget(vec21);\n                                    *base.add(4).cast::<usize>() = len21;\n                                    *base.add(0).cast::<*mut u8>() = ptr21.cast_mut();\n                                    let vec22 = (t20_1.into_bytes()).into_boxed_slice();\n                                    let ptr22 = vec22.as_ptr().cast::<u8>();\n                                    let len22 = vec22.len();\n                                    ::core::mem::forget(vec22);\n                                    *base.add(12).cast::<usize>() = len22;\n                                    *base.add(8).cast::<*mut u8>() = ptr22.cast_mut();\n                                }\n                            }\n                            *ptr12.add(40).cast::<usize>() = len23;\n                            *ptr12.add(36).cast::<*mut u8>() = result23;\n                            match body17 {\n                                Some(e) => {\n                                    *ptr12.add(44).cast::<u8>() = (1i32) as u8;\n                                    let vec24 = (e).into_boxed_slice();\n                                    let ptr24 = vec24.as_ptr().cast::<u8>();\n                                    let len24 = vec24.len();\n                                    ::core::mem::forget(vec24);\n                                    *ptr12.add(52).cast::<usize>() = len24;\n                                    *ptr12.add(48).cast::<*mut u8>() = ptr24.cast_mut();\n                                }\n                                None => {\n                                    *ptr12.add(44).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                        }\n                        Err(e) => {\n                            *ptr12.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec25 = (e.into_bytes()).into_boxed_slice();\n                            let ptr25 = vec25.as_ptr().cast::<u8>();\n                            let len25 = vec25.len();\n                            ::core::mem::forget(vec25);\n                            *ptr12.add(8).cast::<usize>() = len25;\n                            *ptr12.add(4).cast::<*mut u8>() = ptr25.cast_mut();\n                        }\n                    };\n                    ptr12\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_middleware<T: Guest>(arg0: *mut u8) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                            let l5 = *arg0.add(20).cast::<*mut u8>();\n                            let l6 = *arg0.add(24).cast::<usize>();\n                            _rt::cabi_dealloc(l5, l6, 1);\n                            let l7 = *arg0.add(28).cast::<*mut u8>();\n                            let l8 = *arg0.add(32).cast::<usize>();\n                            _rt::cabi_dealloc(l7, l8, 1);\n                            let l9 = *arg0.add(36).cast::<*mut u8>();\n                            let l10 = *arg0.add(40).cast::<usize>();\n                            let base15 = l9;\n                            let len15 = l10;\n                            for i in 0..len15 {\n                                let base = base15.add(i * 16);\n                                {\n                                    let l11 = *base.add(0).cast::<*mut u8>();\n                                    let l12 = *base.add(4).cast::<usize>();\n                                    _rt::cabi_dealloc(l11, l12, 1);\n                                    let l13 = *base.add(8).cast::<*mut u8>();\n                                    let l14 = *base.add(12).cast::<usize>();\n                                    _rt::cabi_dealloc(l13, l14, 1);\n                                }\n                            }\n                            _rt::cabi_dealloc(base15, len15 * 16, 4);\n                            let l16 = i32::from(*arg0.add(44).cast::<u8>());\n                            match l16 {\n                                0 => {}\n                                _ => {\n                                    let l17 = *arg0.add(48).cast::<*mut u8>();\n                                    let l18 = *arg0.add(52).cast::<usize>();\n                                    let base19 = l17;\n                                    let len19 = l18;\n                                    _rt::cabi_dealloc(base19, len19 * 1, 1);\n                                }\n                            }\n                        }\n                        _ => {\n                            let l20 = *arg0.add(4).cast::<*mut u8>();\n                            let l21 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l20, l21, 1);\n                        }\n                    }\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_websocket_connect_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: i64,\n                    arg4: i64,\n                    arg5: *mut u8,\n                    arg6: usize,\n                    arg7: i32,\n                    arg8: *mut u8,\n                    arg9: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let len1 = arg6;\n                    let bytes1 = _rt::Vec::from_raw_parts(arg5.cast(), len1, len1);\n                    let result3 = T::handle_websocket_connect(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (\n                            arg3 as u64,\n                            arg4 as u64,\n                            _rt::string_lift(bytes1),\n                            match arg7 {\n                                0 => None,\n                                1 => {\n                                    let e = {\n                                        let len2 = arg9;\n                                        let bytes2 = _rt::Vec::from_raw_parts(\n                                            arg8.cast(),\n                                            len2,\n                                            len2,\n                                        );\n                                        _rt::string_lift(bytes2)\n                                    };\n                                    Some(e)\n                                }\n                                _ => _rt::invalid_enum_discriminant(),\n                            },\n                        ),\n                    );\n                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result3 {\n                        Ok(e) => {\n                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t5_0,) = e;\n                            match t5_0 {\n                                Some(e) => {\n                                    *ptr4.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec6 = (e).into_boxed_slice();\n                                    let ptr6 = vec6.as_ptr().cast::<u8>();\n                                    let len6 = vec6.len();\n                                    ::core::mem::forget(vec6);\n                                    *ptr4.add(12).cast::<usize>() = len6;\n                                    *ptr4.add(8).cast::<*mut u8>() = ptr6.cast_mut();\n                                }\n                                None => {\n                                    *ptr4.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                        }\n                        Err(e) => {\n                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec7 = (e.into_bytes()).into_boxed_slice();\n                            let ptr7 = vec7.as_ptr().cast::<u8>();\n                            let len7 = vec7.len();\n                            ::core::mem::forget(vec7);\n                            *ptr4.add(8).cast::<usize>() = len7;\n                            *ptr4.add(4).cast::<*mut u8>() = ptr7.cast_mut();\n                        }\n                    };\n                    ptr4\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_websocket_connect<T: Guest>(\n                    arg0: *mut u8,\n                ) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                        }\n                        _ => {\n                            let l5 = *arg0.add(4).cast::<*mut u8>();\n                            let l6 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l5, l6, 1);\n                        }\n                    }\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_websocket_message_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: i64,\n                    arg4: i64,\n                    arg5: i32,\n                    arg6: *mut u8,\n                    arg7: usize,\n                    arg8: i32,\n                    arg9: *mut u8,\n                    arg10: usize,\n                    arg11: i32,\n                    arg12: *mut u8,\n                    arg13: usize,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    use super::super::super::super::ntwk::theater::websocket_types::MessageType as V2;\n                    let v2 = match arg5 {\n                        0 => V2::Text,\n                        1 => V2::Binary,\n                        2 => V2::Connect,\n                        3 => V2::Close,\n                        4 => V2::Ping,\n                        5 => V2::Pong,\n                        n => {\n                            debug_assert_eq!(n, 6, \"invalid enum discriminant\");\n                            let e2 = {\n                                let len1 = arg7;\n                                let bytes1 = _rt::Vec::from_raw_parts(\n                                    arg6.cast(),\n                                    len1,\n                                    len1,\n                                );\n                                _rt::string_lift(bytes1)\n                            };\n                            V2::Other(e2)\n                        }\n                    };\n                    let result5 = T::handle_websocket_message(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (\n                            arg3 as u64,\n                            arg4 as u64,\n                            super::super::super::super::ntwk::theater::websocket_types::WebsocketMessage {\n                                ty: v2,\n                                data: match arg8 {\n                                    0 => None,\n                                    1 => {\n                                        let e = {\n                                            let len3 = arg10;\n                                            _rt::Vec::from_raw_parts(arg9.cast(), len3, len3)\n                                        };\n                                        Some(e)\n                                    }\n                                    _ => _rt::invalid_enum_discriminant(),\n                                },\n                                text: match arg11 {\n                                    0 => None,\n                                    1 => {\n                                        let e = {\n                                            let len4 = arg13;\n                                            let bytes4 = _rt::Vec::from_raw_parts(\n                                                arg12.cast(),\n                                                len4,\n                                                len4,\n                                            );\n                                            _rt::string_lift(bytes4)\n                                        };\n                                        Some(e)\n                                    }\n                                    _ => _rt::invalid_enum_discriminant(),\n                                },\n                            },\n                        ),\n                    );\n                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result5 {\n                        Ok(e) => {\n                            *ptr6.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t7_0, t7_1) = e;\n                            match t7_0 {\n                                Some(e) => {\n                                    *ptr6.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec8 = (e).into_boxed_slice();\n                                    let ptr8 = vec8.as_ptr().cast::<u8>();\n                                    let len8 = vec8.len();\n                                    ::core::mem::forget(vec8);\n                                    *ptr6.add(12).cast::<usize>() = len8;\n                                    *ptr6.add(8).cast::<*mut u8>() = ptr8.cast_mut();\n                                }\n                                None => {\n                                    *ptr6.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                            let (t9_0,) = t7_1;\n                            let vec15 = t9_0;\n                            let len15 = vec15.len();\n                            let layout15 = _rt::alloc::Layout::from_size_align_unchecked(\n                                vec15.len() * 36,\n                                4,\n                            );\n                            let result15 = if layout15.size() != 0 {\n                                let ptr = _rt::alloc::alloc(layout15).cast::<u8>();\n                                if ptr.is_null() {\n                                    _rt::alloc::handle_alloc_error(layout15);\n                                }\n                                ptr\n                            } else {\n                                ::core::ptr::null_mut()\n                            };\n                            for (i, e) in vec15.into_iter().enumerate() {\n                                let base = result15.add(i * 36);\n                                {\n                                    let super::super::super::super::ntwk::theater::websocket_types::WebsocketMessage {\n                                        ty: ty10,\n                                        data: data10,\n                                        text: text10,\n                                    } = e;\n                                    use super::super::super::super::ntwk::theater::websocket_types::MessageType as V12;\n                                    match ty10 {\n                                        V12::Text => {\n                                            *base.add(0).cast::<u8>() = (0i32) as u8;\n                                        }\n                                        V12::Binary => {\n                                            *base.add(0).cast::<u8>() = (1i32) as u8;\n                                        }\n                                        V12::Connect => {\n                                            *base.add(0).cast::<u8>() = (2i32) as u8;\n                                        }\n                                        V12::Close => {\n                                            *base.add(0).cast::<u8>() = (3i32) as u8;\n                                        }\n                                        V12::Ping => {\n                                            *base.add(0).cast::<u8>() = (4i32) as u8;\n                                        }\n                                        V12::Pong => {\n                                            *base.add(0).cast::<u8>() = (5i32) as u8;\n                                        }\n                                        V12::Other(e) => {\n                                            *base.add(0).cast::<u8>() = (6i32) as u8;\n                                            let vec11 = (e.into_bytes()).into_boxed_slice();\n                                            let ptr11 = vec11.as_ptr().cast::<u8>();\n                                            let len11 = vec11.len();\n                                            ::core::mem::forget(vec11);\n                                            *base.add(8).cast::<usize>() = len11;\n                                            *base.add(4).cast::<*mut u8>() = ptr11.cast_mut();\n                                        }\n                                    }\n                                    match data10 {\n                                        Some(e) => {\n                                            *base.add(12).cast::<u8>() = (1i32) as u8;\n                                            let vec13 = (e).into_boxed_slice();\n                                            let ptr13 = vec13.as_ptr().cast::<u8>();\n                                            let len13 = vec13.len();\n                                            ::core::mem::forget(vec13);\n                                            *base.add(20).cast::<usize>() = len13;\n                                            *base.add(16).cast::<*mut u8>() = ptr13.cast_mut();\n                                        }\n                                        None => {\n                                            *base.add(12).cast::<u8>() = (0i32) as u8;\n                                        }\n                                    };\n                                    match text10 {\n                                        Some(e) => {\n                                            *base.add(24).cast::<u8>() = (1i32) as u8;\n                                            let vec14 = (e.into_bytes()).into_boxed_slice();\n                                            let ptr14 = vec14.as_ptr().cast::<u8>();\n                                            let len14 = vec14.len();\n                                            ::core::mem::forget(vec14);\n                                            *base.add(32).cast::<usize>() = len14;\n                                            *base.add(28).cast::<*mut u8>() = ptr14.cast_mut();\n                                        }\n                                        None => {\n                                            *base.add(24).cast::<u8>() = (0i32) as u8;\n                                        }\n                                    };\n                                }\n                            }\n                            *ptr6.add(20).cast::<usize>() = len15;\n                            *ptr6.add(16).cast::<*mut u8>() = result15;\n                        }\n                        Err(e) => {\n                            *ptr6.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec16 = (e.into_bytes()).into_boxed_slice();\n                            let ptr16 = vec16.as_ptr().cast::<u8>();\n                            let len16 = vec16.len();\n                            ::core::mem::forget(vec16);\n                            *ptr6.add(8).cast::<usize>() = len16;\n                            *ptr6.add(4).cast::<*mut u8>() = ptr16.cast_mut();\n                        }\n                    };\n                    ptr6\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_websocket_message<T: Guest>(\n                    arg0: *mut u8,\n                ) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                            let l5 = *arg0.add(16).cast::<*mut u8>();\n                            let l6 = *arg0.add(20).cast::<usize>();\n                            let base17 = l5;\n                            let len17 = l6;\n                            for i in 0..len17 {\n                                let base = base17.add(i * 36);\n                                {\n                                    let l7 = i32::from(*base.add(0).cast::<u8>());\n                                    match l7 {\n                                        0 => {}\n                                        1 => {}\n                                        2 => {}\n                                        3 => {}\n                                        4 => {}\n                                        5 => {}\n                                        _ => {\n                                            let l8 = *base.add(4).cast::<*mut u8>();\n                                            let l9 = *base.add(8).cast::<usize>();\n                                            _rt::cabi_dealloc(l8, l9, 1);\n                                        }\n                                    }\n                                    let l10 = i32::from(*base.add(12).cast::<u8>());\n                                    match l10 {\n                                        0 => {}\n                                        _ => {\n                                            let l11 = *base.add(16).cast::<*mut u8>();\n                                            let l12 = *base.add(20).cast::<usize>();\n                                            let base13 = l11;\n                                            let len13 = l12;\n                                            _rt::cabi_dealloc(base13, len13 * 1, 1);\n                                        }\n                                    }\n                                    let l14 = i32::from(*base.add(24).cast::<u8>());\n                                    match l14 {\n                                        0 => {}\n                                        _ => {\n                                            let l15 = *base.add(28).cast::<*mut u8>();\n                                            let l16 = *base.add(32).cast::<usize>();\n                                            _rt::cabi_dealloc(l15, l16, 1);\n                                        }\n                                    }\n                                }\n                            }\n                            _rt::cabi_dealloc(base17, len17 * 36, 4);\n                        }\n                        _ => {\n                            let l18 = *arg0.add(4).cast::<*mut u8>();\n                            let l19 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l18, l19, 1);\n                        }\n                    }\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn _export_handle_websocket_disconnect_cabi<T: Guest>(\n                    arg0: i32,\n                    arg1: *mut u8,\n                    arg2: usize,\n                    arg3: i64,\n                    arg4: i64,\n                ) -> *mut u8 {\n                    #[cfg(target_arch = \"wasm32\")] _rt::run_ctors_once();\n                    let result1 = T::handle_websocket_disconnect(\n                        match arg0 {\n                            0 => None,\n                            1 => {\n                                let e = {\n                                    let len0 = arg2;\n                                    _rt::Vec::from_raw_parts(arg1.cast(), len0, len0)\n                                };\n                                Some(e)\n                            }\n                            _ => _rt::invalid_enum_discriminant(),\n                        },\n                        (arg3 as u64, arg4 as u64),\n                    );\n                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();\n                    match result1 {\n                        Ok(e) => {\n                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;\n                            let (t3_0,) = e;\n                            match t3_0 {\n                                Some(e) => {\n                                    *ptr2.add(4).cast::<u8>() = (1i32) as u8;\n                                    let vec4 = (e).into_boxed_slice();\n                                    let ptr4 = vec4.as_ptr().cast::<u8>();\n                                    let len4 = vec4.len();\n                                    ::core::mem::forget(vec4);\n                                    *ptr2.add(12).cast::<usize>() = len4;\n                                    *ptr2.add(8).cast::<*mut u8>() = ptr4.cast_mut();\n                                }\n                                None => {\n                                    *ptr2.add(4).cast::<u8>() = (0i32) as u8;\n                                }\n                            };\n                        }\n                        Err(e) => {\n                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;\n                            let vec5 = (e.into_bytes()).into_boxed_slice();\n                            let ptr5 = vec5.as_ptr().cast::<u8>();\n                            let len5 = vec5.len();\n                            ::core::mem::forget(vec5);\n                            *ptr2.add(8).cast::<usize>() = len5;\n                            *ptr2.add(4).cast::<*mut u8>() = ptr5.cast_mut();\n                        }\n                    };\n                    ptr2\n                }\n                #[doc(hidden)]\n                #[allow(non_snake_case)]\n                pub unsafe fn __post_return_handle_websocket_disconnect<T: Guest>(\n                    arg0: *mut u8,\n                ) {\n                    let l0 = i32::from(*arg0.add(0).cast::<u8>());\n                    match l0 {\n                        0 => {\n                            let l1 = i32::from(*arg0.add(4).cast::<u8>());\n                            match l1 {\n                                0 => {}\n                                _ => {\n                                    let l2 = *arg0.add(8).cast::<*mut u8>();\n                                    let l3 = *arg0.add(12).cast::<usize>();\n                                    let base4 = l2;\n                                    let len4 = l3;\n                                    _rt::cabi_dealloc(base4, len4 * 1, 1);\n                                }\n                            }\n                        }\n                        _ => {\n                            let l5 = *arg0.add(4).cast::<*mut u8>();\n                            let l6 = *arg0.add(8).cast::<usize>();\n                            _rt::cabi_dealloc(l5, l6, 1);\n                        }\n                    }\n                }\n                pub trait Guest {\n                    /// Called to handle an HTTP request\n                    fn handle_request(\n                        state: State,\n                        params: (HandlerId, HttpRequest),\n                    ) -> Result<(State, (HttpResponse,)), _rt::String>;\n                    /// Called to process a request through middleware\n                    fn handle_middleware(\n                        state: State,\n                        params: (HandlerId, HttpRequest),\n                    ) -> Result<(State, (MiddlewareResult,)), _rt::String>;\n                    /// Called when a WebSocket connection is established\n                    fn handle_websocket_connect(\n                        state: State,\n                        params: (HandlerId, u64, _rt::String, Option<_rt::String>),\n                    ) -> Result<(State,), _rt::String>;\n                    /// Called when a WebSocket message is received\n                    fn handle_websocket_message(\n                        state: State,\n                        params: (HandlerId, u64, WebsocketMessage),\n                    ) -> Result<(State, (_rt::Vec<WebsocketMessage>,)), _rt::String>;\n                    /// Called when a WebSocket connection is closed\n                    fn handle_websocket_disconnect(\n                        state: State,\n                        params: (HandlerId, u64),\n                    ) -> Result<(State,), _rt::String>;\n                }\n                #[doc(hidden)]\n                macro_rules! __export_ntwk_theater_http_handlers_cabi {\n                    ($ty:ident with_types_in $($path_to_types:tt)*) => {\n                        const _ : () = { #[export_name =\n                        \"ntwk:theater/http-handlers#handle-request\"] unsafe extern \"C\" fn\n                        export_handle_request(arg0 : i32, arg1 : * mut u8, arg2 : usize,\n                        arg3 : i64, arg4 : * mut u8, arg5 : usize, arg6 : * mut u8, arg7\n                        : usize, arg8 : * mut u8, arg9 : usize, arg10 : i32, arg11 : *\n                        mut u8, arg12 : usize,) -> * mut u8 { $($path_to_types)*::\n                        _export_handle_request_cabi::<$ty > (arg0, arg1, arg2, arg3,\n                        arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12) }\n                        #[export_name =\n                        \"cabi_post_ntwk:theater/http-handlers#handle-request\"] unsafe\n                        extern \"C\" fn _post_return_handle_request(arg0 : * mut u8,) {\n                        $($path_to_types)*:: __post_return_handle_request::<$ty > (arg0)\n                        } #[export_name = \"ntwk:theater/http-handlers#handle-middleware\"]\n                        unsafe extern \"C\" fn export_handle_middleware(arg0 : i32, arg1 :\n                        * mut u8, arg2 : usize, arg3 : i64, arg4 : * mut u8, arg5 :\n                        usize, arg6 : * mut u8, arg7 : usize, arg8 : * mut u8, arg9 :\n                        usize, arg10 : i32, arg11 : * mut u8, arg12 : usize,) -> * mut u8\n                        { $($path_to_types)*:: _export_handle_middleware_cabi::<$ty >\n                        (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,\n                        arg10, arg11, arg12) } #[export_name =\n                        \"cabi_post_ntwk:theater/http-handlers#handle-middleware\"] unsafe\n                        extern \"C\" fn _post_return_handle_middleware(arg0 : * mut u8,) {\n                        $($path_to_types)*:: __post_return_handle_middleware::<$ty >\n                        (arg0) } #[export_name =\n                        \"ntwk:theater/http-handlers#handle-websocket-connect\"] unsafe\n                        extern \"C\" fn export_handle_websocket_connect(arg0 : i32, arg1 :\n                        * mut u8, arg2 : usize, arg3 : i64, arg4 : i64, arg5 : * mut u8,\n                        arg6 : usize, arg7 : i32, arg8 : * mut u8, arg9 : usize,) -> *\n                        mut u8 { $($path_to_types)*::\n                        _export_handle_websocket_connect_cabi::<$ty > (arg0, arg1, arg2,\n                        arg3, arg4, arg5, arg6, arg7, arg8, arg9) } #[export_name =\n                        \"cabi_post_ntwk:theater/http-handlers#handle-websocket-connect\"]\n                        unsafe extern \"C\" fn _post_return_handle_websocket_connect(arg0 :\n                        * mut u8,) { $($path_to_types)*::\n                        __post_return_handle_websocket_connect::<$ty > (arg0) }\n                        #[export_name =\n                        \"ntwk:theater/http-handlers#handle-websocket-message\"] unsafe\n                        extern \"C\" fn export_handle_websocket_message(arg0 : i32, arg1 :\n                        * mut u8, arg2 : usize, arg3 : i64, arg4 : i64, arg5 : i32, arg6\n                        : * mut u8, arg7 : usize, arg8 : i32, arg9 : * mut u8, arg10 :\n                        usize, arg11 : i32, arg12 : * mut u8, arg13 : usize,) -> * mut u8\n                        { $($path_to_types)*::\n                        _export_handle_websocket_message_cabi::<$ty > (arg0, arg1, arg2,\n                        arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12,\n                        arg13) } #[export_name =\n                        \"cabi_post_ntwk:theater/http-handlers#handle-websocket-message\"]\n                        unsafe extern \"C\" fn _post_return_handle_websocket_message(arg0 :\n                        * mut u8,) { $($path_to_types)*::\n                        __post_return_handle_websocket_message::<$ty > (arg0) }\n                        #[export_name =\n                        \"ntwk:theater/http-handlers#handle-websocket-disconnect\"] unsafe\n                        extern \"C\" fn export_handle_websocket_disconnect(arg0 : i32, arg1\n                        : * mut u8, arg2 : usize, arg3 : i64, arg4 : i64,) -> * mut u8 {\n                        $($path_to_types)*::\n                        _export_handle_websocket_disconnect_cabi::<$ty > (arg0, arg1,\n                        arg2, arg3, arg4) } #[export_name =\n                        \"cabi_post_ntwk:theater/http-handlers#handle-websocket-disconnect\"]\n                        unsafe extern \"C\" fn\n                        _post_return_handle_websocket_disconnect(arg0 : * mut u8,) {\n                        $($path_to_types)*::\n                        __post_return_handle_websocket_disconnect::<$ty > (arg0) } };\n                    };\n                }\n                #[doc(hidden)]\n                pub(crate) use __export_ntwk_theater_http_handlers_cabi;\n                #[repr(align(4))]\n                struct _RetArea([::core::mem::MaybeUninit<u8>; 56]);\n                static mut _RET_AREA: _RetArea = _RetArea(\n                    [::core::mem::MaybeUninit::uninit(); 56],\n                );\n            }\n        }\n    }\n}\n#[rustfmt::skip]\nmod _rt {\n    pub use alloc_crate::vec::Vec;\n    pub use alloc_crate::string::String;\n    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {\n        if cfg!(debug_assertions) {\n            String::from_utf8(bytes).unwrap()\n        } else {\n            String::from_utf8_unchecked(bytes)\n        }\n    }\n    pub unsafe fn invalid_enum_discriminant<T>() -> T {\n        if cfg!(debug_assertions) {\n            panic!(\"invalid enum discriminant\")\n        } else {\n            core::hint::unreachable_unchecked()\n        }\n    }\n    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {\n        if size == 0 {\n            return;\n        }\n        let layout = alloc::Layout::from_size_align_unchecked(size, align);\n        alloc::dealloc(ptr, layout);\n    }\n    pub fn as_i32<T: AsI32>(t: T) -> i32 {\n        t.as_i32()\n    }\n    pub trait AsI32 {\n        fn as_i32(self) -> i32;\n    }\n    impl<'a, T: Copy + AsI32> AsI32 for &'a T {\n        fn as_i32(self) -> i32 {\n            (*self).as_i32()\n        }\n    }\n    impl AsI32 for i32 {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for u32 {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for i16 {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for u16 {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for i8 {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for u8 {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for char {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    impl AsI32 for usize {\n        #[inline]\n        fn as_i32(self) -> i32 {\n            self as i32\n        }\n    }\n    pub fn as_i64<T: AsI64>(t: T) -> i64 {\n        t.as_i64()\n    }\n    pub trait AsI64 {\n        fn as_i64(self) -> i64;\n    }\n    impl<'a, T: Copy + AsI64> AsI64 for &'a T {\n        fn as_i64(self) -> i64 {\n            (*self).as_i64()\n        }\n    }\n    impl AsI64 for i64 {\n        #[inline]\n        fn as_i64(self) -> i64 {\n            self as i64\n        }\n    }\n    impl AsI64 for u64 {\n        #[inline]\n        fn as_i64(self) -> i64 {\n            self as i64\n        }\n    }\n    pub unsafe fn bool_lift(val: u8) -> bool {\n        if cfg!(debug_assertions) {\n            match val {\n                0 => false,\n                1 => true,\n                _ => panic!(\"invalid bool discriminant\"),\n            }\n        } else {\n            val != 0\n        }\n    }\n    #[cfg(target_arch = \"wasm32\")]\n    pub fn run_ctors_once() {\n        wit_bindgen_rt::run_ctors_once();\n    }\n    pub use alloc_crate::alloc;\n    extern crate alloc as alloc_crate;\n}\n/// Generates `#[no_mangle]` functions to export the specified type as the\n/// root implementation of all generated traits.\n///\n/// For more information see the documentation of `wit_bindgen::generate!`.\n///\n/// ```rust\n/// # macro_rules! export{ ($($t:tt)*) => (); }\n/// # trait Guest {}\n/// struct MyType;\n///\n/// impl Guest for MyType {\n///     // ...\n/// }\n///\n/// export!(MyType);\n/// ```\n#[allow(unused_macros)]\n#[doc(hidden)]\nmacro_rules! __export_single_chat_impl {\n    ($ty:ident) => {\n        self::export!($ty with_types_in self);\n    };\n    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {\n        $($path_to_types_root)*::\n        exports::ntwk::theater::message_server_client::__export_ntwk_theater_message_server_client_cabi!($ty\n        with_types_in $($path_to_types_root)*::\n        exports::ntwk::theater::message_server_client); $($path_to_types_root)*::\n        exports::ntwk::theater::actor::__export_ntwk_theater_actor_cabi!($ty\n        with_types_in $($path_to_types_root)*:: exports::ntwk::theater::actor);\n        $($path_to_types_root)*::\n        exports::ntwk::theater::http_handlers::__export_ntwk_theater_http_handlers_cabi!($ty\n        with_types_in $($path_to_types_root)*:: exports::ntwk::theater::http_handlers);\n    };\n}\n#[doc(inline)]\npub(crate) use __export_single_chat_impl as export;\n#[cfg(target_arch = \"wasm32\")]\n#[link_section = \"component-type:wit-bindgen:0.36.0:ntwk:theater:single-chat:encoded world\"]\n#[doc(hidden)]\npub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2898] = *b\"\\\n\\0asm\\x0d\\0\\x01\\0\\0\\x19\\x16wit-component-encoding\\x04\\0\\x07\\xd0\\x15\\x01A\\x02\\x01\\\nA\\x1d\\x01B\\x0f\\x01p}\\x04\\0\\x04json\\x03\\0\\0\\x01p}\\x01k\\x02\\x04\\0\\x05state\\x03\\0\\x03\\\n\\x01s\\x04\\0\\x08actor-id\\x03\\0\\x05\\x01kw\\x01r\\x03\\x0aevent-types\\x06parent\\x07\\x04\\\ndata\\x01\\x04\\0\\x05event\\x03\\0\\x08\\x01r\\x02\\x04hashw\\x05event\\x09\\x04\\0\\x0ameta-e\\\nvent\\x03\\0\\x0a\\x01p\\x0b\\x01r\\x01\\x06events\\x0c\\x04\\0\\x05chain\\x03\\0\\x0d\\x03\\0\\x12\\\nntwk:theater/types\\x05\\0\\x02\\x03\\0\\0\\x04json\\x02\\x03\\0\\0\\x05chain\\x02\\x03\\0\\0\\x08\\\nactor-id\\x01B\\x0a\\x02\\x03\\x02\\x01\\x01\\x04\\0\\x04json\\x03\\0\\0\\x02\\x03\\x02\\x01\\x02\\x04\\\n\\0\\x05chain\\x03\\0\\x02\\x02\\x03\\x02\\x01\\x03\\x04\\0\\x08actor-id\\x03\\0\\x04\\x01@\\x01\\x03\\\nmsgs\\x01\\0\\x04\\0\\x03log\\x01\\x06\\x01@\\0\\0\\x03\\x04\\0\\x09get-chain\\x01\\x07\\x03\\0\\x14\\\nntwk:theater/runtime\\x05\\x04\\x01B\\x14\\x01p}\\x04\\0\\x05bytes\\x03\\0\\0\\x01o\\x02ss\\x01\\\np\\x02\\x01k\\x01\\x01r\\x04\\x06methods\\x03uris\\x07headers\\x03\\x04body\\x04\\x04\\0\\x0ch\\\nttp-request\\x03\\0\\x05\\x01r\\x03\\x06status{\\x07headers\\x03\\x04body\\x04\\x04\\0\\x0dht\\\ntp-response\\x03\\0\\x07\\x01r\\x02\\x09cert-paths\\x08key-paths\\x04\\0\\x0atls-config\\x03\\\n\\0\\x09\\x01k{\\x01ks\\x01k\\x0a\\x01r\\x03\\x04port\\x0b\\x04host\\x0c\\x0atls-config\\x0d\\x04\\\n\\0\\x0dserver-config\\x03\\0\\x0e\\x01r\\x07\\x02idw\\x04port{\\x04hosts\\x07running\\x7f\\x0c\\\nroutes-county\\x10middleware-county\\x11websocket-enabled\\x7f\\x04\\0\\x0bserver-info\\\n\\x03\\0\\x10\\x01r\\x02\\x07proceed\\x7f\\x07request\\x06\\x04\\0\\x11middleware-result\\x03\\\n\\0\\x12\\x03\\0\\x17ntwk:theater/http-types\\x05\\x05\\x01B\\x07\\x01q\\x07\\x04text\\0\\0\\x06\\\nbinary\\0\\0\\x07connect\\0\\0\\x05close\\0\\0\\x04ping\\0\\0\\x04pong\\0\\0\\x05other\\x01s\\0\\x04\\\n\\0\\x0cmessage-type\\x03\\0\\0\\x01p}\\x01k\\x02\\x01ks\\x01r\\x03\\x02ty\\x01\\x04data\\x03\\x04\\\ntext\\x04\\x04\\0\\x11websocket-message\\x03\\0\\x05\\x03\\0\\x1cntwk:theater/websocket-ty\\\npes\\x05\\x06\\x02\\x03\\0\\0\\x05state\\x02\\x03\\0\\x02\\x0chttp-request\\x02\\x03\\0\\x02\\x0d\\\nhttp-response\\x02\\x03\\0\\x02\\x0dserver-config\\x02\\x03\\0\\x02\\x0bserver-info\\x02\\x03\\\n\\0\\x02\\x0atls-config\\x02\\x03\\0\\x03\\x11websocket-message\\x01B9\\x02\\x03\\x02\\x01\\x07\\\n\\x04\\0\\x05state\\x03\\0\\0\\x02\\x03\\x02\\x01\\x08\\x04\\0\\x0chttp-request\\x03\\0\\x02\\x02\\x03\\\n\\x02\\x01\\x09\\x04\\0\\x0dhttp-response\\x03\\0\\x04\\x02\\x03\\x02\\x01\\x0a\\x04\\0\\x0dserve\\\nr-config\\x03\\0\\x06\\x02\\x03\\x02\\x01\\x0b\\x04\\0\\x0bserver-info\\x03\\0\\x08\\x02\\x03\\x02\\\n\\x01\\x0c\\x04\\0\\x0atls-config\\x03\\0\\x0a\\x02\\x03\\x02\\x01\\x0d\\x04\\0\\x11websocket-me\\\nssage\\x03\\0\\x0c\\x01w\\x04\\0\\x09server-id\\x03\\0\\x0e\\x01w\\x04\\0\\x0ahandler-id\\x03\\0\\\n\\x10\\x01w\\x04\\0\\x08route-id\\x03\\0\\x12\\x01w\\x04\\0\\x0dmiddleware-id\\x03\\0\\x14\\x01j\\\n\\x01\\x0f\\x01s\\x01@\\x01\\x06config\\x07\\0\\x16\\x04\\0\\x0dcreate-server\\x01\\x17\\x01j\\x01\\\n\\x09\\x01s\\x01@\\x01\\x09server-id\\x0f\\0\\x18\\x04\\0\\x0fget-server-info\\x01\\x19\\x01j\\x01\\\n{\\x01s\\x01@\\x01\\x09server-id\\x0f\\0\\x1a\\x04\\0\\x0cstart-server\\x01\\x1b\\x01j\\0\\x01s\\\n\\x01@\\x01\\x09server-id\\x0f\\0\\x1c\\x04\\0\\x0bstop-server\\x01\\x1d\\x04\\0\\x0edestroy-s\\\nerver\\x01\\x1d\\x01j\\x01\\x11\\x01s\\x01@\\x01\\x0chandler-names\\0\\x1e\\x04\\0\\x10registe\\\nr-handler\\x01\\x1f\\x01j\\x01\\x13\\x01s\\x01@\\x04\\x09server-id\\x0f\\x04paths\\x06method\\\ns\\x0ahandler-id\\x11\\0\\x20\\x04\\0\\x09add-route\\x01!\\x01@\\x01\\x08route-id\\x13\\0\\x1c\\\n\\x04\\0\\x0cremove-route\\x01\\\"\\x01j\\x01\\x15\\x01s\\x01@\\x03\\x09server-id\\x0f\\x04path\\\ns\\x0ahandler-id\\x11\\0#\\x04\\0\\x0eadd-middleware\\x01$\\x01@\\x01\\x0dmiddleware-id\\x15\\\n\\0\\x1c\\x04\\0\\x11remove-middleware\\x01%\\x01k\\x11\\x01@\\x05\\x09server-id\\x0f\\x04pat\\\nhs\\x12connect-handler-id&\\x12message-handler-id\\x11\\x15disconnect-handler-id&\\0\\x1c\\\n\\x04\\0\\x10enable-websocket\\x01'\\x01@\\x02\\x09server-id\\x0f\\x04paths\\0\\x1c\\x04\\0\\x11\\\ndisable-websocket\\x01(\\x01@\\x03\\x09server-id\\x0f\\x0dconnection-idw\\x07message\\x0d\\\n\\0\\x1c\\x04\\0\\x16send-websocket-message\\x01)\\x01@\\x02\\x09server-id\\x0f\\x0dconnect\\\nion-idw\\0\\x1c\\x04\\0\\x0fclose-websocket\\x01*\\x03\\0\\x1bntwk:theater/http-framework\\\n\\x05\\x0e\\x02\\x03\\0\\0\\x05event\\x01B\\x0e\\x02\\x03\\x02\\x01\\x01\\x04\\0\\x04json\\x03\\0\\0\\\n\\x02\\x03\\x02\\x01\\x0f\\x04\\0\\x05event\\x03\\0\\x02\\x01k\\x01\\x01o\\x01\\x01\\x01o\\x01\\x04\\\n\\x01j\\x01\\x06\\x01s\\x01@\\x02\\x05state\\x04\\x06params\\x05\\0\\x07\\x04\\0\\x0bhandle-sen\\\nd\\x01\\x08\\x01o\\x02\\x04\\x05\\x01j\\x01\\x09\\x01s\\x01@\\x02\\x05state\\x04\\x06params\\x05\\\n\\0\\x0a\\x04\\0\\x0ehandle-request\\x01\\x0b\\x04\\0\\\"ntwk:theater/message-server-client\\\n\\x05\\x10\\x01B\\x07\\x02\\x03\\x02\\x01\\x07\\x04\\0\\x05state\\x03\\0\\0\\x01o\\x01s\\x01o\\x01\\x01\\\n\\x01j\\x01\\x03\\x01s\\x01@\\x02\\x05state\\x01\\x06params\\x02\\0\\x04\\x04\\0\\x04init\\x01\\x05\\\n\\x04\\0\\x12ntwk:theater/actor\\x05\\x11\\x02\\x03\\0\\x02\\x11middleware-result\\x02\\x03\\0\\\n\\x04\\x0ahandler-id\\x01B'\\x02\\x03\\x02\\x01\\x07\\x04\\0\\x05state\\x03\\0\\0\\x02\\x03\\x02\\x01\\\n\\x08\\x04\\0\\x0chttp-request\\x03\\0\\x02\\x02\\x03\\x02\\x01\\x09\\x04\\0\\x0dhttp-response\\x03\\\n\\0\\x04\\x02\\x03\\x02\\x01\\x0d\\x04\\0\\x11websocket-message\\x03\\0\\x06\\x02\\x03\\x02\\x01\\x12\\\n\\x04\\0\\x11middleware-result\\x03\\0\\x08\\x02\\x03\\x02\\x01\\x13\\x04\\0\\x0ahandler-id\\x03\\\n\\0\\x0a\\x01o\\x02\\x0b\\x03\\x01o\\x01\\x05\\x01o\\x02\\x01\\x0d\\x01j\\x01\\x0e\\x01s\\x01@\\x02\\\n\\x05state\\x01\\x06params\\x0c\\0\\x0f\\x04\\0\\x0ehandle-request\\x01\\x10\\x01o\\x01\\x09\\x01\\\no\\x02\\x01\\x11\\x01j\\x01\\x12\\x01s\\x01@\\x02\\x05state\\x01\\x06params\\x0c\\0\\x13\\x04\\0\\x11\\\nhandle-middleware\\x01\\x14\\x01ks\\x01o\\x04\\x0bws\\x15\\x01o\\x01\\x01\\x01j\\x01\\x17\\x01\\\ns\\x01@\\x02\\x05state\\x01\\x06params\\x16\\0\\x18\\x04\\0\\x18handle-websocket-connect\\x01\\\n\\x19\\x01o\\x03\\x0bw\\x07\\x01p\\x07\\x01o\\x01\\x1b\\x01o\\x02\\x01\\x1c\\x01j\\x01\\x1d\\x01s\\x01\\\n@\\x02\\x05state\\x01\\x06params\\x1a\\0\\x1e\\x04\\0\\x18handle-websocket-message\\x01\\x1f\\\n\\x01o\\x02\\x0bw\\x01@\\x02\\x05state\\x01\\x06params\\x20\\0\\x18\\x04\\0\\x1bhandle-websock\\\net-disconnect\\x01!\\x04\\0\\x1antwk:theater/http-handlers\\x05\\x14\\x04\\0\\x18ntwk:the\\\nater/single-chat\\x04\\0\\x0b\\x11\\x01\\0\\x0bsingle-chat\\x03\\0\\0\\0G\\x09producers\\x01\\x0c\\\nprocessed-by\\x02\\x0dwit-component\\x070.220.1\\x10wit-bindgen-rust\\x060.36.0\";\n#[inline(never)]\n#[doc(hidden)]\npub fn __link_custom_section_describing_imports() {\n    wit_bindgen_rt::maybe_link_cabi_realloc();\n}\n","tool_use_id":"toolu_01Xtd7P2E6fMNBXoshEqx7x7","type":"tool_result"}],"role":"user"},{"content":[{"text":"Let's check out the `wit/` directory to understand more about the interface:","type":"text"},{"id":"toolu_018yZtezbMi5k5osXZ7FbSYS","input":{"path":"wit"},"name":"list_files","type":"tool_use"}],"role":"assistant"},{"content":[{"content":"Contents of './wit': \n [FILE] store.wit\n [FILE] message-server.wit\n [FILE] http.wit\n [FILE] actor.wit\n [FILE] types.wit\n [FILE] websocket.wit\n [FILE] runtime.wit\n [FILE] supervisor.wit\n [FILE] world.wit\n [FILE] filesystem.wit","tool_use_id":"toolu_018yZtezbMi5k5osXZ7FbSYS","type":"tool_result"}],"role":"user"},{"content":[{"text":"Let's look at the world.wit file to understand the component interface:","type":"text"},{"id":"toolu_013dur5fPVGxHDmf1ESGCpAV","input":{"path":"wit/world.wit"},"name":"read_file","type":"tool_use"}],"role":"assistant"},{"content":[{"content":"Contents of './wit/world.wit': package ntwk:theater;\n\nworld single-chat {\n    import runtime;\n    export message-server-client;\n    export actor;\n\n    import http-framework;\n    export http-handlers;\n}\n","tool_use_id":"toolu_013dur5fPVGxHDmf1ESGCpAV","type":"tool_result"}],"role":"user"},{"content":[{"text":"Now I understand the project structure. Based on my exploration, I can see that this is a WebAssembly component that implements an HTTP server. Looking at the `lib.rs` file, I can see that the component handles HTTP requests and WebSocket connections.\n\nThe specific task is to modify the code to print \"Hello Fun World!\" when handling a request. I notice that in the `handle_request` function in `src/lib.rs`, there's a response for the GET \"/\" route that currently returns \"Hello World\". I need to modify this to return \"Hello Fun World!\" instead.\n\nHere's the change I need to make:","type":"text"},{"id":"toolu_01MdePZZT4UpYMKkJ7PGkyUP","input":{"new_text":"                let data = \"Hello Fun World!\";\n                let body = data.as_bytes().to_vec();","old_text":"                let data = \"Hello World\";\n                let body = data.as_bytes().to_vec();","path":"src/lib.rs"},"name":"edit_file","type":"tool_use"}],"role":"assistant"},{"content":[{"content":"Successfully edited file './src/lib.rs'","tool_use_id":"toolu_01MdePZZT4UpYMKkJ7PGkyUP","type":"tool_result"}],"role":"user"},{"content":[{"text":"Now I've modified the code to print \"Hello Fun World!\" instead of \"Hello World\" when handling a request. Let me verify the change:","type":"text"},{"id":"toolu_01CpcLHca1qo7avL2frcfpcw","input":{"path":"src/lib.rs"},"name":"read_file","type":"tool_use"}],"role":"assistant"},{"content":[{"content":"Contents of './src/lib.rs': mod bindings;\n\nuse crate::bindings::exports::ntwk::theater::actor::Guest;\nuse crate::bindings::exports::ntwk::theater::http_handlers::Guest as HttpHandlers;\nuse crate::bindings::exports::ntwk::theater::message_server_client::Guest as MessageServerClient;\nuse crate::bindings::ntwk::theater::http_framework::{\n    add_middleware, add_route, create_server, enable_websocket, register_handler, start_server,\n    ServerConfig,\n};\nuse crate::bindings::ntwk::theater::http_types::{HttpRequest, HttpResponse, MiddlewareResult};\nuse crate::bindings::ntwk::theater::runtime::log;\nuse crate::bindings::ntwk::theater::types::State;\nuse crate::bindings::ntwk::theater::websocket_types::{MessageType, WebsocketMessage};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize)]\nstruct AppState {}\n\nimpl Default for AppState {\n    fn default() -> Self {\n        Self {}\n    }\n}\n\nstruct Actor;\nimpl Guest for Actor {\n    fn init(_state: State, params: (String,)) -> Result<(State,), String> {\n        log(\"Initializing HTTP Actor\");\n        let (param,) = params;\n        log(&format!(\"Init parameter: {}\", param));\n\n        let app_state = AppState::default();\n        log(\"Created default app state\");\n        let state_bytes = serde_json::to_vec(&app_state).map_err(|e| e.to_string())?;\n\n        // Create the initial state\n        let new_state = Some(state_bytes);\n\n        // Set up the HTTP server\n        log(\"Setting up HTTP server...\");\n        setup_http_server().map_err(|e| e.to_string())?;\n        log(\"HTTP server set up successfully\");\n\n        Ok((new_state,))\n    }\n}\n\n// Setup the HTTP server and return the server ID\nfn setup_http_server() -> Result<u64, String> {\n    log(\"Setting up HTTP server\");\n\n    // Create server configuration\n    let config = ServerConfig {\n        port: Some(8080),\n        host: Some(\"0.0.0.0\".to_string()),\n        tls_config: None,\n    };\n\n    // Create a new HTTP server\n    let server_id = create_server(&config)?;\n    log(&format!(\"Created server with ID: {}\", server_id));\n\n    // Register handlers\n    let handler_id = register_handler(\"handle_api\")?;\n\n    log(&format!(\"Registered handlers - API: {}\", handler_id));\n\n    // Add routes\n    add_route(server_id, \"/\", \"GET\", handler_id)?;\n\n    // Start the server\n    let port = start_server(server_id)?;\n    log(&format!(\"Server started on port {}\", port));\n\n    Ok(server_id)\n}\n\nimpl HttpHandlers for Actor {\n    // HTTP Request Handler\n    fn handle_request(\n        state: State,\n        params: (u64, HttpRequest),\n    ) -> Result<(State, (HttpResponse,)), String> {\n        let (handler_id, request) = params;\n        log(&format!(\n            \"Handling HTTP request with handler ID: {}\",\n            handler_id\n        ));\n        log(&format!(\n            \"  Method: {}, Path: {}\",\n            request.method, request.uri\n        ));\n\n        // Parse the current state\n        let state_bytes = state.unwrap_or_default();\n        let mut app_state: AppState = if !state_bytes.is_empty() {\n            log(\"Deserializing existing state\");\n            let app_state: AppState =\n                serde_json::from_slice(&state_bytes).map_err(|e| e.to_string())?;\n            log(&format!(\n                \"App state: {}\",\n                serde_json::to_string_pretty(&app_state).unwrap()\n            ));\n            app_state\n        } else {\n            log(\"Creating default state\");\n            AppState::default()\n        };\n\n        // Process the request based on the path and method\n        log(&format!(\n            \"Processing request: {} {}\",\n            request.method, request.uri\n        ));\n        let response = match (request.uri.as_str(), request.method.as_str()) {\n            (\"/\", \"GET\") => {\n                log(\"Handling GET /\");\n\n                let data = \"Hello Fun World!\";\n                let body = data.as_bytes().to_vec();\n\n                HttpResponse {\n                    status: 200,\n                    headers: vec![(\"content-type\".to_string(), \"application/json\".to_string())],\n                    body: Some(body),\n                }\n            }\n            _ => {\n                // Path not found\n                log(&format!(\n                    \"Error: Path not found - {} {}\",\n                    request.method, request.uri\n                ));\n                let data = serde_json::json!({\n                    \"success\": false,\n                    \"error\": \"Not found\"\n                });\n                let body = serde_json::to_vec(&data).map_err(|e| e.to_string())?;\n\n                HttpResponse {\n                    status: 404,\n                    headers: vec![(\"content-type\".to_string(), \"application/json\".to_string())],\n                    body: Some(body),\n                }\n            }\n        };\n\n        log(&format!(\"Response: {:?}\", response));\n        let updated_state_bytes = serde_json::to_vec(&app_state).map_err(|e| e.to_string())?;\n        let updated_state = Some(updated_state_bytes);\n\n        Ok((updated_state, (response,)))\n    }\n\n    // Middleware Handler\n    fn handle_middleware(\n        state: State,\n        params: (u64, HttpRequest),\n    ) -> Result<(State, (MiddlewareResult,)), String> {\n        let (handler_id, request) = params;\n        log(&format!(\n            \"Handling middleware with handler ID: {}\",\n            handler_id\n        ));\n        Ok((\n            state,\n            (MiddlewareResult {\n                proceed: true,\n                request,\n            },),\n        ))\n    }\n\n    // WebSocket Connect Handler\n    fn handle_websocket_connect(\n        state: State,\n        params: (u64, u64, String, Option<String>),\n    ) -> Result<(State,), String> {\n        let (handler_id, connection_id, path, _query) = params;\n        log(&format!(\n            \"WebSocket connected - Handler: {}, Connection: {}, Path: {}\",\n            handler_id, connection_id, path\n        ));\n\n        Ok((state,))\n    }\n\n    // WebSocket Message Handler\n    fn handle_websocket_message(\n        state: State,\n        params: (u64, u64, WebsocketMessage),\n    ) -> Result<(State, (Vec<WebsocketMessage>,)), String> {\n        let (handler_id, connection_id, message) = params;\n        log(&format!(\n            \"WebSocket message received - Handler: {}, Connection: {}\",\n            handler_id, connection_id\n        ));\n\n        // Parse the current state\n        let state_bytes = state.unwrap_or_default();\n        let app_state: AppState = if !state_bytes.is_empty() {\n            log(\"WebSocket: Deserializing existing state\");\n            let app_state: AppState =\n                serde_json::from_slice(&state_bytes).map_err(|e| e.to_string())?;\n            app_state\n        } else {\n            log(\"WebSocket: Creating default state\");\n            AppState::default()\n        };\n\n        let responses = match message.ty {\n            _ => {\n                // Other message types\n                log(\"  Other message type\");\n                vec![]\n            }\n        };\n\n        // Save the updated state\n        let updated_state_bytes = serde_json::to_vec(&app_state).map_err(|e| e.to_string())?;\n        let updated_state = Some(updated_state_bytes);\n\n        Ok((updated_state, (responses,)))\n    }\n\n    // WebSocket Disconnect Handler\n    fn handle_websocket_disconnect(state: State, params: (u64, u64)) -> Result<(State,), String> {\n        let (handler_id, connection_id) = params;\n        log(&format!(\n            \"WebSocket disconnected - Handler: {}, Connection: {}\",\n            handler_id, connection_id\n        ));\n\n        Ok((state,))\n    }\n}\n\nimpl MessageServerClient for Actor {\n    fn handle_send(\n        state: Option<Vec<u8>>,\n        _params: (Vec<u8>,),\n    ) -> Result<(Option<Vec<u8>>,), String> {\n        Ok((state,))\n    }\n\n    fn handle_request(\n        state: Option<Vec<u8>>,\n        _params: (Vec<u8>,),\n    ) -> Result<(Option<Vec<u8>>, (Vec<u8>,)), String> {\n        Ok((state, (vec![],)))\n    }\n}\n\nbindings::export!(Actor with_types_in bindings);\n","tool_use_id":"toolu_01CpcLHca1qo7avL2frcfpcw","type":"tool_result"}],"role":"user"}],"model":"claude-3-7-sonnet-20250219","tool_choice":{"type":"auto"},"tools":[{"description":"Read the contents of a file from the filesystem. Use this tool to view the contents of any file in the project.","input_schema":{"properties":{"path":{"description":"Path to the file to read. Can be absolute or relative to the current directory.","type":"string"}},"required":["path"],"type":"object"},"name":"read_file"},{"description":"Write content to a file in the filesystem. Use this tool to create new files or completely replace existing files.","input_schema":{"properties":{"content":{"description":"Content to write to the file. This will completely replace any existing content.","type":"string"},"path":{"description":"Path to the file to write. Can be absolute or relative to the current directory.","type":"string"}},"required":["path","content"],"type":"object"},"name":"write_file"},{"description":"Edit a file by replacing specific text with new content. Use this for targeted changes rather than rewriting entire files.","input_schema":{"properties":{"new_text":{"description":"New text to replace the old text with.","type":"string"},"old_text":{"description":"Exact text to find and replace in the file. Must match exactly (including whitespace).","type":"string"},"path":{"description":"Path to the file to edit. Can be absolute or relative to the current directory.","type":"string"}},"required":["path","old_text","new_text"],"type":"object"},"name":"edit_file"},{"description":"List all files and directories in a specified path. Use this to explore the project structure.","input_schema":{"properties":{"path":{"description":"Path to the directory to list. Can be absolute or relative to the current directory. Use '.' for the current directory.","type":"string"}},"required":["path"],"type":"object"},"name":"list_files"},{"description":"Create a new directory. Use this to organize files into new directories.","input_schema":{"properties":{"path":{"description":"Path for the new directory. Can be absolute or relative to the current directory.","type":"string"}},"required":["path"],"type":"object"},"name":"create_dir"},{"description":"Delete a file from the filesystem. Use with caution as this cannot be undone.","input_schema":{"properties":{"path":{"description":"Path to the file to delete. Can be absolute or relative to the current directory.","type":"string"}},"required":["path"],"type":"object"},"name":"delete_file"}]}
