//! Theater Message Server Handler
//!
//! Provides actor-to-actor messaging capabilities including:
//! - One-way send messages
//! - Request-response patterns
//! - Bidirectional channels

use theater::actor::handle::ActorHandle;
use theater::actor::store::ActorStore;
use theater::actor::types::{ActorError, WitActorError};
use theater::config::permissions::MessageServerPermissions;
use theater::events::message::MessageEventData;
use theater::events::{ChainEventData, EventData};
use theater::handler::Handler;
use theater::messages::{
    ActorChannelClose, ActorChannelInitiated, ActorChannelMessage, ActorChannelOpen,
    ActorLifecycleEvent, ActorMessage, ActorRequest, ActorSend, ChannelId, ChannelParticipant,
    MessageCommand,
};
use theater::shutdown::ShutdownReceiver;
use theater::wasm::{ActorComponent, ActorInstance};
use theater::TheaterId;

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use thiserror::Error;
use tokio::sync::mpsc::{Receiver, Sender};
use tracing::{debug, error, info, warn};
use uuid::Uuid;
use wasmtime::component::{ComponentType, Lift, Lower};
use wasmtime::StoreContextMut;

/// Errors that can occur during message server operations
#[derive(Error, Debug)]
pub enum MessageServerError {
    #[error("Handler error: {0}")]
    HandlerError(String),

    #[error("Actor error: {0}")]
    ActorError(#[from] ActorError),

    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),
}

/// Channel acceptance response
#[derive(Debug, Deserialize, Serialize, ComponentType, Lift, Lower)]
#[component(record)]
pub struct ChannelAccept {
    pub accepted: bool,
    pub message: Option<Vec<u8>>,
}

/// State for a single channel
#[derive(Clone)]
struct ChannelState {
    is_open: bool,
}

/// Commands sent to the MessageRouter task
enum RouterCommand {
    RegisterActor {
        actor_id: TheaterId,
        mailbox_tx: Sender<ActorMessage>,
        response_tx: tokio::sync::oneshot::Sender<()>,
    },
    UnregisterActor {
        actor_id: TheaterId,
    },
    RouteMessage {
        command: MessageCommand,
    },
}

/// High-throughput message router using channel-based architecture (no locks!)
///
/// This router runs as a single task that owns the actor registry HashMap.
/// All operations go through message passing, eliminating lock contention.
/// Can handle 100k+ messages/sec with zero blocking.
#[derive(Clone)]
pub struct MessageRouter {
    command_tx: Sender<RouterCommand>,
}

impl MessageRouter {
    /// Create a new MessageRouter and spawn its background task
    pub fn new() -> Self {
        let (command_tx, command_rx) = tokio::sync::mpsc::channel(10000);

        // Spawn the router task that owns the actor registry
        tokio::spawn(Self::router_task(command_rx));

        Self { command_tx }
    }

    /// Register an actor with the router
    pub async fn register_actor(&self, actor_id: TheaterId, mailbox_tx: Sender<ActorMessage>) -> Result<()> {
        let (response_tx, response_rx) = tokio::sync::oneshot::channel();

        self.command_tx.send(RouterCommand::RegisterActor {
            actor_id,
            mailbox_tx,
            response_tx,
        }).await.map_err(|e| anyhow::anyhow!("Failed to send register command: {}", e))?;

        response_rx.await.map_err(|e| anyhow::anyhow!("Failed to receive registration confirmation: {}", e))?;

        Ok(())
    }

    /// Unregister an actor from the router
    pub async fn unregister_actor(&self, actor_id: TheaterId) {
        let _ = self.command_tx.send(RouterCommand::UnregisterActor { actor_id }).await;
    }

    /// Route a message command to the appropriate actor
    pub async fn route_message(&self, command: MessageCommand) -> Result<()> {
        self.command_tx.send(RouterCommand::RouteMessage { command })
            .await
            .map_err(|e| anyhow::anyhow!("Failed to send route command: {}", e))?;

        Ok(())
    }

    /// Main router task - owns the actor registry, zero lock contention!
    async fn router_task(mut command_rx: Receiver<RouterCommand>) {
        info!("MessageRouter task started");

        // This HashMap is owned by this task - no Arc, no RwLock needed!
        let mut actors: HashMap<TheaterId, Sender<ActorMessage>> = HashMap::new();

        while let Some(cmd) = command_rx.recv().await {
            match cmd {
                RouterCommand::RegisterActor { actor_id, mailbox_tx, response_tx } => {
                    info!("Router: Registering actor {}", actor_id);
                    actors.insert(actor_id, mailbox_tx);
                    let _ = response_tx.send(());
                }

                RouterCommand::UnregisterActor { actor_id } => {
                    info!("Router: Unregistering actor {}", actor_id);
                    actors.remove(&actor_id);
                }

                RouterCommand::RouteMessage { command } => {
                    if let Err(e) = Self::handle_route_command(&actors, command).await {
                        error!("Router: Failed to route message: {}", e);
                    }
                }
            }
        }

        info!("MessageRouter task stopped");
    }

    /// Handle routing a MessageCommand to the appropriate actor
    async fn handle_route_command(
        actors: &HashMap<TheaterId, Sender<ActorMessage>>,
        command: MessageCommand,
    ) -> Result<()> {
        match command {
            MessageCommand::SendMessage { target_id, message, response_tx } => {
                if let Some(mailbox) = actors.get(&target_id) {
                    mailbox.send(message).await
                        .map_err(|e| anyhow::anyhow!("Failed to send to mailbox: {}", e))?;
                    let _ = response_tx.send(Ok(()));
                } else {
                    let _ = response_tx.send(Err(anyhow::anyhow!("Actor not found: {}", target_id)));
                }
            }

            MessageCommand::OpenChannel { target_id, channel_id, initiator_id, initial_message, response_tx } => {
                // Extract actor ID from ChannelParticipant
                let actor_id = match &target_id {
                    ChannelParticipant::Actor(id) => id,
                    ChannelParticipant::External => {
                        let _ = response_tx.send(Err(anyhow::anyhow!("Cannot open channel to external participant")));
                        return Ok(());
                    }
                };

                if let Some(mailbox) = actors.get(actor_id) {
                    let msg = ActorMessage::ChannelOpen(ActorChannelOpen {
                        channel_id,
                        initiator_id,
                        response_tx,
                        initial_msg: initial_message,
                    });
                    mailbox.send(msg).await
                        .map_err(|e| anyhow::anyhow!("Failed to send channel open: {}", e))?;
                } else {
                    let _ = response_tx.send(Err(anyhow::anyhow!("Actor not found: {}", target_id)));
                }
            }

            MessageCommand::ChannelMessage { channel_id, message, response_tx } => {
                // TODO: Implement channel message routing
                let _ = response_tx.send(Err(anyhow::anyhow!("Channel message routing not yet implemented")));
            }

            MessageCommand::ChannelClose { channel_id, response_tx } => {
                // TODO: Implement channel close routing
                let _ = response_tx.send(Err(anyhow::anyhow!("Channel close routing not yet implemented")));
            }
        }

        Ok(())
    }
}

/// Per-actor MessageServerHandler that provides actor-to-actor communication.
///
/// Architecture:
/// - Each actor gets its own handler instance (via create_instance)
/// - Handler registers the actor's mailbox with the global MessageRouter
/// - Host functions send MessageCommand to the router for routing
/// - Mailbox consumption happens in start() until shutdown
///
/// Enables actors to:
/// - Send one-way messages
/// - Make request-response calls
/// - Open bidirectional channels
/// - Manage outstanding requests
#[derive(Clone)]
pub struct MessageServerHandler {
    // Reference to the global message router (external service)
    router: MessageRouter,

    // This actor's ID (set in setup_host_functions)
    actor_id: Option<TheaterId>,

    // This actor's mailbox receiver (set in setup_host_functions, consumed in start)
    mailbox_rx: Arc<Mutex<Option<Receiver<ActorMessage>>>>,

    // Request-response tracking for this actor
    outstanding_requests: Arc<Mutex<HashMap<String, tokio::sync::oneshot::Sender<Vec<u8>>>>>,

    #[allow(dead_code)]
    permissions: Option<MessageServerPermissions>,
}

impl MessageServerHandler {
    /// Create a new MessageServerHandler with a reference to the global router
    ///
    /// # Arguments
    /// * `permissions` - Optional permission restrictions
    /// * `router` - Reference to the global MessageRouter
    pub fn new(
        permissions: Option<MessageServerPermissions>,
        router: MessageRouter,
    ) -> Self {
        Self {
            router,
            actor_id: None,
            mailbox_rx: Arc::new(Mutex::new(None)),
            outstanding_requests: Arc::new(Mutex::new(HashMap::new())),
            permissions,
        }
    }

    /// Process a message for THIS actor
    async fn process_actor_message(
        mut lifecycle_rx: Receiver<ActorLifecycleEvent>,
        actor_registry: Arc<tokio::sync::RwLock<HashMap<TheaterId, ActorRegistryEntry>>>,
    ) {
        info!("Message-server lifecycle processor started");

        while let Some(event) = lifecycle_rx.recv().await {
            match event {
                ActorLifecycleEvent::ActorSpawned { actor_id, actor_handle } => {
                    info!("Registering actor: {}", actor_id);

                    // Create mailbox for this actor
                    let (mailbox_tx, mailbox_rx) = tokio::sync::mpsc::channel(100);

                    // Register in our registry
                    let entry = ActorRegistryEntry {
                        actor_id: actor_id.clone(),
                        mailbox_tx: mailbox_tx.clone(),
                        actor_handle: actor_handle.clone(),
                        channels: HashSet::new(),
                    };

                    actor_registry.write().await.insert(actor_id.clone(), entry);

                    // Spawn consumer task for this actor's mailbox
                    tokio::spawn(Self::consume_actor_mailbox(
                        actor_id,
                        mailbox_rx,
                        actor_handle,
                    ));
                }
                ActorLifecycleEvent::ActorStopped { actor_id } => {
                    info!("Unregistering actor: {}", actor_id);
                    actor_registry.write().await.remove(&actor_id);
                }
            }
        }

        info!("Message-server lifecycle processor stopped");
    }

    /// Consume messages from an actor's mailbox
    async fn consume_actor_mailbox(
        actor_id: TheaterId,
        mut mailbox_rx: Receiver<ActorMessage>,
        actor_handle: ActorHandle,
    ) {
        info!("Mailbox consumer started for: {}", actor_id);

        while let Some(msg) = mailbox_rx.recv().await {
            if let Err(e) = Self::process_actor_message(msg, &actor_handle).await {
                error!("Error processing message for {}: {}", actor_id, e);
            }
        }

        info!("Mailbox consumer stopped for: {}", actor_id);
    }

    /// Process a message for a specific actor
    async fn process_actor_message(
        msg: ActorMessage,
        actor_handle: &ActorHandle,
    ) -> Result<(), MessageServerError> {
        match msg {
            ActorMessage::Send(ActorSend { data }) => {
                actor_handle
                    .call_function::<(Vec<u8>,), ()>(
                        "theater:simple/message-server-client.handle-send".to_string(),
                        (data,),
                    )
                    .await?;
            }
            ActorMessage::Request(ActorRequest { response_tx, data }) => {
                let response = actor_handle
                    .call_function::<(Vec<u8>,), (Vec<u8>,)>(
                        "theater:simple/message-server-client.handle-request".to_string(),
                        (data,),
                    )
                    .await?;
                let _ = response_tx.send(response.0);
            }
            ActorMessage::ChannelOpen(ActorChannelOpen {
                channel_id,
                initiator_id,
                response_tx,
                initial_msg,
            }) => {
                let accept = actor_handle
                    .call_function::<(String, String, Vec<u8>), (bool,)>(
                        "theater:simple/message-server-client.handle-channel-open".to_string(),
                        (
                            channel_id.to_string(),
                            initiator_id.to_string(),
                            initial_msg,
                        ),
                    )
                    .await?;
                let _ = response_tx.send(Ok(accept.0));
            }
            ActorMessage::ChannelMessage(ActorChannelMessage { channel_id, msg }) => {
                actor_handle
                    .call_function::<(String, Vec<u8>), ()>(
                        "theater:simple/message-server-client.handle-channel-message".to_string(),
                        (channel_id.to_string(), msg),
                    )
                    .await?;
            }
            ActorMessage::ChannelClose(ActorChannelClose { channel_id }) => {
                actor_handle
                    .call_function::<(String,), ()>(
                        "theater:simple/message-server-client.handle-channel-close".to_string(),
                        (channel_id.to_string(),),
                    )
                    .await?;
            }
            ActorMessage::ChannelInitiated(_) => {
                // Handle channel initiation if needed
            }
        }
        Ok(())
    }

    /// Process message commands from host functions
    async fn process_message_commands(
        mut command_rx: Receiver<MessageCommand>,
        actor_registry: Arc<tokio::sync::RwLock<HashMap<TheaterId, ActorRegistryEntry>>>,
    ) {
        info!("Message command processor started");

        while let Some(command) = command_rx.recv().await {
            match command {
                MessageCommand::SendMessage {
                    target_id,
                    message,
                    response_tx,
                } => {
                    let result = {
                        let registry = actor_registry.read().await;
                        if let Some(entry) = registry.get(&target_id) {
                            entry
                                .mailbox_tx
                                .send(message)
                                .await
                                .map_err(|e| anyhow::anyhow!("Failed to send: {}", e))
                        } else {
                            Err(anyhow::anyhow!("Actor not found: {}", target_id))
                        }
                    };
                    let _ = response_tx.send(result);
                }
                MessageCommand::OpenChannel {
                    initiator_id,
                    target_id,
                    channel_id,
                    initial_message,
                    response_tx,
                } => {
                    let result = {
                        let registry = actor_registry.read().await;

                        // Find target actor
                        let target_actor_id = match target_id {
                            ChannelParticipant::Actor(id) => id,
                            ChannelParticipant::External => {
                                let _ = response_tx.send(Err(anyhow::anyhow!(
                                    "External participants not yet supported"
                                )));
                                continue;
                            }
                        };

                        if let Some(entry) = registry.get(&target_actor_id) {
                            let (oneshot_tx, oneshot_rx) = tokio::sync::oneshot::channel();
                            let open_msg = ActorMessage::ChannelOpen(ActorChannelOpen {
                                channel_id,
                                initiator_id,
                                response_tx: oneshot_tx,
                                initial_msg: initial_message,
                            });

                            // Send to target's mailbox
                            if let Err(e) = entry.mailbox_tx.send(open_msg).await {
                                Err(anyhow::anyhow!("Failed to send channel open: {}", e))
                            } else {
                                // Wait for response
                                match oneshot_rx.await {
                                    Ok(result) => result,
                                    Err(e) => Err(anyhow::anyhow!("Channel open response error: {}", e)),
                                }
                            }
                        } else {
                            Err(anyhow::anyhow!("Target actor not found: {}", target_actor_id))
                        }
                    };
                    let _ = response_tx.send(result);
                }
                MessageCommand::ChannelMessage {
                    channel_id,
                    message,
                    response_tx,
                } => {
                    // TODO: Route to appropriate actor based on channel
                    let _ = response_tx.send(Err(anyhow::anyhow!(
                        "Channel message routing not yet implemented for channel: {}",
                        channel_id
                    )));
                }
                MessageCommand::ChannelClose {
                    channel_id,
                    response_tx,
                } => {
                    // TODO: Route to appropriate actor based on channel
                    let _ = response_tx.send(Err(anyhow::anyhow!(
                        "Channel close routing not yet implemented for channel: {}",
                        channel_id
                    )));
                }
            }
        }

        info!("Message command processor stopped");
    }
}

impl Handler for MessageServerHandler {
    fn create_instance(&self) -> Box<dyn Handler> {
        Box::new(self.clone())
    }

    fn name(&self) -> &str {
        "message-server"
    }

    fn imports(&self) -> Option<String> {
        Some("theater:simple/message-server-host".to_string())
    }

    fn exports(&self) -> Option<String> {
        Some("theater:simple/message-server-client".to_string())
    }

    fn setup_host_functions(&mut self, actor_component: &mut ActorComponent) -> Result<()> {
        info!("Setting up message server host functions");

        // Record setup start
        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::HandlerSetupStart),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Starting message server host function setup".to_string()),
        });

        let mut interface = match actor_component
            .linker
            .instance("theater:simple/message-server-host")
        {
            Ok(interface) => {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::LinkerInstanceSuccess),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(
                        "Successfully created linker instance for message-server-host".to_string(),
                    ),
                });
                interface
            }
            Err(e) => {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "linker_instance".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!("Failed to create linker instance: {}", e)),
                });
                return Err(anyhow::anyhow!(
                    "Could not instantiate theater:simple/message-server-host: {}",
                    e
                ));
            }
        };

        // 1. send operation
        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "send".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'send' function wrapper".to_string()),
        });

        let message_command_tx = self.message_command_tx.clone();

        interface
            .func_wrap_async(
                "send",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (address, msg): (String, Vec<u8>)|
                      -> Box<dyn Future<Output = Result<(Result<(), String>,)>> + Send> {
                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/send".to_string(),
                        data: EventData::Message(MessageEventData::SendMessageCall {
                            recipient: address.clone(),
                            message_type: "binary".to_string(),
                            data: msg.clone(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!("Sending message to {}", address)),
                    });

                    info!("Sending message to actor: {}", address);
                    let target_id = match TheaterId::parse(&address) {
                        Ok(id) => id,
                        Err(e) => {
                            let err_msg = format!("Failed to parse actor ID: {}", e);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/send"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "send".to_string(),
                                    recipient: Some(address.clone()),
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Error sending message to {}: {}",
                                    address, err_msg
                                )),
                            });
                            return Box::new(async move { Ok((Err(err_msg),)) });
                        }
                    };

                    let (response_tx, response_rx) = tokio::sync::oneshot::channel();
                    let command = MessageCommand::SendMessage {
                        target_id,
                        message: ActorMessage::Send(ActorSend { data: msg.clone() }),
                        response_tx,
                    };

                    let message_command_tx = message_command_tx.clone();
                    let address_clone = address.clone();

                    Box::new(async move {
                        if let Err(e) = message_command_tx.send(command).await {
                            let err = e.to_string();
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/send"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "send".to_string(),
                                    recipient: Some(address_clone.clone()),
                                    message: err.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Failed to send command to message-server: {}",
                                    err
                                )),
                            });
                            return Ok((Err(err),));
                        }

                        match response_rx.await {
                            Ok(Ok(())) => {
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/send"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::SendMessageResult {
                                        recipient: address_clone.clone(),
                                        success: true,
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Successfully sent message to {}",
                                        address_clone
                                    )),
                                });
                                Ok((Ok(()),))
                            }
                            Ok(Err(e)) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/send"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "send".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to send message to {}: {}",
                                        address_clone, err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                            Err(e) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/send"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "send".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to receive response from message-server: {}",
                                        err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "send_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'send' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async send function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "send".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Successfully set up 'send' function wrapper".to_string()),
        });

        // 2. request operation
        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "request".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'request' function wrapper".to_string()),
        });

        let message_command_tx = self.message_command_tx.clone();

        interface
            .func_wrap_async(
                "request",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (address, msg): (String, Vec<u8>)|
                      -> Box<dyn Future<Output = Result<(Result<Vec<u8>, String>,)>> + Send> {
                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/request".to_string(),
                        data: EventData::Message(MessageEventData::RequestMessageCall {
                            recipient: address.clone(),
                            message_type: "binary".to_string(),
                            data: msg.clone(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!("Requesting message from {}", address)),
                    });

                    let message_command_tx = message_command_tx.clone();
                    let address_clone = address.clone();

                    Box::new(async move {
                        let target_id = match TheaterId::parse(&address) {
                            Ok(id) => id,
                            Err(e) => {
                                let err_msg = format!("Failed to parse actor ID: {}", e);
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/request"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "request".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err_msg.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Error requesting message from {}: {}",
                                        address_clone, err_msg
                                    )),
                                });
                                return Ok((Err(err_msg),));
                            }
                        };

                        let (response_tx, response_rx) = tokio::sync::oneshot::channel();
                        let (cmd_response_tx, cmd_response_rx) = tokio::sync::oneshot::channel();

                        let command = MessageCommand::SendMessage {
                            target_id,
                            message: ActorMessage::Request(ActorRequest {
                                data: msg,
                                response_tx,
                            }),
                            response_tx: cmd_response_tx,
                        };

                        if let Err(e) = message_command_tx.send(command).await {
                            let err = e.to_string();
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/request"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "request".to_string(),
                                    recipient: Some(address_clone.clone()),
                                    message: err.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Failed to send command to message-server: {}",
                                    err
                                )),
                            });
                            return Ok((Err(err),));
                        }

                        // Wait for command response
                        match cmd_response_rx.await {
                            Ok(Ok(())) => {
                                // Command sent successfully, now wait for actor response
                                match response_rx.await {
                                    Ok(response) => {
                                        ctx.data_mut().record_event(ChainEventData {
                                            event_type: "theater:simple/message-server-host/request"
                                                .to_string(),
                                            data: EventData::Message(
                                                MessageEventData::RequestMessageResult {
                                                    recipient: address_clone.clone(),
                                                    data: response.clone(),
                                                    success: true,
                                                },
                                            ),
                                            timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                            description: Some(format!(
                                                "Successfully received response from {}",
                                                address_clone
                                            )),
                                        });
                                        Ok((Ok(response),))
                                    }
                                    Err(e) => {
                                        let err = e.to_string();
                                        ctx.data_mut().record_event(ChainEventData {
                                            event_type: "theater:simple/message-server-host/request"
                                                .to_string(),
                                            data: EventData::Message(MessageEventData::Error {
                                                operation: "request".to_string(),
                                                recipient: Some(address_clone.clone()),
                                                message: err.clone(),
                                            }),
                                            timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                            description: Some(format!(
                                                "Failed to receive response from {}: {}",
                                                address_clone, err
                                            )),
                                        });
                                        Ok((Err(err),))
                                    }
                                }
                            }
                            Ok(Err(e)) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/request"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "request".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to send request to {}: {}",
                                        address_clone, err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                            Err(e) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/request"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "request".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to receive command response from message-server: {}",
                                        err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "request_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'request' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async request function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "request".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Successfully set up 'request' function wrapper".to_string()),
        });

        // 3. list-outstanding-requests operation
        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "list-outstanding-requests".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some(
                "Setting up 'list-outstanding-requests' function wrapper".to_string(),
            ),
        });

        let outstanding_requests = self.outstanding_requests.clone();

        interface
            .func_wrap_async(
                "list-outstanding-requests",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      _: ()|
                      -> Box<dyn Future<Output = Result<(Vec<String>,)>> + Send> {
                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/list-outstanding-requests"
                            .to_string(),
                        data: EventData::Message(MessageEventData::ListOutstandingRequestsCall {}),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some("Listing outstanding requests".to_string()),
                    });

                    let outstanding_clone = outstanding_requests.clone();
                    Box::new(async move {
                        let requests = outstanding_clone.lock().unwrap();
                        let ids: Vec<String> = requests.keys().cloned().collect();

                        ctx.data_mut().record_event(ChainEventData {
                            event_type:
                                "theater:simple/message-server-host/list-outstanding-requests"
                                    .to_string(),
                            data: EventData::Message(
                                MessageEventData::ListOutstandingRequestsResult {
                                    request_count: ids.len(),
                                    request_ids: ids.clone(),
                                },
                            ),
                            timestamp: chrono::Utc::now().timestamp_millis() as u64,
                            description: Some(format!("Found {} outstanding requests", ids.len())),
                        });

                        Ok((ids,))
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "list_outstanding_requests_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'list-outstanding-requests' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!(
                    "Failed to wrap async list-outstanding-requests function: {}",
                    e
                )
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "list-outstanding-requests".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some(
                "Successfully set up 'list-outstanding-requests' function wrapper".to_string(),
            ),
        });

        // 4. respond-to-request operation
        let outstanding_requests = self.outstanding_requests.clone();

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "respond-to-request".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'respond-to-request' function wrapper".to_string()),
        });

        interface
            .func_wrap_async(
                "respond-to-request",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (request_id, response_data): (String, Vec<u8>)|
                      -> Box<dyn Future<Output = Result<(Result<(), String>,)>> + Send> {
                    let request_id_clone = request_id.clone();

                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/respond-to-request"
                            .to_string(),
                        data: EventData::Message(MessageEventData::RespondToRequestCall {
                            request_id: request_id.clone(),
                            response_size: response_data.len(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!("Responding to request {}", request_id)),
                    });

                    let outstanding_clone = outstanding_requests.clone();
                    Box::new(async move {
                        let mut requests = outstanding_clone.lock().unwrap();
                        if let Some(sender) = requests.remove(&request_id) {
                            match sender.send(response_data) {
                                Ok(_) => {
                                    ctx.data_mut().record_event(ChainEventData {
                                        event_type:
                                            "theater:simple/message-server-host/respond-to-request"
                                                .to_string(),
                                        data: EventData::Message(
                                            MessageEventData::RespondToRequestResult {
                                                request_id: request_id_clone.clone(),
                                                success: true,
                                            },
                                        ),
                                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                        description: Some(format!(
                                            "Successfully responded to request {}",
                                            request_id_clone
                                        )),
                                    });
                                    Ok((Ok(()),))
                                }
                                Err(e) => {
                                    let err_msg = format!("Failed to send response: {:?}", e);
                                    ctx.data_mut().record_event(ChainEventData {
                                        event_type:
                                            "theater:simple/message-server-host/respond-to-request"
                                                .to_string(),
                                        data: EventData::Message(MessageEventData::Error {
                                            operation: "respond-to-request".to_string(),
                                            recipient: None,
                                            message: err_msg.clone(),
                                        }),
                                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                        description: Some(format!(
                                            "Error responding to request {}: {}",
                                            request_id_clone, err_msg
                                        )),
                                    });
                                    Ok((Err(err_msg),))
                                }
                            }
                        } else {
                            let err_msg = format!("Request ID not found: {}", request_id);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/respond-to-request"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "respond-to-request".to_string(),
                                    recipient: None,
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Request {} not found",
                                    request_id_clone
                                )),
                            });
                            Ok((Err(err_msg),))
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "respond_to_request_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'respond-to-request' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async respond-to-request function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "respond-to-request".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some(
                "Successfully set up 'respond-to-request' function wrapper".to_string(),
            ),
        });

        // 5. cancel-request operation
        let outstanding_requests = self.outstanding_requests.clone();

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "cancel-request".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'cancel-request' function wrapper".to_string()),
        });

        interface
            .func_wrap_async(
                "cancel-request",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (request_id,): (String,)|
                      -> Box<dyn Future<Output = Result<(Result<(), String>,)>> + Send> {
                    let request_id_clone = request_id.clone();

                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/cancel-request"
                            .to_string(),
                        data: EventData::Message(MessageEventData::CancelRequestCall {
                            request_id: request_id.clone(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!("Canceling request {}", request_id)),
                    });

                    let outstanding_clone = outstanding_requests.clone();
                    Box::new(async move {
                        let mut requests = outstanding_clone.lock().unwrap();
                        if requests.remove(&request_id).is_some() {
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/cancel-request"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::CancelRequestResult {
                                    request_id: request_id_clone.clone(),
                                    success: true,
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Successfully canceled request {}",
                                    request_id_clone
                                )),
                            });
                            Ok((Ok(()),))
                        } else {
                            let err_msg = format!("Request ID not found: {}", request_id);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/cancel-request"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "cancel-request".to_string(),
                                    recipient: None,
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Request {} not found",
                                    request_id_clone
                                )),
                            });
                            Ok((Err(err_msg),))
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "cancel_request_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'cancel-request' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async cancel-request function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "cancel-request".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Successfully set up 'cancel-request' function wrapper".to_string()),
        });

        // 6. open-channel operation
        let message_command_tx = self.message_command_tx.clone();

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "open-channel".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'open-channel' function wrapper".to_string()),
        });

        interface
            .func_wrap_async(
                "open-channel",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (address, initial_msg): (String, Vec<u8>)|
                      -> Box<dyn Future<Output = Result<(Result<String, String>,)>> + Send> {
                    let current_actor_id = ctx.data().id.clone();
                    let address_clone = address.clone();

                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/open-channel".to_string(),
                        data: EventData::Message(MessageEventData::OpenChannelCall {
                            recipient: address.clone(),
                            message_type: "binary".to_string(),
                            size: initial_msg.len(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!("Opening channel to {}", address)),
                    });

                    let target_id = match TheaterId::parse(&address) {
                        Ok(id) => ChannelParticipant::Actor(id),
                        Err(e) => {
                            let err_msg = format!("Failed to parse actor ID: {}", e);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/open-channel"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "open-channel".to_string(),
                                    recipient: Some(address_clone.clone()),
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Error opening channel to {}: {}",
                                    address_clone, err_msg
                                )),
                            });
                            return Box::new(async move { Ok((Err(err_msg),)) });
                        }
                    };

                    let channel_id = ChannelId::new(
                        &ChannelParticipant::Actor(current_actor_id.clone()),
                        &target_id,
                    );
                    let channel_id_str = channel_id.as_str().to_string();

                    let (response_tx, response_rx) = tokio::sync::oneshot::channel();

                    let command = MessageCommand::OpenChannel {
                        initiator_id: ChannelParticipant::Actor(current_actor_id.clone()),
                        target_id: target_id.clone(),
                        channel_id: channel_id.clone(),
                        initial_message: initial_msg.clone(),
                        response_tx,
                    };

                    let message_command_tx = message_command_tx.clone();
                    let channel_id_clone = channel_id_str.clone();

                    Box::new(async move {
                        if let Err(e) = message_command_tx.send(command).await {
                            let err_msg = format!("Failed to send command to message-server: {}", e);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/open-channel"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "open-channel".to_string(),
                                    recipient: Some(address_clone.clone()),
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Failed to send open-channel command: {}",
                                    err_msg
                                )),
                            });
                            return Ok((Err(err_msg),));
                        }

                        match response_rx.await {
                            Ok(Ok(accepted)) => {
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type:
                                        "theater:simple/message-server-host/open-channel"
                                            .to_string(),
                                    data: EventData::Message(
                                        MessageEventData::OpenChannelResult {
                                            recipient: address_clone.clone(),
                                            channel_id: channel_id_clone.clone(),
                                            accepted,
                                        },
                                    ),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Channel {} to {} {}",
                                        channel_id_clone,
                                        address_clone,
                                        if accepted { "accepted" } else { "rejected" }
                                    )),
                                });

                                if accepted {
                                    Ok((Ok(channel_id_clone),))
                                } else {
                                    Ok((Err(
                                        "Channel request rejected by target actor"
                                            .to_string(),
                                    ),))
                                }
                            }
                            Ok(Err(e)) => {
                                let err_msg = format!("Error opening channel: {}", e);
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type:
                                        "theater:simple/message-server-host/open-channel"
                                            .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "open-channel".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err_msg.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Error opening channel to {}: {}",
                                        address_clone, err_msg
                                    )),
                                });
                                Ok((Err(err_msg),))
                            }
                            Err(e) => {
                                let err_msg = format!("Failed to receive channel open response: {}", e);
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/open-channel"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "open-channel".to_string(),
                                        recipient: Some(address_clone.clone()),
                                        message: err_msg.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Error opening channel to {}: {}",
                                        address_clone, err_msg
                                    )),
                                });
                                Ok((Err(err_msg),))
                            }
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "open_channel_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'open-channel' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async open-channel function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "open-channel".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Successfully set up 'open-channel' function wrapper".to_string()),
        });

        // 7. send-on-channel operation
        let message_command_tx = self.message_command_tx.clone();

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "send-on-channel".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'send-on-channel' function wrapper".to_string()),
        });

        interface
            .func_wrap_async(
                "send-on-channel",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (channel_id_str, msg): (String, Vec<u8>)|
                      -> Box<dyn Future<Output = Result<(Result<(), String>,)>> + Send> {
                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/send-on-channel"
                            .to_string(),
                        data: EventData::Message(MessageEventData::ChannelMessageCall {
                            channel_id: channel_id_str.clone(),
                            msg: msg.clone(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!(
                            "Sending message on channel {}",
                            channel_id_str
                        )),
                    });

                    let channel_id = match ChannelId::parse(&channel_id_str) {
                        Ok(id) => id,
                        Err(e) => {
                            let err_msg = format!("Failed to parse channel ID: {}", e);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/send-on-channel"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "send-on-channel".to_string(),
                                    recipient: None,
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Error sending on channel {}: {}",
                                    channel_id_str, err_msg
                                )),
                            });
                            return Box::new(async move { Ok((Err(err_msg),)) });
                        }
                    };

                    let (response_tx, response_rx) = tokio::sync::oneshot::channel();
                    let command = MessageCommand::ChannelMessage {
                        channel_id: channel_id.clone(),
                        message: msg.clone(),
                        response_tx,
                    };

                    let message_command_tx = message_command_tx.clone();
                    let channel_id_clone = channel_id_str.clone();

                    Box::new(async move {
                        if let Err(e) = message_command_tx.send(command).await {
                            let err = e.to_string();
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/send-on-channel"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "send-on-channel".to_string(),
                                    recipient: None,
                                    message: err.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Failed to send command to message-server: {}",
                                    err
                                )),
                            });
                            return Ok((Err(err),));
                        }

                        match response_rx.await {
                            Ok(Ok(())) => {
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/send-on-channel"
                                        .to_string(),
                                    data: EventData::Message(
                                        MessageEventData::ChannelMessageResult {
                                            channel_id: channel_id_clone.clone(),
                                            success: true,
                                        },
                                    ),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Successfully sent message on channel {}",
                                        channel_id_clone
                                    )),
                                });
                                Ok((Ok(()),))
                            }
                            Ok(Err(e)) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/send-on-channel"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "send-on-channel".to_string(),
                                        recipient: None,
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to send message on channel {}: {}",
                                        channel_id_clone, err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                            Err(e) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/send-on-channel"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "send-on-channel".to_string(),
                                        recipient: None,
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to receive response from message-server: {}",
                                        err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "send_on_channel_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'send-on-channel' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async send-on-channel function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "send-on-channel".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some(
                "Successfully set up 'send-on-channel' function wrapper".to_string(),
            ),
        });

        // 8. close-channel operation
        let message_command_tx = self.message_command_tx.clone();

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupStart {
                function_name: "close-channel".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Setting up 'close-channel' function wrapper".to_string()),
        });

        interface
            .func_wrap_async(
                "close-channel",
                move |mut ctx: StoreContextMut<'_, ActorStore>,
                      (channel_id_str,): (String,)|
                      -> Box<dyn Future<Output = Result<(Result<(), String>,)>> + Send> {
                    ctx.data_mut().record_event(ChainEventData {
                        event_type: "theater:simple/message-server-host/close-channel".to_string(),
                        data: EventData::Message(MessageEventData::CloseChannelCall {
                            channel_id: channel_id_str.clone(),
                        }),
                        timestamp: chrono::Utc::now().timestamp_millis() as u64,
                        description: Some(format!("Closing channel {}", channel_id_str)),
                    });

                    let channel_id = match ChannelId::parse(&channel_id_str) {
                        Ok(id) => id,
                        Err(e) => {
                            let err_msg = format!("Failed to parse channel ID: {}", e);
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/close-channel"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "close-channel".to_string(),
                                    recipient: None,
                                    message: err_msg.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Error closing channel {}: {}",
                                    channel_id_str, err_msg
                                )),
                            });
                            return Box::new(async move { Ok((Err(err_msg),)) });
                        }
                    };

                    let (response_tx, response_rx) = tokio::sync::oneshot::channel();
                    let command = MessageCommand::ChannelClose {
                        channel_id: channel_id.clone(),
                        response_tx,
                    };

                    let message_command_tx = message_command_tx.clone();
                    let channel_id_clone = channel_id_str.clone();

                    Box::new(async move {
                        if let Err(e) = message_command_tx.send(command).await {
                            let err = e.to_string();
                            ctx.data_mut().record_event(ChainEventData {
                                event_type: "theater:simple/message-server-host/close-channel"
                                    .to_string(),
                                data: EventData::Message(MessageEventData::Error {
                                    operation: "close-channel".to_string(),
                                    recipient: None,
                                    message: err.clone(),
                                }),
                                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                description: Some(format!(
                                    "Failed to send command to message-server: {}",
                                    err
                                )),
                            });
                            return Ok((Err(err),));
                        }

                        match response_rx.await {
                            Ok(Ok(())) => {
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/close-channel"
                                        .to_string(),
                                    data: EventData::Message(
                                        MessageEventData::CloseChannelResult {
                                            channel_id: channel_id_clone.clone(),
                                            success: true,
                                        },
                                    ),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Successfully closed channel {}",
                                        channel_id_clone
                                    )),
                                });
                                Ok((Ok(()),))
                            }
                            Ok(Err(e)) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/close-channel"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "close-channel".to_string(),
                                        recipient: None,
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to close channel {}: {}",
                                        channel_id_clone, err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                            Err(e) => {
                                let err = e.to_string();
                                ctx.data_mut().record_event(ChainEventData {
                                    event_type: "theater:simple/message-server-host/close-channel"
                                        .to_string(),
                                    data: EventData::Message(MessageEventData::Error {
                                        operation: "close-channel".to_string(),
                                        recipient: None,
                                        message: err.clone(),
                                    }),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    description: Some(format!(
                                        "Failed to receive response from message-server: {}",
                                        err
                                    )),
                                });
                                Ok((Err(err),))
                            }
                        }
                    })
                },
            )
            .map_err(|e| {
                actor_component.actor_store.record_event(ChainEventData {
                    event_type: "message-server-setup".to_string(),
                    data: EventData::Message(MessageEventData::HandlerSetupError {
                        error: e.to_string(),
                        step: "close_channel_function_wrap".to_string(),
                    }),
                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                    description: Some(format!(
                        "Failed to set up 'close-channel' function wrapper: {}",
                        e
                    )),
                });
                anyhow::anyhow!("Failed to wrap async close-channel function: {}", e)
            })?;

        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::FunctionSetupSuccess {
                function_name: "close-channel".to_string(),
            }),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some("Successfully set up 'close-channel' function wrapper".to_string()),
        });

        // Record overall setup completion
        actor_component.actor_store.record_event(ChainEventData {
            event_type: "message-server-setup".to_string(),
            data: EventData::Message(MessageEventData::HandlerSetupSuccess),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            description: Some(
                "Message server host functions setup completed successfully".to_string(),
            ),
        });

        info!("Message server host functions added");

        Ok(())
    }

    fn add_export_functions(&self, actor_instance: &mut ActorInstance) -> Result<()> {
        info!("Adding export functions for message server");

        // 1. handle-send
        actor_instance
            .register_function_no_result::<(Vec<u8>,)>(
                "theater:simple/message-server-client",
                "handle-send",
            )
            .map_err(|e| anyhow::anyhow!("Failed to register handle-send function: {}", e))?;

        // 2. handle-request
        actor_instance
            .register_function::<(String, Vec<u8>), (Option<Vec<u8>>,)>(
                "theater:simple/message-server-client",
                "handle-request",
            )
            .map_err(|e| anyhow::anyhow!("Failed to register handle-request function: {}", e))?;

        // 3. handle-channel-open
        actor_instance
            .register_function::<(String, Vec<u8>), (ChannelAccept,)>(
                "theater:simple/message-server-client",
                "handle-channel-open",
            )
            .map_err(|e| {
                anyhow::anyhow!("Failed to register handle-channel-open function: {}", e)
            })?;

        // 4. handle-channel-message
        actor_instance
            .register_function_no_result::<(String, Vec<u8>)>(
                "theater:simple/message-server-client",
                "handle-channel-message",
            )
            .map_err(|e| {
                anyhow::anyhow!("Failed to register handle-channel-message function: {}", e)
            })?;

        // 5. handle-channel-close
        actor_instance
            .register_function_no_result::<(String,)>(
                "theater:simple/message-server-client",
                "handle-channel-close",
            )
            .map_err(|e| {
                anyhow::anyhow!("Failed to register handle-channel-close function: {}", e)
            })?;

        info!("Added all export functions for message server");
        Ok(())
    }

    fn start(
        &mut self,
        _actor_handle: ActorHandle,
        mut shutdown_receiver: ShutdownReceiver,
    ) -> Pin<Box<dyn Future<Output = Result<()>> + Send>> {
        info!("Starting message server handler");

        // Take the receivers out of the Options
        let lifecycle_rx_opt = self.lifecycle_rx.lock().unwrap().take();
        let message_command_rx_opt = self.message_command_rx.lock().unwrap().take();

        // Clone state for the async tasks
        let actor_registry = self.actor_registry.clone();

        Box::pin(async move {
            // If we don't have receivers (cloned instance), just return
            let Some(lifecycle_rx) = lifecycle_rx_opt else {
                info!("Message server has no lifecycle receiver (cloned instance), not starting");
                return Ok(());
            };

            let Some(message_command_rx) = message_command_rx_opt else {
                info!("Message server has no command receiver (cloned instance), not starting");
                return Ok(());
            };

            // Spawn lifecycle processor task
            let lifecycle_handle = tokio::spawn(Self::process_lifecycle_events(
                lifecycle_rx,
                actor_registry.clone(),
            ));

            // Spawn command processor task
            let command_handle = tokio::spawn(Self::process_message_commands(
                message_command_rx,
                actor_registry.clone(),
            ));

            // Wait for shutdown signal
            shutdown_receiver.receiver.await.ok();
            info!("Message server handler received shutdown signal");

            // Tasks will complete when channels are dropped
            lifecycle_handle.abort();
            command_handle.abort();

            info!("Message server handler shutdown complete");
            Ok(())
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_server_handler_creation() {
        let (handler, _lifecycle_tx, _message_command_tx) = MessageServerHandler::new(None);

        assert_eq!(handler.name(), "message-server");
        assert_eq!(
            handler.imports(),
            Some("theater:simple/message-server-host".to_string())
        );
        assert_eq!(
            handler.exports(),
            Some("theater:simple/message-server-client".to_string())
        );
    }

    #[test]
    fn test_message_server_handler_clone() {
        let (handler, _lifecycle_tx, _message_command_tx) = MessageServerHandler::new(None);

        let cloned = handler.create_instance();
        assert_eq!(cloned.name(), "message-server");
    }
}
