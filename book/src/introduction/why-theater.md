# Why Theater?

## The Challenge of Trust in the AI-Generated Code Era

Software has always been built on a foundation of trust. We trust programmers to write correct code, organizations to review that code, and the ecosystem to catch and fix bugs. This trust model has worked reasonably well, but it's about to be severely tested.

As Large Language Models (LLMs) begin to generate more and more code, we're entering an era where much of the software running in production may never have been reviewed by human eyes. The programmer, that essential link in the chain of trust, is increasingly being replaced by an AI system with different strengths and weaknesses than a human developer.

This shift raises several critical challenges:

1. **Quality Validation**: How do we validate the correctness of code when there's simply too much of it to review?
2. **Failure Containment**: When AI-generated code fails, how do we prevent it from taking down entire systems?
3. **Debugging Complexity**: How do we debug issues in code we didn't write and may not fully understand?
4. **Security Boundaries**: How do we ensure that untrusted code can't access or manipulate data it shouldn't?

These challenges aren't merely theoretical. They represent real problems that organizations will face as they integrate more AI-generated code into their workflows.

## Shifting Trust from Code to System

The traditional approach to software reliability has been to focus on making the code itself more correct through code reviews, testing, and careful design. This approach assumes that humans will create, review, and validate the code.

Theater takes a different approach. Rather than assuming all code is trustworthy, Theater shifts trust to the system itself. By providing strong guarantees at the system level, Theater creates an environment where even potentially flawed or untrusted code can run safely.

This shift parallels other advancements in computing history:
- Type systems shifted trust from developers to compilers
- Memory management shifted trust from manual allocation to automatic systems
- Rust's borrow checker shifted trust from runtime checks to compile-time verification

Theater continues this evolution by shifting trust from code quality to system-level guarantees.

## The Three Pillars of Theater

Theater uses three key pillars to provide guarantees about code running in the system:

### 1. WebAssembly Components & Sandboxing

Theater uses WebAssembly Components as its foundation, providing:

- **Strong Isolation**: Each actor runs in its own sandbox, preventing direct access to the host system or other actors
- **Deterministic Execution**: The same inputs always produce the same outputs, making systems easier to test and debug
- **Language Agnosticism**: Actors can be written in any language that compiles to WebAssembly
- **Capability-Based Security**: Actors only get access to capabilities explicitly granted to them

### 2. Actor Model & Supervision

Taking inspiration from Erlang/OTP, Theater implements a comprehensive actor system:

- **Message Passing**: All communication happens through explicit messages
- **Hierarchical Supervision**: Parent actors monitor children and can restart them upon failure
- **Failure Isolation**: Problems in one actor don't affect siblings or unrelated parts of the system
- **Explicit Error Handling**: Error handling becomes a first-class concern in the system design

### 3. Traceability & Verification

Theater tracks all information that enters or leaves the WebAssembly sandbox:

- **Event Chain**: All system actions are recorded in a verifiable chain
- **Deterministic Replay**: Any sequence of events can be replayed exactly
- **State Verification**: Each state transition is cryptographically linked to its predecessors
- **Comprehensive Debugging**: The complete history of actor interactions is available for inspection

## Building for an AI-First World

By providing a structured environment with strong system-level guarantees, Theater enables developers to build more trustworthy systems, even when individual components might not be fully trusted. This approach is particularly valuable as we move into an era where more code is generated by AI systems.

Theater doesn't try to make AI-generated code perfect. Instead, it creates an environment where:

- The impact of bugs is contained
- Failures can be recovered from automatically
- System behavior is transparent and verifiable
- Security boundaries are enforced by the runtime

In the following chapters, we'll explore how Theater implements these principles in practice, starting with the core concepts that form the foundation of the system.
